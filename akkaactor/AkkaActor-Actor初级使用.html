<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>Actor初级使用 &mdash; 梦境迷离</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="canonical" href="https://blog.dreamylost.cn/akkaactor/AkkaActor-Actor%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8.html"><link rel="alternate" type="application/atom+xml" title="梦境迷离" href="https://blog.dreamylost.cn/feed.xml"><link rel="shortcut icon" href="https://dreamylost.cn/favicon.ico"><meta property="og:title" content="Actor初级使用"><meta name="keywords" content="梦境迷离, jxnu-liguobin"><meta name="og:keywords" content="梦境迷离, jxnu-liguobin"><meta name="description" content=""><meta name="og:description" content=""><meta property="og:url" content="https://blog.dreamylost.cn/akkaactor/AkkaActor-Actor%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8.html"><meta property="og:site_name" content="梦境迷离"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2019-10-13"> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/main.js"></script> <script data-ad-client="ca-pub-8236444920328818" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://blog.dreamylost.cn/" title="梦境迷离"><span class="octicon octicon-mark-github"></span> 梦境迷离</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://blog.dreamylost.cn/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://blog.dreamylost.cn/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://blog.dreamylost.cn/archives/" class=" site-header-nav-item" target="" title="归档">归档</a> <a href="https://blog.dreamylost.cn/open-source/" class=" site-header-nav-item" target="" title="开源">开源</a> <a href="https://blog.dreamylost.cn/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://blog.dreamylost.cn/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://blog.dreamylost.cn/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="Actor初级使用"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">Actor初级使用</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2019/10/13 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://blog.dreamylost.cn/categories/#AkkaActor" title="AkkaActor">AkkaActor</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 8860 字，约 26 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"> <img style="height:72px;width:72px" src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/images/qrcode.jpg" alt="梦境迷离" /></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" > <ins class="adsbygoogle content-header-ad" data-ad-client="ca-pub-8236444920328818" data-ad-slot="3977594606"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> <br /><article class="article-content markdown-body"><ul id="markdown-toc"><li><a href="#依赖" id="markdown-toc-依赖">依赖</a></li><li><a href="#创建actor" id="markdown-toc-创建actor">创建actor</a><ul><li><a href="#定义actor类" id="markdown-toc-定义actor类">定义Actor类</a></li><li><a href="#props使用" id="markdown-toc-props使用">Props使用</a></li><li><a href="#用props创建actor" id="markdown-toc-用props创建actor">用Props创建actor</a></li><li><a href="#值类作为构造函数参数" id="markdown-toc-值类作为构造函数参数">值类作为构造函数参数</a></li><li><a href="#依赖注入" id="markdown-toc-依赖注入">依赖注入</a></li><li><a href="#收件箱信箱" id="markdown-toc-收件箱信箱">收件箱（信箱）</a></li></ul></li><li><a href="#消息" id="markdown-toc-消息">消息</a><ul><li><a href="#发送消息" id="markdown-toc-发送消息">发送消息</a></li><li><a href="#接收消息" id="markdown-toc-接收消息">接收消息</a></li><li><a href="#回复消息" id="markdown-toc-回复消息">回复消息</a></li><li><a href="#接收超时" id="markdown-toc-接收超时">接收超时</a></li><li><a href="#定时器与定期消息" id="markdown-toc-定时器与定期消息">定时器与定期消息</a></li></ul></li><li><a href="#初始化模式" id="markdown-toc-初始化模式">初始化模式</a><ul><li><a href="#通过构造函数初始化" id="markdown-toc-通过构造函数初始化">通过构造函数初始化</a></li><li><a href="#通过预启动初始化" id="markdown-toc-通过预启动初始化">通过预启动初始化</a></li><li><a href="#通过消息传递初始化" id="markdown-toc-通过消息传递初始化">通过消息传递初始化</a></li></ul></li><li><a href="#actor与异常" id="markdown-toc-actor与异常">actor与异常</a><ul><li><a href="#对于消息来说发生了什么" id="markdown-toc-对于消息来说发生了什么">对于消息来说发生了什么</a></li><li><a href="#对于信箱邮箱来说发生了什么" id="markdown-toc-对于信箱邮箱来说发生了什么">对于信箱（邮箱）来说发生了什么</a></li><li><a href="#对于actor来说发生了什么" id="markdown-toc-对于actor来说发生了什么">对于actor来说发生了什么</a></li></ul></li><li><a href="#其他" id="markdown-toc-其他">其他</a></li></ul><h3 id="依赖">依赖</h3><p>注意是akka-actor，不是scala-actors</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">"com.typesafe.akka"</span> <span class="o">%%</span> <span class="s">"akka-actor"</span> <span class="o">%</span> <span class="s">"2.5.25"</span>
</code></pre></div></div><h3 id="创建actor">创建actor</h3><p>Akka强制执行家长监督，每个actor都受到监督，而且（潜在的）监督其子女</p><h4 id="定义actor类">定义Actor类</h4><p>actor通过扩展Actor基本特质和实现receive方法来实现。receive方法应该定义一系列case语句（其类型为PartialFunction[Any，Unit]），使用标准Scala模式匹配定义您的Actor可以处理哪些消息，以及应该如何处理消息的实现。</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">akka.actor.Actor</span>
<span class="k">import</span> <span class="nn">akka.actor.Props</span>
<span class="k">import</span> <span class="nn">akka.event.Logging</span>

<span class="k">class</span> <span class="nc">MyActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">log</span> <span class="k">=</span> <span class="nc">Logging</span><span class="o">(</span><span class="nv">context</span><span class="o">.</span><span class="py">system</span><span class="o">,</span> <span class="k">this</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">"test"</span> <span class="k">=&gt;</span> <span class="nv">log</span><span class="o">.</span><span class="py">info</span><span class="o">(</span><span class="s">"received test"</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span>      <span class="k">=&gt;</span> <span class="nv">log</span><span class="o">.</span><span class="py">info</span><span class="o">(</span><span class="s">"received unknown message"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>Akka actor的receive message消息匹配的遍历是彻底的，与Erlang和Scala Actors（已废弃）不同。这意味着您需要为它可以接受的所有消息提供模式匹配，如果您希望能够处理未知的消息，那么您需要有一个默认的case，如上面的示例所示。 否则akka.actor.UnhandledMessage(message, sender, recipient)将发布到ActorSystem的EventStream。 上面定义的行为的返回类型是Unit，如果actor应回复所收到的消息，则必须按照下文解释明确地这样做。receive方法的结果是一个部分函数对象，该对象作为其“初始行为”存储在actor中。</p><p>以下是一个例子：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">akka.actor.</span><span class="o">{</span> <span class="nc">Actor</span><span class="o">,</span> <span class="nc">ActorRef</span><span class="o">,</span> <span class="nc">ActorSystem</span><span class="o">,</span> <span class="nc">PoisonPill</span><span class="o">,</span> <span class="nc">Props</span> <span class="o">}</span>
<span class="k">import</span> <span class="nn">language.postfixOps</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">case</span> <span class="k">object</span> <span class="nc">Ping</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Pong</span>

<span class="k">class</span> <span class="nc">Pinger</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">countDown</span> <span class="k">=</span> <span class="mi">100</span>

  <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Pong</span> <span class="k">=&gt;</span>
      <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"${self.path} received pong, count down $countDown"</span><span class="o">)</span>

      <span class="nf">if</span> <span class="o">(</span><span class="n">countDown</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">countDown</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="nf">sender</span><span class="o">()</span> <span class="o">!</span> <span class="nc">Ping</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="nf">sender</span><span class="o">()</span> <span class="o">!</span> <span class="nc">PoisonPill</span>
        <span class="n">self</span> <span class="o">!</span> <span class="nc">PoisonPill</span>
      <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Ponger</span><span class="o">(</span><span class="n">pinger</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Ping</span> <span class="k">=&gt;</span>
      <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"${self.path} received ping"</span><span class="o">)</span>
      <span class="n">pinger</span> <span class="o">!</span> <span class="nc">Pong</span>
  <span class="o">}</span>
<span class="o">}</span>

    <span class="k">val</span> <span class="nv">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">"pingpong"</span><span class="o">)</span>

    <span class="k">val</span> <span class="nv">pinger</span> <span class="k">=</span> <span class="nv">system</span><span class="o">.</span><span class="py">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">Pinger</span><span class="o">],</span> <span class="s">"pinger"</span><span class="o">)</span>

    <span class="k">val</span> <span class="nv">ponger</span> <span class="k">=</span> <span class="nv">system</span><span class="o">.</span><span class="py">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">Ponger</span><span class="o">],</span> <span class="n">pinger</span><span class="o">),</span> <span class="s">"ponger"</span><span class="o">)</span>

    <span class="k">import</span> <span class="nn">system.dispatcher</span>
    <span class="nv">system</span><span class="o">.</span><span class="py">scheduler</span><span class="o">.</span><span class="py">scheduleOnce</span><span class="o">(</span><span class="mi">500</span> <span class="n">millis</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">ponger</span> <span class="o">!</span> <span class="nc">Ping</span>
    <span class="o">}</span>
</code></pre></div></div><h4 id="props使用">Props使用</h4><p>Props是一个配置类，用于指定创建actor的选项，将其看作是不可变的，因此可以自由地共享创建一个actor的配方。下面是一些如何创建Props实例的例子。</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">akka.actor.Props</span>

<span class="k">val</span> <span class="nv">props1</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">[</span><span class="kt">MyActor</span><span class="o">]</span>
<span class="k">val</span> <span class="nv">props2</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">ActorWithArgs</span><span class="o">(</span><span class="s">"arg"</span><span class="o">))</span> <span class="c1">// careful, see below</span>
<span class="k">val</span> <span class="nv">props3</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">ActorWithArgs</span><span class="o">],</span> <span class="s">"arg"</span><span class="o">)</span> <span class="c1">// no support for value class arguments</span>
</code></pre></div></div><p>第二个变体显示如何将构造函数参数传递给正在创建的actor，但它只应在行为者之外使用，如下所述。</p><p>最后一行显示了传递构造函数参数的可能性，而不管它在哪个上下文中使用。在Props对象的构造过程中，将验证匹配构造函数的存在，如果找不到或找到多个匹配的构造函数，则会导致IllegalArgumentException。</p><h4 id="用props创建actor">用Props创建actor</h4><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">akka.actor.ActorSystem</span>

<span class="c1">// ActorSystem is a heavy object: create only one per application</span>
<span class="k">val</span> <span class="nv">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">"mySystem"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">myActor</span> <span class="k">=</span> <span class="nv">system</span><span class="o">.</span><span class="py">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">MyActor</span><span class="o">],</span> <span class="s">"myactor2"</span><span class="o">)</span>
</code></pre></div></div><p>使用ActorSystem将创建顶级actor，由actor系统的监护人提供监督，而使用actor的上下文将创造出一个子actor。</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FirstActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">child</span> <span class="k">=</span> <span class="nv">context</span><span class="o">.</span><span class="py">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">MyActor</span><span class="o">],</span> <span class="n">name</span> <span class="k">=</span> <span class="s">"myChild"</span><span class="o">)</span>
  <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="nf">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">x</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>对ActorOf的调用返回ActorRef的一个实例。这是actor实例的句柄，也是与其交互的唯一方法。ActorRef是不可变的，并且与它所代表的actor有一对一的关系。 ActorRef也是可序列化和网络感知的。这意味着您可以序列化它，通过线路发送它，并在远程主机上使用它，它仍然代表着网络上原始节点上的同一个actor。</p><h4 id="值类作为构造函数参数">值类作为构造函数参数</h4><p>实例化actor props的推荐方法是在运行时使用反射来确定要调用的正确的actor构造函数，并且由于技术上的限制，当所述构造函数接受属于值类的参数时，不支持这种方法。 在这些情况下，您应该打开参数包装，或者通过手动调用构造函数来创建props：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Argument</span><span class="o">(</span><span class="k">val</span> <span class="nv">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span>
<span class="k">class</span> <span class="nc">ValueClassActor</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span> <span class="kt">Argument</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">{</span> <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="o">()</span> <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">ValueClassActor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">props1</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span> <span class="kt">Argument</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">ValueClassActor</span><span class="o">],</span> <span class="n">arg</span><span class="o">)</span> <span class="c1">// fails at runtime</span>
  <span class="k">def</span> <span class="nf">props2</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span> <span class="kt">Argument</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">ValueClassActor</span><span class="o">],</span> <span class="nv">arg</span><span class="o">.</span><span class="py">value</span><span class="o">)</span> <span class="c1">// ok</span>
  <span class="k">def</span> <span class="nf">props3</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span> <span class="kt">Argument</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">ValueClassActor</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="c1">// ok</span>
<span class="o">}</span>
</code></pre></div></div><h4 id="依赖注入">依赖注入</h4><p>如果您的actor有一个接受参数的构造函数，那么这些参数也需要作为props的一部分，如前所述。 但是，在某些情况下，必须使用工厂方法，例如，实际的构造函数参数由依赖项注入框架确定。</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">akka.actor.IndirectActorProducer</span>

<span class="k">class</span> <span class="nc">DependencyInjector</span><span class="o">(</span><span class="n">applicationContext</span><span class="k">:</span> <span class="kt">AnyRef</span><span class="o">,</span> <span class="n">beanName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">IndirectActorProducer</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="nf">actorClass</span> <span class="k">=</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">Actor</span><span class="o">]</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">produce</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Echo</span><span class="o">(</span><span class="n">beanName</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">this</span><span class="o">(</span><span class="n">beanName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nf">this</span><span class="o">(</span><span class="s">""</span><span class="o">,</span> <span class="n">beanName</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">actorRef</span> <span class="k">=</span> <span class="nv">system</span><span class="o">.</span><span class="py">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">DependencyInjector</span><span class="o">],</span> <span class="n">applicationContext</span><span class="o">,</span> <span class="s">"hello"</span><span class="o">),</span> <span class="s">"helloBean"</span><span class="o">)</span>
</code></pre></div></div><p>有时，您可能会想提供一个IndirectActorProducer，它总是返回相同的实例，例如使用惰性val。 这是不支持的，因为它违背了actor重新启动的含义。</p><p>当使用依赖项注入框架时，actor bean不能有单例作用域。</p><h4 id="收件箱信箱">收件箱（信箱）</h4><p>当编写与actor通信的外部代码时，ask模式可以是解决方案（见下文），但它不能做两件事：接收多个答复（例如，通过订阅ActorRef）和监视其他actor的生命周期。为此目的，有Inbox class：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">akka.actor.ActorDSL._</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">i</span> <span class="k">=</span> <span class="nf">inbox</span><span class="o">()</span>
<span class="n">echo</span> <span class="o">!</span> <span class="s">"hello"</span>
<span class="nv">i</span><span class="o">.</span><span class="py">receive</span><span class="o">()</span> <span class="n">should</span> <span class="o">===(</span><span class="s">"hello"</span><span class="o">)</span>
</code></pre></div></div><p>有一个从收件箱到actor引用的隐式转换，这意味着在本例中，发送方引用将是隐藏在收件箱中的actor的引用。这允许在最后一行接收答复。看actor也很简单：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">target</span> <span class="k">=</span> <span class="c1">// some actor</span>
<span class="k">val</span> <span class="nv">i</span> <span class="k">=</span> <span class="nf">inbox</span><span class="o">()</span>
<span class="nv">i</span><span class="o">.</span><span class="py">watch</span><span class="o">(</span><span class="n">target</span><span class="o">)</span>
</code></pre></div></div><h3 id="消息">消息</h3><h4 id="发送消息">发送消息</h4><p>通过下列方法之一向Actor发送消息。</p><ul><li>! 意思是“触发和遗忘”，例如异步发送消息并立即返回。又称tell</li><li>? 异步发送消息并返回Future代表可能的答复。又称ask</li></ul><p>这是发送消息的首选方式，不要阻塞等待消息，因为这提供了最佳的并发性和可伸缩性特征。</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">actorRef</span> <span class="o">!</span> <span class="n">message</span>
</code></pre></div></div><p>如果从Actor内部调用，则发送者actor的引用将与消息一起隐式传递，并在其sender(): ActorRef成员方法中对目标actor可用，接受者可用它来回复原始发送方，方法是sender() ! replyMsg</p><h4 id="接收消息">接收消息</h4><p>actor必须实现receive方法来接收消息：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="nc">PartialFunction</span><span class="o">[</span><span class="kt">Any</span>, <span class="kt">Unit</span><span class="o">]</span>

<span class="k">def</span> <span class="nf">receive</span><span class="k">:</span> <span class="kt">Actor.Receive</span>
</code></pre></div></div><p>此方法返回PartialFunction，例如，使用Scala模式匹配将消息与不同的case子句相匹配的“Match/case”子句。以下是一个例子：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">akka.actor.Actor</span>
<span class="k">import</span> <span class="nn">akka.actor.Props</span>
<span class="k">import</span> <span class="nn">akka.event.Logging</span>

<span class="k">class</span> <span class="nc">MyActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">log</span> <span class="k">=</span> <span class="nc">Logging</span><span class="o">(</span><span class="nv">context</span><span class="o">.</span><span class="py">system</span><span class="o">,</span> <span class="k">this</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">"test"</span> <span class="k">=&gt;</span> <span class="nv">log</span><span class="o">.</span><span class="py">info</span><span class="o">(</span><span class="s">"received test"</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span>      <span class="k">=&gt;</span> <span class="nv">log</span><span class="o">.</span><span class="py">info</span><span class="o">(</span><span class="s">"received unknown message"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h4 id="回复消息">回复消息</h4><p>如果您想拥有回复消息的句柄，可以使用sender() ，这给了你一个actor的ActorRef。您可以通过向ActorRef发送sender() ! replyMsg。 您还可以存储ActorRef，以便稍后回复，或传递给其他actor。如果没有发送者（消息是在没有actor或Future上下文的情况下发送的），则发送方默认为“死信”actor引用。</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">sender</span><span class="o">()</span> <span class="o">!</span> <span class="n">x</span> <span class="c1">// replies will go to this actor</span>
</code></pre></div></div><h4 id="接收超时">接收超时</h4><p>这个ActorContext setReceiveTimeout定义非活动超时，然后发送ReceiveTimeout信息被触发。 指定时，接收函数应该能够处理akka.actor.ReceiveTimeout留言。1毫秒是支持的最小超时。</p><blockquote><p>请注意，接收超时可能会在另一条消息排队后立即触发并排队ReceiveTimeout消息；因此，不能保证在接收超时，一定有通过此方法配置的空闲期间。 一旦设置，接收超时将保持有效（即在不活动期间后继续重复触发）。传入Duration.Undefined关闭此功能。</p></blockquote><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">akka.actor.ReceiveTimeout</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">class</span> <span class="nc">MyActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="c1">// To set an initial delay</span>
  <span class="nv">context</span><span class="o">.</span><span class="py">setReceiveTimeout</span><span class="o">(</span><span class="mi">30</span> <span class="n">milliseconds</span><span class="o">)</span>
  <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">"Hello"</span> <span class="k">=&gt;</span>
      <span class="c1">// To set in a response to a message</span>
      <span class="nv">context</span><span class="o">.</span><span class="py">setReceiveTimeout</span><span class="o">(</span><span class="mi">100</span> <span class="n">milliseconds</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">ReceiveTimeout</span> <span class="k">=&gt;</span>
      <span class="c1">// To turn it off</span>
      <span class="nv">context</span><span class="o">.</span><span class="py">setReceiveTimeout</span><span class="o">(</span><span class="nv">Duration</span><span class="o">.</span><span class="py">Undefined</span><span class="o">)</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="s">"Receive timed out"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h4 id="定时器与定期消息">定时器与定期消息</h4><p>可以将消息计划在以后的某个点发送，方法是使用调度器，但是当在一个actor中调度周期性或单个消息时，使用对命名计时器的支持是更方便和安全的。 当actor重新启动并由定时器处理时，调度消息的生命周期可能很难管理。</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">import</span> <span class="nn">akka.actor.Actor</span>
<span class="k">import</span> <span class="nn">akka.actor.Timers</span>

<span class="k">object</span> <span class="nc">MyActor</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">TickKey</span>
  <span class="k">private</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">FirstTick</span>
  <span class="k">private</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">Tick</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">MyActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">Timers</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">MyActor._</span>
  <span class="nv">timers</span><span class="o">.</span><span class="py">startSingleTimer</span><span class="o">(</span><span class="nc">TickKey</span><span class="o">,</span> <span class="nc">FirstTick</span><span class="o">,</span> <span class="mf">500.</span><span class="n">millis</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">FirstTick</span> <span class="k">=&gt;</span>
      <span class="c1">// do something useful here</span>
      <span class="nv">timers</span><span class="o">.</span><span class="py">startPeriodicTimer</span><span class="o">(</span><span class="nc">TickKey</span><span class="o">,</span> <span class="nc">Tick</span><span class="o">,</span> <span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Tick</span> <span class="k">=&gt;</span>
    <span class="c1">// do something useful here</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>每个定时器都有一个键，可以替换或取消。保证不会接收来自具有相同密钥的定时器上一次投递的消息，它可能已经在邮箱中排队，即使在取消或启动新计时器时。</p><p>定时器被绑定到拥有它的actor的生命周期中，因此在重新启动或停止时会自动取消。注意，TimerScheduler不是线程安全的，也就是说它只能在拥有它的actor中使用。几种定时器的比较参考本博客（“其他”分类中的三种定时器的使用），其中包括ActorSystem的定时器。</p><h3 id="初始化模式">初始化模式</h3><h4 id="通过构造函数初始化">通过构造函数初始化</h4><p>使用构造函数进行初始化有各种好处。首先，使用val字段存储在actor实例生命周期内不发生更改的任何状态成为可能，从而使actor的实现更加健壮。 当调用actorOf创建actor实例和重新启动时，就会调用该构造函数，因此，该actor的内部总是可以假定发生了适当的初始化。这也是这种方法的缺点，因为在某些情况下，人们希望避免在重启时重新初始化内部。例如，在重启过程中保持子角色通常是有用的。下面提供了这种情况的case。</p><h4 id="通过预启动初始化">通过预启动初始化</h4><p>在初始化第一个实例时，即在创建ActorRef时，只直接调用actor的方法prestart()一次。在重新启动的情况下，从postRestart()调用prestart()，因此如果不重写， 则在每次重新启动时调用prestart()。但是，通过重写postRestart()，可以禁用此行为，并确保只有一个对prestart()的调用。</p><p>此模式的一个有用用法是在重新启动期间禁用为子级创建新ActorRefs。这可以通过重写preRestart()来实现。下面是这些生命周期挂钩的默认实现：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">override</span> <span class="k">def</span> <span class="nf">preStart</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="c1">// Initialize children here</span>
<span class="o">}</span>

<span class="c1">// Overriding postRestart to disable the call to preStart()</span>
<span class="c1">// after restarts</span>
<span class="k">override</span> <span class="k">def</span> <span class="nf">postRestart</span><span class="o">(</span><span class="n">reason</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">()</span>

<span class="c1">// The default implementation of preRestart() stops all the children</span>
<span class="c1">// of the actor. To opt-out from stopping the children, we</span>
<span class="c1">// have to override preRestart()</span>
<span class="k">override</span> <span class="k">def</span> <span class="nf">preRestart</span><span class="o">(</span><span class="n">reason</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">,</span> <span class="n">message</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Any</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="c1">// Keep the call to postStop(), but no stopping of children</span>
  <span class="nf">postStop</span><span class="o">()</span>
<span class="o">}</span>
</code></pre></div></div><blockquote><p>请注意，子角色仍在重新启动，但没有创建新的ActorRef。我们可以递归地对子元素应用相同的原则，确保它们的prestart()方法只有在创建它们的refs时才被调用。</p></blockquote><h4 id="通过消息传递初始化">通过消息传递初始化</h4><p>在某些情况下，不可能在构造函数中传递actor初始化所需的所有信息，例如在循环依赖项存在时。 在这种情况下，actor应该侦听初始化消息，并使用become()或有限状态机【State(S) x Event(E) -&gt; Actions (A), State(S’)】状态转换来对actor的初始化状态和未初始化状态进行编码。</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">initializeMe</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>

<span class="k">override</span> <span class="k">def</span> <span class="nf">receive</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="s">"init"</span> <span class="k">=&gt;</span>
    <span class="n">initializeMe</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="s">"Up and running"</span><span class="o">)</span>
    <span class="nv">context</span><span class="o">.</span><span class="py">become</span><span class="o">(</span><span class="n">initialized</span><span class="o">,</span> <span class="n">discardOld</span> <span class="k">=</span> <span class="kc">true</span><span class="o">)</span>

<span class="o">}</span>

<span class="k">def</span> <span class="nf">initialized</span><span class="k">:</span> <span class="kt">Receive</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="s">"U OK?"</span> <span class="k">=&gt;</span> <span class="nv">initializeMe</span><span class="o">.</span><span class="py">foreach</span> <span class="o">{</span> <span class="nf">sender</span><span class="o">()</span> <span class="o">!</span> <span class="k">_</span> <span class="o">}</span>

</code></pre></div></div><p>如果actor可能在消息被初始化之前接收消息，则可以使用一个有用的工具来保存消息，直到初始化完成为止，然后在actor初始化后重新回复它们。</p><p>actor生命周期：</p><p><img src="../../public/image/actor1.png" alt="生命周期" /></p><h3 id="actor与异常">actor与异常</h3><p>当消息正在由actor处理时，可能会引发某种类型的异常，例如数据库异常等。</p><p>通过重写监督方法可以对异常进行必要的处理，下面是一个简单的例子：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//AllForOneStrategy，影响同级或同层所有actor</span>
  <span class="k">override</span> <span class="k">def</span> <span class="nf">supervisorStrategy</span><span class="k">:</span> <span class="kt">SupervisorStrategy</span> <span class="o">=</span> <span class="nc">AllForOneStrategy</span><span class="o">(</span><span class="n">maxNrOfRetries</span> <span class="k">=</span> <span class="mi">5</span><span class="o">,</span> <span class="nv">Duration</span><span class="o">.</span><span class="py">create</span><span class="o">(</span><span class="s">"1 minute"</span><span class="o">),</span> <span class="kc">true</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">//索引是IO操作，挂了就停止</span>
        <span class="k">case</span> <span class="k">_:</span> <span class="kt">IndexingException</span> <span class="o">=&gt;</span> <span class="nc">Escalate</span>
        
        <span class="c1">//重启，Restart不保留状态，重新抓取页面</span>
        <span class="k">case</span> <span class="n">re</span><span class="k">:</span> <span class="kt">RetrievalException</span> <span class="o">=&gt;</span> <span class="o">{</span>
            <span class="nf">if</span> <span class="o">(</span><span class="nv">re</span><span class="o">.</span><span class="py">url</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="nv">logger</span><span class="o">.</span><span class="py">warn</span><span class="o">(</span><span class="s">"url {} has an exception"</span><span class="o">,</span> <span class="nv">re</span><span class="o">.</span><span class="py">url</span><span class="o">)</span>
                <span class="nv">VisitedPageStore</span><span class="o">.</span><span class="py">finished</span><span class="o">(</span><span class="nv">re</span><span class="o">.</span><span class="py">url</span><span class="o">)</span>
            <span class="o">}</span>
            <span class="nc">Resume</span>
        <span class="o">}</span>
        <span class="c1">//代理异常，忽略</span>
        <span class="k">case</span> <span class="n">pe</span><span class="k">:</span> <span class="kt">ProxyException</span> <span class="o">=&gt;</span> <span class="o">{</span>
            <span class="nf">if</span> <span class="o">(</span><span class="nv">pe</span><span class="o">.</span><span class="py">url</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="nv">logger</span><span class="o">.</span><span class="py">warn</span><span class="o">(</span><span class="s">"url {} has an exception"</span><span class="o">,</span> <span class="nv">pe</span><span class="o">.</span><span class="py">url</span><span class="o">)</span>
                <span class="nv">VisitedPageStore</span><span class="o">.</span><span class="py">finished</span><span class="o">(</span><span class="nv">pe</span><span class="o">.</span><span class="py">url</span><span class="o">)</span>
            <span class="o">}</span>
            <span class="nc">Escalate</span>
        <span class="o">}</span>
        <span class="c1">//其他异常</span>
        <span class="k">case</span> <span class="k">_:</span> <span class="kt">Exception</span> <span class="o">=&gt;</span> <span class="nc">Stop</span>
    <span class="o">}</span>
</code></pre></div></div><h5 id="对于消息来说发生了什么">对于消息来说发生了什么</h5><p>如果在处理消息时抛出异常，则此消息将丢失。 重要的是要明白，它没有放回邮箱。因此，如果您想要重新尝试处理一条消息，您需要自己处理它，捕捉异常并重试您的流。 确保您绑定了重试次数，因为您不希望系统发生活锁（这样就会消耗大量的CPU周期而不会取得有意义的进展）。</p><h5 id="对于信箱邮箱来说发生了什么">对于信箱（邮箱）来说发生了什么</h5><p>如果在处理消息时引发异常，则邮箱不会发生任何情况。如果重新启动该actor，则将存在相同的邮箱。所以邮箱上的所有信息（消息）都会在那里而不会丢失。</p><h5 id="对于actor来说发生了什么">对于actor来说发生了什么</h5><p>如果actor中的代码抛出异常，则暂停该actor并启动监视过程（请参阅监督与监控）。 这取决于主管（上级）actor的决定，actor可以被恢复（好像什么都没发生）、也可以被重新启动（清除内部状态并从头开始）或者被终止。</p><h3 id="其他">其他</h3><p>其他特性代码，没有翻译。<a href="https://github.com/jxnu-liguobin/scala-examples/tree/master/scala-akka/src/main/scala/io/growing/akka/actor">Akka-actor examples</a></p><ul><li>Become_Actor.scala</li><li>PartialFunction_Actor.scala</li><li>Schedule_Actor.scala</li><li>Selection_Actor.scala</li><li>Stash_Actor.scala</li><li>Stop_Actor.scala</li><li>Watch_Actor.scala</li></ul><p><a href="https://doc.akka.io/docs/akka/current/actors.html">文档</a></p><ul><li>使用搜狗翻译、百度翻译、谷歌翻译，仅供参考</li><li>来自官方文档、参考《响应式架构 消息模式Actor实现与Scala、Akka应用集成》</li><li>后续随着理解深入会继续修改错误和描述，以便更好理解，本博客开源，欢迎指出错误</li></ul><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://blog.dreamylost.cn" target="_blank">梦境迷离</a></li><li>本文链接：<a href="https://blog.dreamylost.cn/akkaactor/AkkaActor-Actor%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8.html" target="_blank">https://blog.dreamylost.cn/akkaactor/AkkaActor-Actor%E5%88%9D%E7%BA%A7%E4%BD%BF%E7%94%A8.html</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/akkaactor/AkkaActor-Actor%E5%88%9D%E7%BA%A7%E4%BD', clientID: '061aadb5d449c0877d7d', clientSecret: '9aa7af7c248a7e36a07a86993e11a7acf7fbd353', repo: 'dreamylost-comments', owner: 'jxnu-liguobin', admin: ['jxnu-liguobin'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@built/assets/search_data.json?v=1697165615', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"> <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-8236444920328818" data-ad-slot="6220614560" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2019 <span title="梦境迷离">梦境迷离</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/jxnu-liguobin/jxnu-liguobin.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://blog.dreamylost.cn/" title="首页" target="">首页</a></li><li> <a href="https://blog.dreamylost.cn/categories/" title="分类" target="">分类</a></li><li> <a href="https://blog.dreamylost.cn/archives/" title="归档" target="">归档</a></li><li> <a href="https://blog.dreamylost.cn/open-source/" title="开源" target="">开源</a></li><li> <a href="https://blog.dreamylost.cn/wiki/" title="维基" target="">维基</a></li><li> <a href="https://blog.dreamylost.cn/links/" title="链接" target="">链接</a></li><li> <a href="https://blog.dreamylost.cn/about/" title="关于" target="">关于</a></li><li><a href="https://blog.dreamylost.cn/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2019-09-20 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-147390701-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
