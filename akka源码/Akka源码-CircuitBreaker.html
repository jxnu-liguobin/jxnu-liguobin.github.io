<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>CircuitBreaker &mdash; 梦境迷离</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="canonical" href="https://blog.dreamylost.cn/akka%E6%BA%90%E7%A0%81/Akka%E6%BA%90%E7%A0%81-CircuitBreaker.html"><link rel="alternate" type="application/atom+xml" title="梦境迷离" href="https://blog.dreamylost.cn/feed.xml"><link rel="shortcut icon" href="https://dreamylost.cn/favicon.ico"><meta property="og:title" content="CircuitBreaker"><meta name="keywords" content="梦境迷离, jxnu-liguobin"><meta name="og:keywords" content="梦境迷离, jxnu-liguobin"><meta name="description" content="```scala/* Copyright (C) 2009-2018 Lightbend Inc. https://www.lightbend.com*/"><meta name="og:description" content="```scala/* Copyright (C) 2009-2018 Lightbend Inc. https://www.lightbend.com*/"><meta property="og:url" content="https://blog.dreamylost.cn/akka%E6%BA%90%E7%A0%81/Akka%E6%BA%90%E7%A0%81-CircuitBreaker.html"><meta property="og:site_name" content="梦境迷离"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2020-03-20"> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/main.js"></script> <script data-ad-client="ca-pub-8236444920328818" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://blog.dreamylost.cn/" title="梦境迷离"><span class="octicon octicon-mark-github"></span> 梦境迷离</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://blog.dreamylost.cn/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://blog.dreamylost.cn/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://blog.dreamylost.cn/archives/" class=" site-header-nav-item" target="" title="归档">归档</a> <a href="https://blog.dreamylost.cn/open-source/" class=" site-header-nav-item" target="" title="开源">开源</a> <a href="https://blog.dreamylost.cn/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://blog.dreamylost.cn/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://blog.dreamylost.cn/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="CircuitBreaker"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">CircuitBreaker</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2020/03/20 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://blog.dreamylost.cn/categories/#Akka源码" title="Akka源码">Akka源码</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 19193 字，约 55 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"> <img style="height:72px;width:72px" src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/images/qrcode.jpg" alt="梦境迷离" /></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" > <ins class="adsbygoogle content-header-ad" data-ad-client="ca-pub-8236444920328818" data-ad-slot="3977594606"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> <br /><article class="article-content markdown-body"><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
* Copyright (C) 2009-2018 Lightbend Inc. &lt;https://www.lightbend.com&gt;
*/</span>

<span class="k">package</span> <span class="nn">akka.pattern</span>

<span class="k">import</span> <span class="nn">java.util.Optional</span>
<span class="k">import</span> <span class="nn">java.util.concurrent.</span><span class="o">{</span><span class="nc">Callable</span><span class="o">,</span> <span class="nc">CompletionStage</span><span class="o">,</span> <span class="nc">CopyOnWriteArrayList</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">java.util.concurrent.atomic.</span><span class="o">{</span><span class="nc">AtomicBoolean</span><span class="o">,</span> <span class="nc">AtomicInteger</span><span class="o">,</span> <span class="nc">AtomicLong</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">java.util.function.</span><span class="o">{</span><span class="nc">BiFunction</span><span class="o">,</span> <span class="nc">Consumer</span><span class="o">}</span>

<span class="k">import</span> <span class="nn">akka.AkkaException</span>
<span class="k">import</span> <span class="nn">akka.actor.Scheduler</span>
<span class="k">import</span> <span class="nn">akka.dispatch.ExecutionContexts.sameThreadExecutionContext</span>
<span class="k">import</span> <span class="nn">akka.util.JavaDurationConverters._</span>
<span class="k">import</span> <span class="nn">akka.util.Unsafe</span>

<span class="k">import</span> <span class="nn">scala.compat.java8.FutureConverters</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">scala.concurrent._</span>
<span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Failure</span><span class="o">,</span> <span class="nc">Success</span><span class="o">,</span> <span class="nc">Try</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scala.util.control.</span><span class="o">{</span><span class="nc">NonFatal</span><span class="o">,</span> <span class="nc">NoStackTrace</span><span class="o">}</span>

<span class="cm">/**
*
*1.正常运行时，断路器处于Closed状态：
*  1)超出配置的callTimeout的异常或调用均会增加失败计数器
*  2)成功将失败计数重置为零
*  3)当失败计数器达到maxFailures时，断路器跳闸至Open状态
*2.当断路器处于Open状态时：
*  1)所有调用都以CircuitBreakerOpenException快速失败
*  2)配置resetTimeout后，断路器进入Half-Open状态
*3.当断路器处于Half-Open状态时：
*  1)允许尝试的第一个调用通过，但不会快速失败
*  2)所有其他调用都会快速失败，异常情况与Open状态相同
*  3)如果第一次调用成功，断路器复位回Closed状态，resetTimeout复位
*  4)如果第一次呼叫失败，断路器将再次跳闸至Open状态（对于指数后退断路器，resetTimeout乘以指数后退系数）
*4.状态转换侦听器：
*  1)可以通过onOpen、onClose和onHalfOpen为每个状态条目提供回调
*  2)它们在提供的ExecutionContext中执行
*5.调用结果侦听器：
*  1)回调可用于收集有关所有调用的统计信息，或对成功、失败或超时等特定调用结果做出反应
*  2)支持的回调包括：onCallSuccess、onCallFailure、onCallTimeout和onCallBreakerOpen
*  3)它们在提供的ExecutionContext中执行
*/</span>
<span class="k">object</span> <span class="nc">CircuitBreaker</span> <span class="o">{</span>

<span class="c1">//提供用于CircuitBreaker的工厂方法的伴生对象，该断路器在调用者的线程中运行回调</span>
   <span class="cm">/**
    * 创建一个断路器
    * 使用withSyncCircuitBreaker时，回调函数在调用者的线程中运行；
    * 使用withCircuitBreaker时，回调函数在与Future中传递的相同的ExecutionContext中运行
    * 要将另一个ExecutionContext用于回调，可以在构造函数中指定ExecutionContext
    *
    * @param scheduler    Akka scheduler实例，如：system.scheduler
    * @param maxFailures  断路器打开前最大错误次数
    * @param callTimeout  [[scala.concurrent.duration.FiniteDuration]] XX 时间之后才认为调用失败，失败时会导致故障计数器增加
    * @param resetTimeout [[scala.concurrent.duration.FiniteDuration]] XX 时间之后尝试关闭
    */</span>
<span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">scheduler</span><span class="k">:</span> <span class="kt">Scheduler</span><span class="o">,</span> <span class="n">maxFailures</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">callTimeout</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">,</span> <span class="n">resetTimeout</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitBreaker</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">CircuitBreaker</span><span class="o">(</span><span class="n">scheduler</span><span class="o">,</span> <span class="n">maxFailures</span><span class="o">,</span> <span class="n">callTimeout</span><span class="o">,</span> <span class="n">resetTimeout</span><span class="o">)(</span><span class="n">sameThreadExecutionContext</span><span class="o">)</span>

   <span class="cm">/**
    * Java API
    */</span>
<span class="nd">@deprecated</span><span class="o">(</span><span class="s">"Use the overloaded one which accepts java.time.Duration instead."</span><span class="o">,</span> <span class="n">since</span> <span class="k">=</span> <span class="s">"2.5.12"</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">create</span><span class="o">(</span><span class="n">scheduler</span><span class="k">:</span> <span class="kt">Scheduler</span><span class="o">,</span> <span class="n">maxFailures</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">callTimeout</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">,</span> <span class="n">resetTimeout</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitBreaker</span> <span class="o">=</span>
    <span class="nf">apply</span><span class="o">(</span><span class="n">scheduler</span><span class="o">,</span> <span class="n">maxFailures</span><span class="o">,</span> <span class="n">callTimeout</span><span class="o">,</span> <span class="n">resetTimeout</span><span class="o">)</span>

   <span class="cm">/**
    * Java API
    */</span>
<span class="k">def</span> <span class="nf">create</span><span class="o">(</span><span class="n">scheduler</span><span class="k">:</span> <span class="kt">Scheduler</span><span class="o">,</span> <span class="n">maxFailures</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">callTimeout</span><span class="k">:</span> <span class="kt">java.time.Duration</span><span class="o">,</span> <span class="n">resetTimeout</span><span class="k">:</span> <span class="kt">java.time.Duration</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitBreaker</span> <span class="o">=</span>
    <span class="nf">apply</span><span class="o">(</span><span class="n">scheduler</span><span class="o">,</span> <span class="n">maxFailures</span><span class="o">,</span> <span class="nv">callTimeout</span><span class="o">.</span><span class="py">asScala</span><span class="o">,</span> <span class="nv">resetTimeout</span><span class="o">.</span><span class="py">asScala</span><span class="o">)</span>

<span class="c1">//所有异常都将导致值为true</span>
<span class="k">private</span> <span class="k">val</span> <span class="nv">exceptionAsFailure</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">⇒</span> <span class="nc">Boolean</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">_:</span> <span class="kt">Success</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">⇒</span> <span class="kc">false</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">⇒</span> <span class="kc">true</span>
<span class="o">}</span>

<span class="c1">//Java版</span>
<span class="k">private</span> <span class="k">def</span> <span class="nf">exceptionAsFailureJava</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span><span class="k">:</span> <span class="kt">BiFunction</span><span class="o">[</span><span class="kt">Optional</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>, <span class="kt">Optional</span><span class="o">[</span><span class="kt">Throwable</span><span class="o">]</span>, <span class="kt">java.lang.Boolean</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">BiFunction</span><span class="o">[</span><span class="kt">Optional</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>, <span class="kt">Optional</span><span class="o">[</span><span class="kt">Throwable</span><span class="o">]</span>, <span class="kt">java.lang.Boolean</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Optional</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">err</span><span class="k">:</span> <span class="kt">Optional</span><span class="o">[</span><span class="kt">Throwable</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
        <span class="nf">if</span> <span class="o">(</span><span class="nv">err</span><span class="o">.</span><span class="py">isPresent</span><span class="o">)</span>
        <span class="kc">true</span>
        <span class="k">else</span>
        <span class="kc">false</span>
    <span class="o">}</span>
    <span class="o">}</span>
<span class="c1">//Java 错误函数转化为Scala的</span>
<span class="k">protected</span> <span class="k">def</span> <span class="nf">convertJavaFailureFnToScala</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">javaFn</span><span class="k">:</span> <span class="kt">BiFunction</span><span class="o">[</span><span class="kt">Optional</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>, <span class="kt">Optional</span><span class="o">[</span><span class="kt">Throwable</span><span class="o">]</span>, <span class="kt">java.lang.Boolean</span><span class="o">])</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">⇒</span> <span class="nc">Boolean</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">failureFnInScala</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">⇒</span> <span class="nc">Boolean</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">t</span><span class="o">)</span> <span class="k">⇒</span> <span class="nf">javaFn</span><span class="o">(</span><span class="nv">Optional</span><span class="o">.</span><span class="py">of</span><span class="o">(</span><span class="n">t</span><span class="o">),</span> <span class="nv">Optional</span><span class="o">.</span><span class="py">empty</span><span class="o">())</span>
    <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">err</span><span class="o">)</span> <span class="k">⇒</span> <span class="nf">javaFn</span><span class="o">(</span><span class="nv">Optional</span><span class="o">.</span><span class="py">empty</span><span class="o">(),</span> <span class="nv">Optional</span><span class="o">.</span><span class="py">of</span><span class="o">(</span><span class="n">err</span><span class="o">))</span>
    <span class="o">}</span>
    <span class="n">failureFnInScala</span>
<span class="o">}</span>
<span class="o">}</span>

<span class="c1">//断路器的具体实现</span>
<span class="k">class</span> <span class="nc">CircuitBreaker</span><span class="o">(</span>
<span class="n">scheduler</span><span class="k">:</span> <span class="kt">Scheduler</span><span class="o">,</span>
<span class="n">maxFailures</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
<span class="n">callTimeout</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">,</span>
<span class="k">val</span> <span class="nv">resetTimeout</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">,</span>
<span class="n">maxResetTimeout</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">,</span>
<span class="n">exponentialBackoffFactor</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">executor</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AbstractCircuitBreaker</span> <span class="o">{</span>

<span class="nf">require</span><span class="o">(</span><span class="n">exponentialBackoffFactor</span> <span class="o">&gt;=</span> <span class="mf">1.0</span><span class="o">,</span> <span class="s">"factor must be &gt;= 1.0"</span><span class="o">)</span>

<span class="nd">@deprecated</span><span class="o">(</span><span class="s">"Use the overloaded one which accepts java.time.Duration instead."</span><span class="o">,</span> <span class="n">since</span> <span class="k">=</span> <span class="s">"2.5.12"</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">this</span><span class="o">(</span><span class="n">executor</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">,</span> <span class="n">scheduler</span><span class="k">:</span> <span class="kt">Scheduler</span><span class="o">,</span> <span class="n">maxFailures</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">callTimeout</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">,</span> <span class="n">resetTimeout</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nf">this</span><span class="o">(</span><span class="n">scheduler</span><span class="o">,</span> <span class="n">maxFailures</span><span class="o">,</span> <span class="n">callTimeout</span><span class="o">,</span> <span class="n">resetTimeout</span><span class="o">,</span> <span class="mf">36500.d</span><span class="n">ays</span><span class="o">,</span> <span class="mf">1.0</span><span class="o">)(</span><span class="n">executor</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">this</span><span class="o">(</span><span class="n">executor</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">,</span> <span class="n">scheduler</span><span class="k">:</span> <span class="kt">Scheduler</span><span class="o">,</span> <span class="n">maxFailures</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">callTimeout</span><span class="k">:</span> <span class="kt">java.time.Duration</span><span class="o">,</span> <span class="n">resetTimeout</span><span class="k">:</span> <span class="kt">java.time.Duration</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nf">this</span><span class="o">(</span><span class="n">scheduler</span><span class="o">,</span> <span class="n">maxFailures</span><span class="o">,</span> <span class="nv">callTimeout</span><span class="o">.</span><span class="py">asScala</span><span class="o">,</span> <span class="nv">resetTimeout</span><span class="o">.</span><span class="py">asScala</span><span class="o">,</span> <span class="mf">36500.d</span><span class="n">ays</span><span class="o">,</span> <span class="mf">1.0</span><span class="o">)(</span><span class="n">executor</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">//二进制兼容</span>
<span class="k">def</span> <span class="nf">this</span><span class="o">(</span><span class="n">scheduler</span><span class="k">:</span> <span class="kt">Scheduler</span><span class="o">,</span> <span class="n">maxFailures</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">callTimeout</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">,</span> <span class="n">resetTimeout</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">executor</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nf">this</span><span class="o">(</span><span class="n">scheduler</span><span class="o">,</span> <span class="n">maxFailures</span><span class="o">,</span> <span class="n">callTimeout</span><span class="o">,</span> <span class="n">resetTimeout</span><span class="o">,</span> <span class="mf">36500.d</span><span class="n">ays</span><span class="o">,</span> <span class="mf">1.0</span><span class="o">)(</span><span class="n">executor</span><span class="o">)</span>
<span class="o">}</span>

   <span class="cm">/**
    * 每次断路器闭合的失败尝试都会使“resetTimeout”成倍增加，默认的指数补偿因子为2，说明这个实现是一个指数退避断路器
    *
    * @param maxResetTimeout resetTimeout的上限
    */</span>
<span class="k">def</span> <span class="nf">withExponentialBackoff</span><span class="o">(</span><span class="n">maxResetTimeout</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitBreaker</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">new</span> <span class="nc">CircuitBreaker</span><span class="o">(</span><span class="n">scheduler</span><span class="o">,</span> <span class="n">maxFailures</span><span class="o">,</span> <span class="n">callTimeout</span><span class="o">,</span> <span class="n">resetTimeout</span><span class="o">,</span> <span class="n">maxResetTimeout</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">)(</span><span class="n">executor</span><span class="o">)</span>
<span class="o">}</span>

   <span class="cm">/**
    * Java API
    */</span>
<span class="k">def</span> <span class="nf">withExponentialBackoff</span><span class="o">(</span><span class="n">maxResetTimeout</span><span class="k">:</span> <span class="kt">java.time.Duration</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitBreaker</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nf">withExponentialBackoff</span><span class="o">(</span><span class="nv">maxResetTimeout</span><span class="o">.</span><span class="py">asScala</span><span class="o">)</span>
<span class="o">}</span>

   <span class="cm">/**
    * 保留对CircuitBreaker当前状态的引用-只能通过辅助方法访问（反射，来自AbstractCircuitBreaker的Unsafe封装）
    */</span>
<span class="nd">@volatile</span>
<span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="nc">_currentStateDoNotCallMeDirectly</span><span class="k">:</span> <span class="kt">State</span> <span class="o">=</span> <span class="nc">Closed</span>

   <span class="cm">/**
    * 保留对CircuitBreaker的当前resetTimeout的引用-只能通过辅助方法访问
    */</span>
<span class="nd">@volatile</span>
<span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="nc">_currentResetTimeoutDoNotCallMeDirectly</span><span class="k">:</span> <span class="kt">FiniteDuration</span> <span class="o">=</span> <span class="n">resetTimeout</span>

   <span class="cm">/**
    * 内联函数
    * Helper方法，通过Unsafe修改状态
    *
    * @param oldState 上一个过渡状态
    * @param newState 下一个过渡状态
    * @return 前一个状态是否正确匹配
    */</span>
<span class="nd">@inline</span>
<span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">def</span> <span class="nf">swapState</span><span class="o">(</span><span class="n">oldState</span><span class="k">:</span> <span class="kt">State</span><span class="o">,</span> <span class="n">newState</span><span class="k">:</span> <span class="kt">State</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
<span class="c1">//CAS操作</span>
    <span class="nv">Unsafe</span><span class="o">.</span><span class="py">instance</span><span class="o">.</span><span class="py">compareAndSwapObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="nv">AbstractCircuitBreaker</span><span class="o">.</span><span class="py">stateOffset</span><span class="o">,</span> <span class="n">oldState</span><span class="o">,</span> <span class="n">newState</span><span class="o">)</span>


   <span class="cm">/**
    * Unsafe获取当前状态
    */</span>
<span class="nd">@inline</span>
<span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">def</span> <span class="nf">currentState</span><span class="k">:</span> <span class="kt">State</span> <span class="o">=</span>
    <span class="nv">Unsafe</span><span class="o">.</span><span class="py">instance</span><span class="o">.</span><span class="py">getObjectVolatile</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="nv">AbstractCircuitBreaker</span><span class="o">.</span><span class="py">stateOffset</span><span class="o">).</span><span class="py">asInstanceOf</span><span class="o">[</span><span class="kt">State</span><span class="o">]</span>

   <span class="cm">/**
    * Unsafe修改ResetTimeout
    */</span>
<span class="nd">@inline</span>
<span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">def</span> <span class="nf">swapResetTimeout</span><span class="o">(</span><span class="n">oldResetTimeout</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">,</span> <span class="n">newResetTimeout</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
    <span class="nv">Unsafe</span><span class="o">.</span><span class="py">instance</span><span class="o">.</span><span class="py">compareAndSwapObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="nv">AbstractCircuitBreaker</span><span class="o">.</span><span class="py">resetTimeoutOffset</span><span class="o">,</span> <span class="n">oldResetTimeout</span><span class="o">,</span> <span class="n">newResetTimeout</span><span class="o">)</span>

   <span class="cm">/**
    * Unsafe获取当前ResetTimeout
    */</span>
<span class="nd">@inline</span>
<span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">def</span> <span class="nf">currentResetTimeout</span><span class="k">:</span> <span class="kt">FiniteDuration</span> <span class="o">=</span>
    <span class="nv">Unsafe</span><span class="o">.</span><span class="py">instance</span><span class="o">.</span><span class="py">getObjectVolatile</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="nv">AbstractCircuitBreaker</span><span class="o">.</span><span class="py">resetTimeoutOffset</span><span class="o">).</span><span class="py">asInstanceOf</span><span class="o">[</span><span class="kt">FiniteDuration</span><span class="o">]</span>

   <span class="cm">/**
    * 包装需要被保护的异步调用代码块
    *
    * @param body            需被保护的异步代码块
    * @param defineFailureFn 该函数定义了应该考虑的故障，从而增加故障计数
    * @return [[scala.concurrent.Future]] containing the call result or a
    *         `scala.concurrent.TimeoutException` if the call timed out
    */</span>
<span class="k">def</span> <span class="nf">withCircuitBreaker</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">body</span><span class="k">:</span> <span class="k">⇒</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">defineFailureFn</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">⇒</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">currentState</span><span class="o">.</span><span class="py">invoke</span><span class="o">(</span><span class="n">body</span><span class="o">,</span> <span class="n">defineFailureFn</span><span class="o">)</span>


<span class="k">def</span> <span class="nf">withCircuitBreaker</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">body</span><span class="k">:</span> <span class="k">⇒</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nv">currentState</span><span class="o">.</span><span class="py">invoke</span><span class="o">(</span><span class="n">body</span><span class="o">,</span> <span class="nv">CircuitBreaker</span><span class="o">.</span><span class="py">exceptionAsFailure</span><span class="o">)</span>

   <span class="cm">/**
    * Java API
    */</span>
<span class="k">def</span> <span class="nf">callWithCircuitBreaker</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">body</span><span class="k">:</span> <span class="kt">Callable</span><span class="o">[</span><span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="nf">callWithCircuitBreaker</span><span class="o">(</span><span class="n">body</span><span class="o">,</span> <span class="nv">CircuitBreaker</span><span class="o">.</span><span class="py">exceptionAsFailureJava</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>

   <span class="cm">/**
    * Java API
    */</span>
<span class="k">def</span> <span class="nf">callWithCircuitBreaker</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">body</span><span class="k">:</span> <span class="kt">Callable</span><span class="o">[</span><span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]],</span> <span class="n">defineFailureFn</span><span class="k">:</span> <span class="kt">BiFunction</span><span class="o">[</span><span class="kt">Optional</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>, <span class="kt">Optional</span><span class="o">[</span><span class="kt">Throwable</span><span class="o">]</span>, <span class="kt">java.lang.Boolean</span><span class="o">])</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">failureFnInScala</span> <span class="k">=</span> <span class="nv">CircuitBreaker</span><span class="o">.</span><span class="py">convertJavaFailureFnToScala</span><span class="o">(</span><span class="n">defineFailureFn</span><span class="o">)</span>

    <span class="nf">withCircuitBreaker</span><span class="o">(</span><span class="nv">body</span><span class="o">.</span><span class="py">call</span><span class="o">,</span> <span class="n">failureFnInScala</span><span class="o">)</span>
<span class="o">}</span>

   <span class="cm">/**
    * Java API (8)
    */</span>
<span class="k">def</span> <span class="nf">callWithCircuitBreakerCS</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">body</span><span class="k">:</span> <span class="kt">Callable</span><span class="o">[</span><span class="kt">CompletionStage</span><span class="o">[</span><span class="kt">T</span><span class="o">]])</span><span class="k">:</span> <span class="kt">CompletionStage</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="nf">callWithCircuitBreakerCS</span><span class="o">(</span><span class="n">body</span><span class="o">,</span> <span class="nv">CircuitBreaker</span><span class="o">.</span><span class="py">exceptionAsFailureJava</span><span class="o">)</span>

   <span class="cm">/**
    * Java API (8)
    */</span>
<span class="k">def</span> <span class="nf">callWithCircuitBreakerCS</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span>
    <span class="n">body</span><span class="k">:</span> <span class="kt">Callable</span><span class="o">[</span><span class="kt">CompletionStage</span><span class="o">[</span><span class="kt">T</span><span class="o">]],</span>
    <span class="n">defineFailureFn</span><span class="k">:</span> <span class="kt">BiFunction</span><span class="o">[</span><span class="kt">Optional</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>, <span class="kt">Optional</span><span class="o">[</span><span class="kt">Throwable</span><span class="o">]</span>, <span class="kt">java.lang.Boolean</span><span class="o">])</span><span class="k">:</span> <span class="kt">CompletionStage</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">FutureConverters</span><span class="o">.</span><span class="py">toJava</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="nf">callWithCircuitBreaker</span><span class="o">(</span><span class="k">new</span> <span class="nc">Callable</span><span class="o">[</span><span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">call</span><span class="o">()</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nv">FutureConverters</span><span class="o">.</span><span class="py">toScala</span><span class="o">(</span><span class="nv">body</span><span class="o">.</span><span class="py">call</span><span class="o">())</span>
    <span class="o">},</span> <span class="n">defineFailureFn</span><span class="o">))</span>

   <span class="cm">/**
    *
    * 在调用者线程中执行，由于同步性scala.concurrent.TimeoutException只会在主体完成之后抛出
    * 如果调用超时，则抛出 java.util.concurrent.TimeoutException
    *
    * @param body 需要被保护的代码
    * @return The result of the call
    */</span>
<span class="k">def</span> <span class="nf">withSyncCircuitBreaker</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">body</span><span class="k">:</span> <span class="k">⇒</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
    <span class="nf">withSyncCircuitBreaker</span><span class="o">(</span><span class="n">body</span><span class="o">,</span> <span class="nv">CircuitBreaker</span><span class="o">.</span><span class="py">exceptionAsFailure</span><span class="o">)</span>

   <span class="cm">/**
    * 同上，但支持定义失败函数以支持被故障计数
    */</span>
<span class="k">def</span> <span class="nf">withSyncCircuitBreaker</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">body</span><span class="k">:</span> <span class="k">⇒</span> <span class="kt">T</span><span class="o">,</span> <span class="n">defineFailureFn</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">⇒</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
    <span class="nv">Await</span><span class="o">.</span><span class="py">result</span><span class="o">(</span>
    <span class="nf">withCircuitBreaker</span><span class="o">(</span>
        <span class="k">try</span> <span class="nv">Future</span><span class="o">.</span><span class="py">successful</span><span class="o">(</span><span class="n">body</span><span class="o">)</span> <span class="k">catch</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">NonFatal</span><span class="o">(</span><span class="n">t</span><span class="o">)</span> <span class="k">⇒</span> <span class="nv">Future</span><span class="o">.</span><span class="py">failed</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
        <span class="o">},</span>
        <span class="n">defineFailureFn</span><span class="o">),</span>
    <span class="n">callTimeout</span><span class="o">)</span>

   <span class="cm">/**
    * Java API
    */</span>
<span class="k">def</span> <span class="nf">callWithSyncCircuitBreaker</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">body</span><span class="k">:</span> <span class="kt">Callable</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
    <span class="nf">callWithSyncCircuitBreaker</span><span class="o">(</span><span class="n">body</span><span class="o">,</span> <span class="nv">CircuitBreaker</span><span class="o">.</span><span class="py">exceptionAsFailureJava</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>

   <span class="cm">/**
    * Java API
    */</span>
<span class="k">def</span> <span class="nf">callWithSyncCircuitBreaker</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">body</span><span class="k">:</span> <span class="kt">Callable</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">defineFailureFn</span><span class="k">:</span> <span class="kt">BiFunction</span><span class="o">[</span><span class="kt">Optional</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>, <span class="kt">Optional</span><span class="o">[</span><span class="kt">Throwable</span><span class="o">]</span>, <span class="kt">java.lang.Boolean</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">failureFnInScala</span> <span class="k">=</span> <span class="nv">CircuitBreaker</span><span class="o">.</span><span class="py">convertJavaFailureFnToScala</span><span class="o">(</span><span class="n">defineFailureFn</span><span class="o">)</span>
    <span class="nf">withSyncCircuitBreaker</span><span class="o">(</span><span class="nv">body</span><span class="o">.</span><span class="py">call</span><span class="o">,</span> <span class="n">failureFnInScala</span><span class="o">)</span>
<span class="o">}</span>

   <span class="cm">/**
    * 通过CircuitBreaker标记成功的调用
    * 有时，断路器的被调用者会向调用者Actor回复一条消息，在这种情况下，标记为成功的调用比通过使用Future更为方便
    */</span>
<span class="k">def</span> <span class="nf">succeed</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nv">currentState</span><span class="o">.</span><span class="py">callSucceeds</span><span class="o">()</span>
<span class="o">}</span>

   <span class="cm">/**
    * 通过CircuitBreaker标记失败的调用有时，断路器的被调用者会向调用者Actor回复一条消息，在这种情况下，标记为失败的调用比通过使用Future更为方便
    */</span>
<span class="k">def</span> <span class="nf">fail</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nv">currentState</span><span class="o">.</span><span class="py">callFails</span><span class="o">()</span>
<span class="o">}</span>

   <span class="cm">/**
    * 类似电路上开关的闭合和打开
    * 如果内部状态为“闭合”，则返回true 警告：这是一个“power API”调用，您应谨慎使用
    * 如CircuitBreaker一样，CircuitBreaker的常规用例希望远程调用返回Future 因此，如果您自己检查状态，并在CircuitBreaker外部进行远程调用，则应该自己管理状态
    */</span>
<span class="k">def</span> <span class="nf">isClosed</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">currentState</span> <span class="o">==</span> <span class="nc">Closed</span>
<span class="o">}</span>

   <span class="cm">/**
    * 如果内部状态为“打开”，则返回true 警告：这是一个“power API”调用，您应谨慎使用
    * 如CircuitBreaker一样，CircuitBreaker的常规用例希望远程调用返回Future 因此，如果您自己检查状态，并在CircuitBreaker外部进行远程调用，则应该自己管理状态
    */</span>
<span class="k">def</span> <span class="nf">isOpen</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">currentState</span> <span class="o">==</span> <span class="nc">Open</span>
<span class="o">}</span>

   <span class="cm">/**
    * 强调状态
    * 如果内部状态为“半开”，则返回true 警告：这是一个“power API”调用，您应谨慎使用
    * 如CircuitBreaker一样，CircuitBreaker的常规用例希望远程调用返回Future 因此，如果您自己检查状态，并在CircuitBreaker外部进行远程调用，则应该自己管理状态
    */</span>
<span class="k">def</span> <span class="nf">isHalfOpen</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">currentState</span> <span class="o">==</span> <span class="nc">HalfOpen</span>
<span class="o">}</span>

   <span class="cm">/**
    * 添加一个断路器在打开时执行的回调，回调在构造函数中提供的ExecutionContext中执行
    *
    * @param callback 状态更改时要调用的处理程序
    * @return CircuitBreaker for fluent usage
    */</span>
<span class="k">def</span> <span class="nf">onOpen</span><span class="o">(</span><span class="n">callback</span><span class="k">:</span> <span class="k">⇒</span> <span class="kt">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitBreaker</span> <span class="o">=</span> <span class="nf">addOnOpenListener</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">run</span> <span class="k">=</span> <span class="n">callback</span>
<span class="o">})</span>

   <span class="cm">/**
    * Java API
    */</span>
<span class="nd">@deprecated</span><span class="o">(</span><span class="s">"Use addOnOpenListener instead"</span><span class="o">,</span> <span class="s">"2.5.0"</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">onOpen</span><span class="o">(</span><span class="n">callback</span><span class="k">:</span> <span class="kt">Runnable</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitBreaker</span> <span class="o">=</span> <span class="nf">addOnOpenListener</span><span class="o">(</span><span class="n">callback</span><span class="o">)</span>

   <span class="cm">/**
    * Java API for onOpen
    *
    */</span>
<span class="k">def</span> <span class="nf">addOnOpenListener</span><span class="o">(</span><span class="n">callback</span><span class="k">:</span> <span class="kt">Runnable</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitBreaker</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nc">Open</span> <span class="n">addListener</span> <span class="n">callback</span>
    <span class="k">this</span>
<span class="o">}</span>

   <span class="cm">/**
    * 添加一个断路器在处于半开状态时执行的回调，回调在构造函数中提供的ExecutionContext中执行
    *
    * @param callback 状态更改时要调用的处理程序
    * @return CircuitBreaker for fluent usage
    */</span>
<span class="k">def</span> <span class="nf">onHalfOpen</span><span class="o">(</span><span class="n">callback</span><span class="k">:</span> <span class="k">⇒</span> <span class="kt">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitBreaker</span> <span class="o">=</span> <span class="nf">addOnHalfOpenListener</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">run</span> <span class="k">=</span> <span class="n">callback</span>
<span class="o">})</span>

   <span class="cm">/**
    * JavaAPI
    */</span>
<span class="nd">@deprecated</span><span class="o">(</span><span class="s">"Use addOnHalfOpenListener instead"</span><span class="o">,</span> <span class="s">"2.5.0"</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">onHalfOpen</span><span class="o">(</span><span class="n">callback</span><span class="k">:</span> <span class="kt">Runnable</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitBreaker</span> <span class="o">=</span> <span class="nf">addOnHalfOpenListener</span><span class="o">(</span><span class="n">callback</span><span class="o">)</span>

   <span class="cm">/**
    * JavaAPI
    */</span>
<span class="k">def</span> <span class="nf">addOnHalfOpenListener</span><span class="o">(</span><span class="n">callback</span><span class="k">:</span> <span class="kt">Runnable</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitBreaker</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nc">HalfOpen</span> <span class="n">addListener</span> <span class="n">callback</span>
    <span class="k">this</span>
<span class="o">}</span>

   <span class="cm">/**
    * 添加一个回调以在断路器状态关闭时执行，回调在构造函数中提供的ExecutionContext中执行
    *
    * @param callback 状态更改时要调用的处理程序
    * @return CircuitBreaker for fluent usage
    */</span>
<span class="k">def</span> <span class="nf">onClose</span><span class="o">(</span><span class="n">callback</span><span class="k">:</span> <span class="k">⇒</span> <span class="kt">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitBreaker</span> <span class="o">=</span> <span class="nf">addOnCloseListener</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">run</span> <span class="k">=</span> <span class="n">callback</span>
<span class="o">})</span>

   <span class="cm">/**
    * JavaAPI
    */</span>
<span class="nd">@deprecated</span><span class="o">(</span><span class="s">"Use addOnCloseListener instead"</span><span class="o">,</span> <span class="s">"2.5.0"</span><span class="o">)</span>
<span class="k">def</span> <span class="nf">onClose</span><span class="o">(</span><span class="n">callback</span><span class="k">:</span> <span class="kt">Runnable</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitBreaker</span> <span class="o">=</span> <span class="nf">addOnCloseListener</span><span class="o">(</span><span class="n">callback</span><span class="o">)</span>

   <span class="cm">/**
    * JavaAPI
    */</span>
<span class="k">def</span> <span class="nf">addOnCloseListener</span><span class="o">(</span><span class="n">callback</span><span class="k">:</span> <span class="kt">Runnable</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitBreaker</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nc">Closed</span> <span class="n">addListener</span> <span class="n">callback</span>
    <span class="k">this</span>
<span class="o">}</span>

   <span class="cm">/**
    * 添加一个回调以在调用成功完成时执行，回调在构造函数中提供的ExecutionContext中执行
    *
    * @param callback 成功调用时要调用的处理程序，其中传递的值是经过的时间（以纳秒为单位）
    * @return CircuitBreaker for fluent usage
    */</span>
<span class="k">def</span> <span class="nf">onCallSuccess</span><span class="o">(</span><span class="n">callback</span><span class="k">:</span> <span class="kt">Long</span> <span class="k">⇒</span> <span class="kt">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitBreaker</span> <span class="o">=</span> <span class="nf">addOnCallSuccessListener</span><span class="o">(</span><span class="k">new</span> <span class="nc">Consumer</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">accept</span><span class="o">(</span><span class="n">result</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nf">callback</span><span class="o">(</span><span class="n">result</span><span class="o">)</span>
<span class="o">})</span>

   <span class="cm">/**
    * JavaAPI
    */</span>
<span class="k">def</span> <span class="nf">addOnCallSuccessListener</span><span class="o">(</span><span class="n">callback</span><span class="k">:</span> <span class="kt">Consumer</span><span class="o">[</span><span class="kt">Long</span><span class="o">])</span><span class="k">:</span> <span class="kt">CircuitBreaker</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">successListeners</span> <span class="n">add</span> <span class="n">callback</span>
    <span class="k">this</span>
<span class="o">}</span>

   <span class="cm">/**
    * 添加一个回调以在调用失败后执行，回调在构造函数中提供的ExecutionContext中执行
    *
    * @param callback 失败调用时要调用的处理程序，其中传递的值是经过的时间（以纳秒为单位）
    * @return CircuitBreaker for fluent usage
    */</span>
<span class="k">def</span> <span class="nf">onCallFailure</span><span class="o">(</span><span class="n">callback</span><span class="k">:</span> <span class="kt">Long</span> <span class="k">⇒</span> <span class="kt">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitBreaker</span> <span class="o">=</span> <span class="nf">addOnCallFailureListener</span><span class="o">(</span><span class="k">new</span> <span class="nc">Consumer</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">accept</span><span class="o">(</span><span class="n">result</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nf">callback</span><span class="o">(</span><span class="n">result</span><span class="o">)</span>
<span class="o">})</span>

   <span class="cm">/**
    * JavaAPI
    */</span>
<span class="k">def</span> <span class="nf">addOnCallFailureListener</span><span class="o">(</span><span class="n">callback</span><span class="k">:</span> <span class="kt">Consumer</span><span class="o">[</span><span class="kt">Long</span><span class="o">])</span><span class="k">:</span> <span class="kt">CircuitBreaker</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">callFailureListeners</span> <span class="n">add</span> <span class="n">callback</span>
    <span class="k">this</span>
<span class="o">}</span>

   <span class="cm">/**
    * 添加一个回调以在超时结束时执行，回调在构造函数中提供的ExecutionContext中执行
    *
    * @param callback 超时结束时调用的处理程序，其中传递的值是经过的时间（以纳秒为单位）
    * @return CircuitBreaker for fluent usage
    */</span>
<span class="k">def</span> <span class="nf">onCallTimeout</span><span class="o">(</span><span class="n">callback</span><span class="k">:</span> <span class="kt">Long</span> <span class="k">⇒</span> <span class="kt">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitBreaker</span> <span class="o">=</span> <span class="nf">addOnCallTimeoutListener</span><span class="o">(</span><span class="k">new</span> <span class="nc">Consumer</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">accept</span><span class="o">(</span><span class="n">result</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nf">callback</span><span class="o">(</span><span class="n">result</span><span class="o">)</span>
<span class="o">})</span>

   <span class="cm">/**
    * JavaAPI
    */</span>
<span class="k">def</span> <span class="nf">addOnCallTimeoutListener</span><span class="o">(</span><span class="n">callback</span><span class="k">:</span> <span class="kt">Consumer</span><span class="o">[</span><span class="kt">Long</span><span class="o">])</span><span class="k">:</span> <span class="kt">CircuitBreaker</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">callTimeoutListeners</span> <span class="n">add</span> <span class="n">callback</span>
    <span class="k">this</span>
<span class="o">}</span>

   <span class="cm">/**
    * 添加一个回调，以在由于打开断路器而导致调用失败时执行，回调在构造函数中提供的ExecutionContext中执行
    *
    * @param callback 由于断路器打开，在调用时调用的处理程序失败
    * @return CircuitBreaker for fluent usage
    */</span>
<span class="k">def</span> <span class="nf">onCallBreakerOpen</span><span class="o">(</span><span class="n">callback</span><span class="k">:</span> <span class="k">⇒</span> <span class="kt">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitBreaker</span> <span class="o">=</span> <span class="nf">addOnCallBreakerOpenListener</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">run</span> <span class="k">=</span> <span class="n">callback</span>
<span class="o">})</span>

   <span class="cm">/**
    * JavaAPI
    */</span>
<span class="k">def</span> <span class="nf">addOnCallBreakerOpenListener</span><span class="o">(</span><span class="n">callback</span><span class="k">:</span> <span class="kt">Runnable</span><span class="o">)</span><span class="k">:</span> <span class="kt">CircuitBreaker</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">callBreakerOpenListeners</span> <span class="n">add</span> <span class="n">callback</span>
    <span class="k">this</span>
<span class="o">}</span>

   <span class="cm">/**
    * 当前故障计数
    *
    * @return count
    */</span>
<span class="k">private</span><span class="o">[</span><span class="kt">akka</span><span class="o">]</span> <span class="k">def</span> <span class="nf">currentFailureCount</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nv">Closed</span><span class="o">.</span><span class="py">get</span>

   <span class="cm">/**
    * 实现状态之间的一致过渡 如果尝试了无效的转换，则抛出IllegalStateException
    * 使用CAS转换状态
    *
    * @param fromState from
    * @param toState   to
    */</span>
<span class="k">private</span> <span class="k">def</span> <span class="nf">transition</span><span class="o">(</span><span class="n">fromState</span><span class="k">:</span> <span class="kt">State</span><span class="o">,</span> <span class="n">toState</span><span class="k">:</span> <span class="kt">State</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nf">if</span> <span class="o">(</span><span class="nf">swapState</span><span class="o">(</span><span class="n">fromState</span><span class="o">,</span> <span class="n">toState</span><span class="o">))</span>
    <span class="nv">toState</span><span class="o">.</span><span class="py">enter</span><span class="o">()</span>
    <span class="c1">//否则其他一些线程已经交换状态</span>
<span class="o">}</span>

   <span class="cm">/**
    * 将断路器跳到打开状态 这在“关闭”或“半开”状态下有效半开或者闭合时均可以到“打开”状态
    */</span>
<span class="k">private</span> <span class="k">def</span> <span class="nf">tripBreaker</span><span class="o">(</span><span class="n">fromState</span><span class="k">:</span> <span class="kt">State</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nf">transition</span><span class="o">(</span><span class="n">fromState</span><span class="o">,</span> <span class="nc">Open</span><span class="o">)</span>

   <span class="cm">/**
    * 将断路器重置为闭合状态 仅在半开状态下有效
    */</span>
<span class="k">private</span> <span class="k">def</span> <span class="nf">resetBreaker</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nf">transition</span><span class="o">(</span><span class="nc">HalfOpen</span><span class="o">,</span> <span class="nc">Closed</span><span class="o">)</span>

   <span class="cm">/**
    * 调用所有onSuccess回调处理程序
    *
    * @param start 调用的时间（纳秒）
    */</span>
<span class="k">private</span> <span class="k">def</span> <span class="nf">notifyCallSuccessListeners</span><span class="o">(</span><span class="n">start</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nf">if</span> <span class="o">(!</span><span class="nv">successListeners</span><span class="o">.</span><span class="py">isEmpty</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">elapsed</span> <span class="k">=</span> <span class="nv">System</span><span class="o">.</span><span class="py">nanoTime</span><span class="o">()</span> <span class="o">-</span> <span class="n">start</span>
    <span class="k">val</span> <span class="nv">iterator</span> <span class="k">=</span> <span class="nv">successListeners</span><span class="o">.</span><span class="py">iterator</span><span class="o">()</span>
    <span class="nf">while</span> <span class="o">(</span><span class="nv">iterator</span><span class="o">.</span><span class="py">hasNext</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">listener</span> <span class="k">=</span> <span class="nv">iterator</span><span class="o">.</span><span class="py">next</span><span class="o">()</span>
    <span class="nv">executor</span><span class="o">.</span><span class="py">execute</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">run</span><span class="o">()</span> <span class="k">=</span> <span class="nv">listener</span><span class="o">.</span><span class="py">accept</span><span class="o">(</span><span class="n">elapsed</span><span class="o">)</span>
    <span class="o">})</span>
    <span class="o">}</span>
<span class="o">}</span>

   <span class="cm">/**
    * 调用所有onCallFailure回调处理程序
    *
    * @param start 调用的时间（纳秒）
    */</span>
<span class="k">private</span> <span class="k">def</span> <span class="nf">notifyCallFailureListeners</span><span class="o">(</span><span class="n">start</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nf">if</span> <span class="o">(!</span><span class="nv">callFailureListeners</span><span class="o">.</span><span class="py">isEmpty</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">elapsed</span> <span class="k">=</span> <span class="nv">System</span><span class="o">.</span><span class="py">nanoTime</span><span class="o">()</span> <span class="o">-</span> <span class="n">start</span>
    <span class="k">val</span> <span class="nv">iterator</span> <span class="k">=</span> <span class="nv">callFailureListeners</span><span class="o">.</span><span class="py">iterator</span><span class="o">()</span>
    <span class="nf">while</span> <span class="o">(</span><span class="nv">iterator</span><span class="o">.</span><span class="py">hasNext</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">listener</span> <span class="k">=</span> <span class="nv">iterator</span><span class="o">.</span><span class="py">next</span><span class="o">()</span>
    <span class="nv">executor</span><span class="o">.</span><span class="py">execute</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">run</span><span class="o">()</span> <span class="k">=</span> <span class="nv">listener</span><span class="o">.</span><span class="py">accept</span><span class="o">(</span><span class="n">elapsed</span><span class="o">)</span>
    <span class="o">})</span>
    <span class="o">}</span>
<span class="o">}</span>

   <span class="cm">/**
    * 调用所有onCallTimeout回调处理程序
    *
    * @param start 调用的时间（纳秒）
    */</span>
<span class="k">private</span> <span class="k">def</span> <span class="nf">notifyCallTimeoutListeners</span><span class="o">(</span><span class="n">start</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nf">if</span> <span class="o">(!</span><span class="nv">callTimeoutListeners</span><span class="o">.</span><span class="py">isEmpty</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">elapsed</span> <span class="k">=</span> <span class="nv">System</span><span class="o">.</span><span class="py">nanoTime</span><span class="o">()</span> <span class="o">-</span> <span class="n">start</span>
    <span class="k">val</span> <span class="nv">iterator</span> <span class="k">=</span> <span class="nv">callTimeoutListeners</span><span class="o">.</span><span class="py">iterator</span><span class="o">()</span>
    <span class="nf">while</span> <span class="o">(</span><span class="nv">iterator</span><span class="o">.</span><span class="py">hasNext</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">listener</span> <span class="k">=</span> <span class="nv">iterator</span><span class="o">.</span><span class="py">next</span><span class="o">()</span>
    <span class="nv">executor</span><span class="o">.</span><span class="py">execute</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">run</span><span class="o">()</span> <span class="k">=</span> <span class="nv">listener</span><span class="o">.</span><span class="py">accept</span><span class="o">(</span><span class="n">elapsed</span><span class="o">)</span>
    <span class="o">})</span>
    <span class="o">}</span>
<span class="o">}</span>

   <span class="cm">/**
    * 调用所有onCallBreakerOpen回调处理程序
    */</span>
<span class="k">private</span> <span class="k">def</span> <span class="nf">notifyCallBreakerOpenListeners</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nf">if</span> <span class="o">(!</span><span class="nv">callBreakerOpenListeners</span><span class="o">.</span><span class="py">isEmpty</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">iterator</span> <span class="k">=</span> <span class="nv">callBreakerOpenListeners</span><span class="o">.</span><span class="py">iterator</span><span class="o">()</span>
    <span class="nf">while</span> <span class="o">(</span><span class="nv">iterator</span><span class="o">.</span><span class="py">hasNext</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">listener</span> <span class="k">=</span> <span class="nv">iterator</span><span class="o">.</span><span class="py">next</span><span class="o">()</span>
    <span class="nv">executor</span><span class="o">.</span><span class="py">execute</span><span class="o">(</span><span class="n">listener</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>

    <span class="cm">/**
    * 尝试通过过渡到半开状态来重置断路器 仅在打开状态下有效
    */</span>
<span class="k">private</span> <span class="k">def</span> <span class="nf">attemptReset</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nf">transition</span><span class="o">(</span><span class="nc">Open</span><span class="o">,</span> <span class="nc">HalfOpen</span><span class="o">)</span>
<span class="c1">//断路器超时异常</span>
<span class="k">private</span> <span class="k">val</span> <span class="nv">timeoutEx</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TimeoutException</span><span class="o">(</span><span class="s">"Circuit Breaker Timed out."</span><span class="o">)</span> <span class="k">with</span> <span class="nc">NoStackTrace</span>

<span class="k">private</span> <span class="k">val</span> <span class="nv">callFailureListeners</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">CopyOnWriteArrayList</span><span class="o">[</span><span class="kt">Consumer</span><span class="o">[</span><span class="kt">Long</span><span class="o">]]</span>

<span class="k">private</span> <span class="k">val</span> <span class="nv">callTimeoutListeners</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">CopyOnWriteArrayList</span><span class="o">[</span><span class="kt">Consumer</span><span class="o">[</span><span class="kt">Long</span><span class="o">]]</span>

<span class="k">private</span> <span class="k">val</span> <span class="nv">callBreakerOpenListeners</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">CopyOnWriteArrayList</span><span class="o">[</span><span class="kt">Runnable</span><span class="o">]</span>

<span class="k">private</span> <span class="k">val</span> <span class="nv">successListeners</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">CopyOnWriteArrayList</span><span class="o">[</span><span class="kt">Consumer</span><span class="o">[</span><span class="kt">Long</span><span class="o">]]</span>

    <span class="cm">/**
    * 内部状态抽象
    */</span>
<span class="k">private</span> <span class="k">sealed</span> <span class="k">trait</span> <span class="nc">State</span> <span class="o">{</span>
    <span class="c1">//所有监听器</span>
    <span class="k">private</span> <span class="k">val</span> <span class="nv">listeners</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">CopyOnWriteArrayList</span><span class="o">[</span><span class="kt">Runnable</span><span class="o">]</span>

    <span class="cm">/**
    * 添加在状态项上调用的侦听器函数
    */</span>
    <span class="k">def</span> <span class="nf">addListener</span><span class="o">(</span><span class="n">listener</span><span class="k">:</span> <span class="kt">Runnable</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">listeners</span> <span class="n">add</span> <span class="n">listener</span>

    <span class="cm">/**
    * 监听器是否存在
    */</span>
    <span class="k">private</span> <span class="k">def</span> <span class="nf">hasListeners</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">!</span><span class="nv">listeners</span><span class="o">.</span><span class="py">isEmpty</span>

    <span class="cm">/**
    * 通过在隐式参数ExecutionContext中执行的Future通知侦听器转换事件
    */</span>
    <span class="k">protected</span> <span class="k">def</span> <span class="nf">notifyTransitionListeners</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">hasListeners</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">iterator</span> <span class="k">=</span> <span class="nv">listeners</span><span class="o">.</span><span class="py">iterator</span>
        <span class="nf">while</span> <span class="o">(</span><span class="nv">iterator</span><span class="o">.</span><span class="py">hasNext</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">listener</span> <span class="k">=</span> <span class="nv">iterator</span><span class="o">.</span><span class="py">next</span>
        <span class="nv">executor</span><span class="o">.</span><span class="py">execute</span><span class="o">(</span><span class="n">listener</span><span class="o">)</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
    * 抛出异常或超过允许的超时调用被视为失败调用，否则视为成功调用
    */</span>
    <span class="k">def</span> <span class="nf">callThrough</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">body</span><span class="k">:</span> <span class="k">⇒</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">defineFailureFn</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">⇒</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

    <span class="c1">//将非致命异常转化为Future.failed</span>
    <span class="k">def</span> <span class="nf">materialize</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="k">⇒</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="k">try</span> <span class="n">value</span> <span class="k">catch</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">NonFatal</span><span class="o">(</span><span class="n">t</span><span class="o">)</span> <span class="k">⇒</span> <span class="nv">Future</span><span class="o">.</span><span class="py">failed</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="c1">//callTimeout=0时，不需要定时器</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">callTimeout</span> <span class="o">==</span> <span class="nv">Duration</span><span class="o">.</span><span class="py">Zero</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">start</span> <span class="k">=</span> <span class="nv">System</span><span class="o">.</span><span class="py">nanoTime</span><span class="o">()</span>
        <span class="k">val</span> <span class="nv">f</span> <span class="k">=</span> <span class="nf">materialize</span><span class="o">(</span><span class="n">body</span><span class="o">)</span>

        <span class="nv">f</span><span class="o">.</span><span class="py">onComplete</span> <span class="o">{</span>
        <span class="k">case</span> <span class="n">s</span><span class="k">:</span> <span class="kt">Success</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">⇒</span>
            <span class="c1">//触发调用成功监听器</span>
            <span class="nf">notifyCallSuccessListeners</span><span class="o">(</span><span class="n">start</span><span class="o">)</span>
            <span class="nf">callSucceeds</span><span class="o">()</span>
        <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">⇒</span>
            <span class="c1">//触发调用失败监听器</span>
            <span class="nf">notifyCallFailureListeners</span><span class="o">(</span><span class="n">start</span><span class="o">)</span>
            <span class="nf">callFails</span><span class="o">()</span>
        <span class="o">}</span>

        <span class="n">f</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="k">val</span> <span class="nv">start</span> <span class="k">=</span> <span class="nv">System</span><span class="o">.</span><span class="py">nanoTime</span><span class="o">()</span>
        <span class="k">val</span> <span class="nv">p</span> <span class="k">=</span> <span class="nc">Promise</span><span class="o">[</span><span class="kt">T</span><span class="o">]()</span>
        <span class="c1">//构造函数传进来的ExecutionContext - 线程池</span>
        <span class="k">implicit</span> <span class="k">val</span> <span class="nv">ec</span> <span class="k">=</span> <span class="n">sameThreadExecutionContext</span>

        <span class="nv">p</span><span class="o">.</span><span class="py">future</span><span class="o">.</span><span class="py">onComplete</span> <span class="o">{</span> <span class="n">fResult</span> <span class="k">⇒</span>
        <span class="nf">if</span> <span class="o">(</span><span class="nf">defineFailureFn</span><span class="o">(</span><span class="n">fResult</span><span class="o">))</span> <span class="o">{</span>
            <span class="nf">callFails</span><span class="o">()</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">//触发调用成功监听器</span>
            <span class="nf">notifyCallSuccessListeners</span><span class="o">(</span><span class="n">start</span><span class="o">)</span>
            <span class="nf">callSucceeds</span><span class="o">()</span>
        <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//延迟callTimeout时间后检查Promise p的状态是否失败，失败则抛出断路器超时异常</span>
        <span class="k">val</span> <span class="nv">timeout</span> <span class="k">=</span> <span class="nv">scheduler</span><span class="o">.</span><span class="py">scheduleOnce</span><span class="o">(</span><span class="n">callTimeout</span><span class="o">)</span> <span class="o">{</span>
        <span class="nf">if</span> <span class="o">(</span><span class="n">p</span> <span class="n">tryFailure</span> <span class="n">timeoutEx</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//触发调用超时监听器</span>
            <span class="nf">notifyCallTimeoutListeners</span><span class="o">(</span><span class="n">start</span><span class="o">)</span>
        <span class="o">}</span>
        <span class="o">}</span>

        <span class="nf">materialize</span><span class="o">(</span><span class="n">body</span><span class="o">).</span><span class="py">onComplete</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="k">⇒</span>
            <span class="nv">p</span><span class="o">.</span><span class="py">trySuccess</span><span class="o">(</span><span class="n">result</span><span class="o">)</span>
            <span class="c1">//取消掉定时器</span>
            <span class="nv">timeout</span><span class="o">.</span><span class="py">cancel</span>
        <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">⇒</span>
            <span class="nf">if</span> <span class="o">(</span><span class="nv">p</span><span class="o">.</span><span class="py">tryFailure</span><span class="o">(</span><span class="n">ex</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">//触发调用失败监听器</span>
            <span class="nf">notifyCallFailureListeners</span><span class="o">(</span><span class="n">start</span><span class="o">)</span>
            <span class="o">}</span>
            <span class="c1">//取消掉定时器</span>
            <span class="nv">timeout</span><span class="o">.</span><span class="py">cancel</span>
        <span class="o">}</span>
        <span class="nv">p</span><span class="o">.</span><span class="py">future</span>
    <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="nf">callThrough</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">body</span><span class="k">:</span> <span class="k">⇒</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nf">callThrough</span><span class="o">(</span><span class="n">body</span><span class="o">,</span> <span class="nv">CircuitBreaker</span><span class="o">.</span><span class="py">exceptionAsFailure</span><span class="o">)</span>

    <span class="cm">/**
    * 所有状态的抽象调用方法
    */</span>
    <span class="k">def</span> <span class="nf">invoke</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">body</span><span class="k">:</span> <span class="k">⇒</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">defineFailureFn</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">⇒</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>

    <span class="k">def</span> <span class="nf">invoke</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">body</span><span class="k">:</span> <span class="k">⇒</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">body</span><span class="o">,</span> <span class="nv">CircuitBreaker</span><span class="o">.</span><span class="py">exceptionAsFailure</span><span class="o">)</span>

    <span class="cm">/**
    * 成功时调用
    */</span>
    <span class="k">def</span> <span class="nf">callSucceeds</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span>

    <span class="cm">/**
    * 失败时调用
    */</span>
    <span class="k">def</span> <span class="nf">callFails</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span>

    <span class="cm">/**
    * 转换状态在转换期间调用，调用子类方法_enter后通知侦听器
    */</span>
    <span class="k">final</span> <span class="k">def</span> <span class="nf">enter</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nc">_enter</span><span class="o">()</span>
    <span class="c1">//通知所有的转化监听器</span>
    <span class="nf">notifyTransitionListeners</span><span class="o">()</span>
    <span class="o">}</span>

    <span class="cm">/**
    * 抽象方法
    */</span>
    <span class="k">def</span> <span class="nf">_enter</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>

   <span class="cm">/**
    * 闭合状态的具体实现
    * 继承自AtomicInteger，拥有原子计数器，标记处在闭合状态时的错误次数
    */</span>
<span class="k">private</span> <span class="k">object</span> <span class="nc">Closed</span> <span class="k">extends</span> <span class="nc">AtomicInteger</span> <span class="k">with</span> <span class="nc">State</span> <span class="o">{</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">invoke</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">body</span><span class="k">:</span> <span class="k">⇒</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">defineFailureFn</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">⇒</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="nf">callThrough</span><span class="o">(</span><span class="n">body</span><span class="o">,</span> <span class="n">defineFailureFn</span><span class="o">)</span>

    <span class="c1">//成功时重置错误次数为0</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">callSucceeds</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nf">set</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

    <span class="c1">//失败时，如果当前错误次数等于最大错误次数，将断路器设为打开状态，不再处理任务</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">callFails</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nf">if</span> <span class="o">(</span><span class="nf">incrementAndGet</span><span class="o">()</span> <span class="o">==</span> <span class="n">maxFailures</span><span class="o">)</span> <span class="nf">tripBreaker</span><span class="o">(</span><span class="nc">Closed</span><span class="o">)</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">_enter</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="c1">//重置错误次数，并且修改断路器的退避时间    </span>
    <span class="nf">set</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
    <span class="nf">swapResetTimeout</span><span class="o">(</span><span class="n">currentResetTimeout</span><span class="o">,</span> <span class="n">resetTimeout</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">toString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"Closed with failure count = "</span> <span class="o">+</span> <span class="nf">get</span><span class="o">()</span>
<span class="o">}</span>

   <span class="cm">/**
    * 半开状态的具体实现
    * 继承自AtomicBoolean，标记是否为半开状态
    */</span>
<span class="k">private</span> <span class="k">object</span> <span class="nc">HalfOpen</span> <span class="k">extends</span> <span class="nc">AtomicBoolean</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="k">with</span> <span class="nc">State</span> <span class="o">{</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">invoke</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">body</span><span class="k">:</span> <span class="k">⇒</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">defineFailureFn</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">⇒</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="nf">if</span> <span class="o">(</span><span class="nf">compareAndSet</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">))</span>
        <span class="c1">//处于半开状态时，可以处理第一次请求</span>
        <span class="nf">callThrough</span><span class="o">(</span><span class="n">body</span><span class="o">,</span> <span class="n">defineFailureFn</span><span class="o">)</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="c1">//后续请求将使得断路器打开，不再处理任务</span>
        <span class="nf">notifyCallBreakerOpenListeners</span><span class="o">()</span>
        <span class="c1">//且同时抛出断路器异常，0表示处于半开状态</span>
        <span class="nv">Future</span><span class="o">.</span><span class="py">failed</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">new</span> <span class="nc">CircuitBreakerOpenException</span><span class="o">(</span><span class="mf">0.</span><span class="n">seconds</span><span class="o">))</span>
    <span class="o">}</span>
    <span class="c1">//半开状态的调用成功时，断路器回到闭合状态 </span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">callSucceeds</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nf">resetBreaker</span><span class="o">()</span>
    <span class="c1">//半开状态调用失败时，回到打开状态</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">callFails</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nf">tripBreaker</span><span class="o">(</span><span class="nc">HalfOpen</span><span class="o">)</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">_enter</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="nf">set</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">toString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"Half-Open currently testing call for success = "</span> <span class="o">+</span> <span class="nf">get</span><span class="o">()</span>
<span class="o">}</span>

<span class="cm">/**
 * 打开状态的具体实现，继承自AtomicLong，标记打开时间
 */</span>
<span class="k">private</span> <span class="k">object</span> <span class="nc">Open</span> <span class="k">extends</span> <span class="nc">AtomicLong</span> <span class="k">with</span> <span class="nc">State</span> <span class="o">{</span>

    <span class="k">override</span> <span class="k">def</span> <span class="nf">invoke</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">body</span><span class="k">:</span> <span class="k">⇒</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">defineFailureFn</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">⇒</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="c1">//唤起所有打开监听器    </span>
    <span class="nf">notifyCallBreakerOpenListeners</span><span class="o">()</span>
    <span class="c1">//返回 异常，包含重置之前的剩余时间</span>
    <span class="nv">Future</span><span class="o">.</span><span class="py">failed</span><span class="o">(</span><span class="k">new</span> <span class="nc">CircuitBreakerOpenException</span><span class="o">(</span><span class="nf">remainingDuration</span><span class="o">()))</span>
    <span class="o">}</span>
    
    <span class="c1">//计算剩余时间</span>
    <span class="k">private</span> <span class="k">def</span> <span class="nf">remainingDuration</span><span class="o">()</span><span class="k">:</span> <span class="kt">FiniteDuration</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">fromOpened</span> <span class="k">=</span> <span class="nv">System</span><span class="o">.</span><span class="py">nanoTime</span><span class="o">()</span> <span class="o">-</span> <span class="n">get</span>
    <span class="k">val</span> <span class="nv">diff</span> <span class="k">=</span> <span class="nv">currentResetTimeout</span><span class="o">.</span><span class="py">toNanos</span> <span class="o">-</span> <span class="n">fromOpened</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">diff</span> <span class="o">&lt;=</span> <span class="mi">0L</span><span class="o">)</span> <span class="nv">Duration</span><span class="o">.</span><span class="py">Zero</span>
    <span class="k">else</span> <span class="nv">diff</span><span class="o">.</span><span class="py">nanos</span>
    <span class="o">}</span>

    <span class="cm">/**
    * 对于打开状态不提供此操作，因为调用永远不会执行，因此没有成功或失败
    */</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">callSucceeds</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">()</span>

    <span class="cm">/**
    * 对于打开状态不提供此操作，因为调用永远不会执行，因此没有成功或失败
    */</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">callFails</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">()</span>

    <span class="cm">/**
    * 进入此状态后，通过[[akka.actor.Scheduler]]安排一次尝试重置的时间，并保存输入时间以计算尝试重置之前的剩余时间
    */</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">_enter</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nf">set</span><span class="o">(</span><span class="nv">System</span><span class="o">.</span><span class="py">nanoTime</span><span class="o">())</span>
    <span class="nv">scheduler</span><span class="o">.</span><span class="py">scheduleOnce</span><span class="o">(</span><span class="n">currentResetTimeout</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//在打开状态时，尝试等待currentResetTimeout时间后过渡到半开状态，以便可以恢复断路器</span>
        <span class="nf">attemptReset</span><span class="o">()</span>
    <span class="o">}</span>
    <span class="c1">//下一个重置时间，使用退避，exponentialBackoffFactor=2</span>
    <span class="k">val</span> <span class="nv">nextResetTimeout</span> <span class="k">=</span> <span class="n">currentResetTimeout</span> <span class="o">*</span> <span class="n">exponentialBackoffFactor</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="n">f</span><span class="k">:</span> <span class="kt">FiniteDuration</span> <span class="k">⇒</span> <span class="kt">f</span>
        <span class="k">case</span> <span class="k">_</span> <span class="k">⇒</span> <span class="n">currentResetTimeout</span>
    <span class="o">}</span>
    <span class="c1">//下次的退避时间必须小于用户指定的最大退避时间</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">nextResetTimeout</span> <span class="o">&lt;</span> <span class="n">maxResetTimeout</span><span class="o">)</span>
        <span class="nf">swapResetTimeout</span><span class="o">(</span><span class="n">currentResetTimeout</span><span class="o">,</span> <span class="n">nextResetTimeout</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="cm">/**
    * 重写以获得更具描述性的toString方法
    */</span>
    <span class="k">override</span> <span class="k">def</span> <span class="nf">toString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"Open"</span>
<span class="o">}</span>

<span class="o">}</span>

<span class="cm">/**
* 断路器打开时引发异常
*
* @param remainingDuration 保存尝试重置之前的剩余时间 持续时间为零表示断路器当前处于半开状态
* @param message           默认为“断路器打开；调用快速失败”
*/</span>
<span class="k">class</span> <span class="nc">CircuitBreakerOpenException</span><span class="o">(</span>
<span class="k">val</span> <span class="nv">remainingDuration</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">,</span>
<span class="n">message</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"Circuit Breaker is open; calls are failing fast"</span><span class="o">)</span>
<span class="k">extends</span> <span class="nc">AkkaException</span><span class="o">(</span><span class="n">message</span><span class="o">)</span> <span class="k">with</span> <span class="nc">NoStackTrace</span>
</code></pre></div></div><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 抽象断路器
 */</span>
<span class="kn">package</span> <span class="nn">akka.pattern</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">akka.util.Unsafe</span><span class="o">;</span>
<span class="c1">//使用Unsafe反射获取CircuitBreaker的属性值</span>
<span class="kd">class</span> <span class="nc">AbstractCircuitBreaker</span> <span class="o">{</span>
  <span class="kd">protected</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">long</span> <span class="n">stateOffset</span><span class="o">;</span>
  <span class="kd">protected</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">long</span> <span class="n">resetTimeoutOffset</span><span class="o">;</span>

  <span class="kd">static</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="n">stateOffset</span> <span class="o">=</span> <span class="nc">Unsafe</span><span class="o">.</span><span class="na">instance</span><span class="o">.</span><span class="na">objectFieldOffset</span><span class="o">(</span><span class="nc">CircuitBreaker</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"_currentStateDoNotCallMeDirectly"</span><span class="o">));</span>
      <span class="n">resetTimeoutOffset</span> <span class="o">=</span> <span class="nc">Unsafe</span><span class="o">.</span><span class="na">instance</span><span class="o">.</span><span class="na">objectFieldOffset</span><span class="o">(</span><span class="nc">CircuitBreaker</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"_currentResetTimeoutDoNotCallMeDirectly"</span><span class="o">));</span>
    <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="nc">Throwable</span> <span class="n">t</span><span class="o">){</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">ExceptionInInitializerError</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://blog.dreamylost.cn" target="_blank">梦境迷离</a></li><li>本文链接：<a href="https://blog.dreamylost.cn/akka%E6%BA%90%E7%A0%81/Akka%E6%BA%90%E7%A0%81-CircuitBreaker.html" target="_blank">https://blog.dreamylost.cn/akka%E6%BA%90%E7%A0%81/Akka%E6%BA%90%E7%A0%81-CircuitBreaker.html</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/akka%E6%BA%90%E7%A0%81/Akka%E6%BA%90%E7%A0%81-Cir', clientID: '061aadb5d449c0877d7d', clientSecret: '9aa7af7c248a7e36a07a86993e11a7acf7fbd353', repo: 'dreamylost-comments', owner: 'jxnu-liguobin', admin: ['jxnu-liguobin'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@built/assets/search_data.json?v=1697168372', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"> <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-8236444920328818" data-ad-slot="6220614560" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2019 <span title="梦境迷离">梦境迷离</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/jxnu-liguobin/jxnu-liguobin.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://blog.dreamylost.cn/" title="首页" target="">首页</a></li><li> <a href="https://blog.dreamylost.cn/categories/" title="分类" target="">分类</a></li><li> <a href="https://blog.dreamylost.cn/archives/" title="归档" target="">归档</a></li><li> <a href="https://blog.dreamylost.cn/open-source/" title="开源" target="">开源</a></li><li> <a href="https://blog.dreamylost.cn/wiki/" title="维基" target="">维基</a></li><li> <a href="https://blog.dreamylost.cn/links/" title="链接" target="">链接</a></li><li> <a href="https://blog.dreamylost.cn/about/" title="关于" target="">关于</a></li><li><a href="https://blog.dreamylost.cn/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2019-09-20 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-147390701-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
