<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>HashMap &mdash; 梦境迷离</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="canonical" href="https://blog.dreamylost.cn/java%E6%BA%90%E7%A0%81/Java%E6%BA%90%E7%A0%81-HashMap.html"><link rel="alternate" type="application/atom+xml" title="梦境迷离" href="https://blog.dreamylost.cn/feed.xml"><link rel="shortcut icon" href="https://dreamylost.cn/favicon.ico"><meta property="og:title" content="HashMap"><meta name="keywords" content="梦境迷离, jxnu-liguobin"><meta name="og:keywords" content="梦境迷离, jxnu-liguobin"><meta name="description" content="在JDK8及以后的版本中，HashMap引入了红黑树结构，其底层的数据结构变成了数组+链表或数组+红黑树。添加元素时，若桶中链表个数超过8，链表会转换成红黑树。"><meta name="og:description" content="在JDK8及以后的版本中，HashMap引入了红黑树结构，其底层的数据结构变成了数组+链表或数组+红黑树。添加元素时，若桶中链表个数超过8，链表会转换成红黑树。"><meta property="og:url" content="https://blog.dreamylost.cn/java%E6%BA%90%E7%A0%81/Java%E6%BA%90%E7%A0%81-HashMap.html"><meta property="og:site_name" content="梦境迷离"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2018-08-12"> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/main.js"></script> <script data-ad-client="ca-pub-8236444920328818" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://blog.dreamylost.cn/" title="梦境迷离"><span class="octicon octicon-mark-github"></span> 梦境迷离</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://blog.dreamylost.cn/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://blog.dreamylost.cn/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://blog.dreamylost.cn/archives/" class=" site-header-nav-item" target="" title="归档">归档</a> <a href="https://blog.dreamylost.cn/open-source/" class=" site-header-nav-item" target="" title="开源">开源</a> <a href="https://blog.dreamylost.cn/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://blog.dreamylost.cn/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://blog.dreamylost.cn/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="HashMap"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">HashMap</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2018/08/12 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://blog.dreamylost.cn/categories/#Java源码" title="Java源码">Java源码</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 50449 字，约 145 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"> <img style="height:72px;width:72px" src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/images/qrcode.jpg" alt="梦境迷离" /></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><p>在JDK8及以后的版本中，HashMap引入了红黑树结构，其底层的数据结构变成了数组+链表或数组+红黑树。添加元素时，若桶中链表个数超过8，链表会转换成红黑树。</p><h1 id="为什么临界值是8">为什么临界值是8？</h1><p>源码中有这样一段注释 Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use (see TREEIFYTHRESHOLD). And when they become too small (due to removal or resizing) they are converted back to plain bins. In usages with well-distributed user hashCodes, tree bins are rarely used. Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution (http://en.wikipedia.org/wiki/Poissondistribution) with a parameter of about 0.5 on average for the default resizing threshold of 0.75, although with a large variance because of resizing granularity. Ignoring variance, the expected occurrences of list size k are (exp(-pow(0.5, k) / factorial(k)). The first values are: 0: 0.60653066 1: 0.30326533 2: 0.07581633 3: 0.01263606 4: 0.00157952 5: 0.00015795 6: 0.00001316 7: 0.00000094 8: 0.00000006 more: less than 1 in ten million</p><p>理想情况下使用随机的哈希码，容器中节点分布在hash桶中的频率遵循泊松分布(具体可以查看http://en.wikipedia.org/wiki/Poisson_distribution)，按照泊松分布的计算公式计算出了桶中元素个数和概率的对照表，可以看到链表中元素个数为8时的概率已经非常小，再多的就更少了，所以原作者在选择链表元素个数时选择了8，是根据概率统计而选择的。</p><h1 id="默认加载因子为什么选择075">默认加载因子为什么选择0.75?</h1><p>HashMap有两个参数影响其性能：初始容量和加载因子。容量是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动扩容之前可以达到多满的一种度量。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行扩容、rehash操作（即重建内部数据结构），扩容后的哈希表将具有两倍的原容量。</p><p>通常，加载因子需要在时间和空间成本上寻求一种折衷。加载因子过高，例如为1，虽然减少了空间开销，提高了空间利用率，但同时也增加了查询时间成本；加载因子过低，例如0.5，虽然可以减少查询时间成本，但是空间利用率很低，同时提高了rehash操作的次数</p><p>【这很容易理解，当加载因子为1时，桶中所有位置都可用，但是不可避免的冲突可能性增大，试想桶中如果100个坑，已经有了98个坑位被占了，剩下两个是不是得费尽心思才能正确进入？而如果100个坑，还剩50个坑可用，是不是随意入坑的概率高得多？别忘了，一旦冲突就是要成链或红黑树，比起直接在桶中获取速度当然慢了，而当加载因子为0.5时，随意hash存放进桶更容易不冲突，但是一旦占用一半就需要扩容就太消耗性能，毕竟扩容是费时间的，而且一半的坑位用不了是不是太浪费存储空间了？】</p><p>在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少rehash操作次数，所以，一般在使用HashMap时建议根据预估值设置初始容量，减少扩容操作。 选择0.75作为默认的加载因子，完全是时间和空间成本上寻求的一种折衷选择。</p><h1 id="源码">源码</h1><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">java.util</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">sun.misc.SharedSecrets</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InvalidObjectException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.Serializable</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.ParameterizedType</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Type</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.BiConsumer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.BiFunction</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.Consumer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.Function</span><span class="o">;</span>

<span class="cm">/**
 * HashMap是常用的Java集合之一，是基于哈希表的Map接口的实现。与HashTable主要区别为不支持同步和允许null作为key和value。
 *
 * 扩容由于是2的幂次，所以比Hashtable快，但是这样可能造成冲突概率增加，所以进行二次hash
 * HashMap由于使用了2的幂次方，所以在取模运算时不需要做除法，只需要位的与运算就可以了。
 * HashMap在调用了对象的hashCode方法之后，又做了一些位运算在打散数据
 * 
 * HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。
 * 如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。
 * 
 * 在JDK1.6中，HashMap采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。
 * 但是当位于一个数组中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。
 * 
 * 而JDK1.8中，HashMap采用数组+链表+红黑树实现，当链表长度超过阈值8时，将链表转换为红黑树，这样大大减少了查找时间。
 * 原本Map.Entry接口的实现类Entry改名为了Node。转化为红黑树时改用另一种实现TreeNode。
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">AbstractMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span>
        <span class="kd">implements</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;,</span> <span class="nc">Cloneable</span><span class="o">,</span> <span class="nc">Serializable</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">362498820763181265L</span><span class="o">;</span>


    <span class="cm">/**
     * 默认的初始容量（容量为HashMap中槽的数目）是16，且实际容量必须是2的整数次幂。
     * 理由
     * 1:节省空间，计算索引的时候几乎使每个位置均可存放元素
     * 2:在计算hashCode的时候只需要改变一位，效率高
     * 3:使得元素分布均匀，减少冲突发生
     * 4:若传入不是2的幂，将使用最接近的替换
     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">DEFAULT_INITIAL_CAPACITY</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="c1">// aka 16</span>

    <span class="cm">/**
     * 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换）
     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MAXIMUM_CAPACITY</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="o">;</span>

    <span class="cm">/**
     * 默认装填因子0.75，如果当前键值对个数 &gt;= HashMap最大容量*装填因子，进行rehash操作
     * 表示已经存放的元素，占整个hash表的比例，0.75表示已经占用75%空间了。
     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">float</span> <span class="no">DEFAULT_LOAD_FACTOR</span> <span class="o">=</span> <span class="mf">0.75f</span><span class="o">;</span>

    <span class="cm">/**
     * JDK1.8 新加，Entry链表最大长度，当桶中节点数目大于该长度时，将链表转成红黑树存储；
     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">TREEIFY_THRESHOLD</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>

    <span class="cm">/**
     * JDK1.8 新加，当桶中节点数小于该长度，将红黑树转为链表存储；
     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">UNTREEIFY_THRESHOLD</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>

    <span class="cm">/**
     * 桶可能被转化为树形结构的最小容量。当哈希表的大小超过这个阈值，才会把链式结构转化成树型结构，否则仅采取扩容来尝试减少冲突。
     * 应该至少4*TREEIFY_THRESHOLD来避免扩容和树形结构化之间的冲突。
     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MIN_TREEIFY_CAPACITY</span> <span class="o">=</span> <span class="mi">64</span><span class="o">;</span>

    <span class="cm">/**
     * JDK1.6用Entry描述键值对，JDK1.8中用Node代替Entry
     */</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="c1">// hash存储key的hashCode</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">;</span>
        <span class="c1">// final:一个键值对的key不可改变</span>
        <span class="kd">final</span> <span class="no">K</span> <span class="n">key</span><span class="o">;</span>
        <span class="no">V</span> <span class="n">value</span><span class="o">;</span>
        <span class="c1">//指向下个节点的引用</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>

        <span class="c1">//构造函数</span>
        <span class="nc">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="no">K</span> <span class="nf">getKey</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">key</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="no">V</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">key</span> <span class="o">+</span> <span class="s">"="</span> <span class="o">+</span> <span class="n">value</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">^</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="no">V</span> <span class="nf">setValue</span><span class="o">(</span><span class="no">V</span> <span class="n">newValue</span><span class="o">)</span> <span class="o">{</span>
            <span class="no">V</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">newValue</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="k">this</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;?,</span> <span class="o">?&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;?,</span> <span class="o">?&gt;)</span> <span class="n">o</span><span class="o">;</span>
                <span class="c1">// Objects.equals方法是Obejcts的静态工具方法，可以使用可变长参数</span>
                <span class="k">if</span> <span class="o">(</span><span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getKey</span><span class="o">())</span> <span class="o">&amp;&amp;</span>
                        <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getValue</span><span class="o">()))</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/* ---------------- Static utilities -------------- */</span>

    <span class="cm">/**
     * HashMap中键值对的存储形式为链表节点，hashCode相同的节点（位于同一个桶）用链表组织
     * hash方法分为三步:
     * 1.取key的hashCode
     * 2.key的hashCode右移16位然后与自己异或
     * 3.将第一步和第二步得到的结果进行取模运算。
     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">hash</span><span class="o">(</span><span class="nc">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">h</span><span class="o">;</span>
        <span class="c1">//计算key的hashCode, h = Objects.hashCode(key)</span>
        <span class="c1">//h &gt;&gt;&gt; 16表示对h无符号右移16位，高位补0，然后h与h &gt;&gt;&gt; 16按位异或</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">())</span> <span class="o">^</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">16</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 如果参数x实现了Comparable接口，返回参数x的类名，否则返回null
     */</span>
    <span class="kd">static</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">comparableClassFor</span><span class="o">(</span><span class="nc">Object</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="k">instanceof</span> <span class="nc">Comparable</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">c</span><span class="o">;</span>
            <span class="nc">Type</span><span class="o">[]</span> <span class="n">ts</span><span class="o">,</span> <span class="n">as</span><span class="o">;</span>
            <span class="nc">Type</span> <span class="n">t</span><span class="o">;</span>
            <span class="nc">ParameterizedType</span> <span class="n">p</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">c</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">getClass</span><span class="o">())</span> <span class="o">==</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="c1">// bypass checks</span>
                <span class="k">return</span> <span class="n">c</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">ts</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">getGenericInterfaces</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ts</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(((</span><span class="n">t</span> <span class="o">=</span> <span class="n">ts</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="k">instanceof</span> <span class="nc">ParameterizedType</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                            <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="o">(</span><span class="nc">ParameterizedType</span><span class="o">)</span> <span class="n">t</span><span class="o">).</span><span class="na">getRawType</span><span class="o">()</span> <span class="o">==</span>
                                    <span class="nc">Comparable</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                            <span class="o">(</span><span class="n">as</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getActualTypeArguments</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
                            <span class="n">as</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">as</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">c</span><span class="o">)</span> <span class="c1">// type arg is c</span>
                        <span class="k">return</span> <span class="n">c</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 如果x的类型为kc，则返回k.compareTo(x)，否则返回0
     */</span>
    <span class="nd">@SuppressWarnings</span><span class="o">({</span><span class="s">"rawtypes"</span><span class="o">,</span> <span class="s">"unchecked"</span><span class="o">})</span> <span class="c1">// for cast to Comparable</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">compareComparables</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">kc</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">k</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">x</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span> <span class="o">!=</span> <span class="n">kc</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span>
                <span class="o">((</span><span class="nc">Comparable</span><span class="o">)</span> <span class="n">k</span><span class="o">).</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 结果为&gt;=cap的最小2的自然数幂
     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">tableSizeFor</span><span class="o">(</span><span class="kt">int</span> <span class="n">cap</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//先移位再或运算，最终保证返回值是2的整数幂</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">cap</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">2</span><span class="o">;</span>
        <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">4</span><span class="o">;</span>
        <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">8</span><span class="o">;</span>
        <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">16</span><span class="o">;</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="no">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">?</span> <span class="no">MAXIMUM_CAPACITY</span> <span class="o">:</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/* ---------------- Fields -------------- */</span>

    <span class="cm">/**
     * 哈希桶数组，分配的时候，table的长度总是2的幂
     */</span>
    <span class="kd">transient</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">table</span><span class="o">;</span>

    <span class="cm">/**
     * HashMap将数据转换成set的另一种存储形式，这个变量主要用于迭代功能
     */</span>
    <span class="kd">transient</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">entrySet</span><span class="o">;</span>

    <span class="cm">/**
     * 实际存储的数量，则HashMap的size()方法，实际返回的就是这个值，isEmpty()也是判断该值是否为0
     */</span>
    <span class="kd">transient</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>

    <span class="cm">/**
     * hashmap结构被改变的次数，fail-fast机制
     * 快速失败的依据
     */</span>
    <span class="kd">transient</span> <span class="kt">int</span> <span class="n">modCount</span><span class="o">;</span>

    <span class="cm">/**
     * HashMap的扩容阈值，在HashMap中存储的Node键值对超过这个数量时，自动扩容容量为原来的二倍
     * 美 [ˈθrɛʃˌ(h)oʊld]
     * @serial
     */</span>
    <span class="kt">int</span> <span class="n">threshold</span><span class="o">;</span>

    <span class="cm">/**
     * HashMap的负加载因子，可计算出当前table长度下的扩容阈值：threshold = loadFactor * table.length
     *
     * @serial
     */</span>
    <span class="kd">final</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">;</span>

    <span class="cm">/* ---------------- Public operations -------------- */</span>

    <span class="cm">/**
     * 使用指定的初始化容量initial capacity 和加载因子load factor构造一个空HashMap
     *
     * @param initialCapacity 初始化容量
     * @param loadFactor      加载因子【默认0.75】
     * @throws IllegalArgumentException 如果指定的初始化容量为负数或者加载因子为非正数
     */</span>
    <span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">,</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Illegal initial capacity: "</span> <span class="o">+</span>
                    <span class="n">initialCapacity</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&gt;</span> <span class="no">MAXIMUM_CAPACITY</span><span class="o">)</span>
            <span class="n">initialCapacity</span> <span class="o">=</span> <span class="no">MAXIMUM_CAPACITY</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">loadFactor</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nc">Float</span><span class="o">.</span><span class="na">isNaN</span><span class="o">(</span><span class="n">loadFactor</span><span class="o">))</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Illegal load factor: "</span> <span class="o">+</span>
                    <span class="n">loadFactor</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">loadFactor</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">threshold</span> <span class="o">=</span> <span class="n">tableSizeFor</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 使用指定的初始化容量initial capacity和默认加载因子DEFAULT_LOAD_FACTOR（0.75）构造一个空HashMap
     *
     * @param initialCapacity 初始化容量
     * @throws IllegalArgumentException 如果指定的初始化容量为负数
     */</span>
    <span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">,</span> <span class="no">DEFAULT_LOAD_FACTOR</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 使用指定的初始化容量（16）和默认加载因子DEFAULT_LOAD_FACTOR（0.75）构造一个空HashMap
     */</span>
    <span class="kd">public</span> <span class="nf">HashMap</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="no">DEFAULT_LOAD_FACTOR</span><span class="o">;</span> <span class="c1">// all other fields defaulted</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 使用指定Map m构造新的HashMap。使用指定的初始化容量（16）和默认加载因子DEFAULT_LOAD_FACTOR（0.75）
     *
     * @param m 指定的map
     * @throws NullPointerException 如果指定的map是null
     */</span>
    <span class="kd">public</span> <span class="nf">HashMap</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="no">DEFAULT_LOAD_FACTOR</span><span class="o">;</span>
        <span class="n">putMapEntries</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Map.putAll and Map constructor的实现需要的方法
     * 将m的键值对插入本map中
     *
     * @param m     指定的map
     * @param evict 初始化map时使用false，否则使用true
     */</span>
    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">putMapEntries</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">evict</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="c1">//如果参数map不为空</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 判断table是否已经初始化</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">table</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// pre-size</span>
                <span class="c1">// 未初始化，s为m的实际元素个数</span>
                <span class="kt">float</span> <span class="n">ft</span> <span class="o">=</span> <span class="o">((</span><span class="kt">float</span><span class="o">)</span> <span class="n">s</span> <span class="o">/</span> <span class="n">loadFactor</span><span class="o">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="no">F</span><span class="o">;</span>
                <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="o">((</span><span class="n">ft</span> <span class="o">&lt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="no">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">?</span>
                        <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">ft</span> <span class="o">:</span> <span class="no">MAXIMUM_CAPACITY</span><span class="o">);</span>
                <span class="c1">// 计算得到的t大于阈值，则初始化阈值</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">)</span>
                    <span class="c1">//根据容量初始化临界值</span>
                    <span class="n">threshold</span> <span class="o">=</span> <span class="n">tableSizeFor</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
                <span class="c1">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">)</span>
                <span class="c1">//扩容处理</span>
                <span class="n">resize</span><span class="o">();</span>
            <span class="c1">// 将m中的所有元素添加至HashMap中</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">:</span> <span class="n">m</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
                <span class="no">K</span> <span class="n">key</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
                <span class="no">V</span> <span class="n">value</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
                <span class="n">putVal</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">evict</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 返回map中键值对映射的个数
     *
     * @return map中键值对映射的个数
     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">size</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 如果map中没有键值对映射，返回true
     *
     * @return 如果map中没有键值对映射，返回true
     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 返回指定的key映射的value，如果value为null，则返回null
     * get可以分为三个步骤：
     * 1.通过hash(Object key)方法计算key的哈希值hash。
     * 2.通过getNode( int hash, Object key)方法获取node。
     * 3.如果node为null，返回null，否则返回node.value。
     *
     * @see #put(Object, Object)
     */</span>
    <span class="kd">public</span> <span class="no">V</span> <span class="nf">get</span><span class="o">(</span><span class="nc">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
        <span class="c1">//根据key及其hash值查询node节点，如果存在，则返回该节点的value值</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">getNode</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 根据key的哈希值和key获取对应的节点
     * getNode可分为以下几个步骤：
     * 1.如果哈希表为空，或key对应的桶为空，返回null
     * 2.如果桶中的第一个节点就和指定参数hash和key匹配上了，返回这个节点。
     * 3.如果桶中的第一个节点没有匹配上，而且有后续节点
     * 3.1如果当前的桶采用红黑树，则调用红黑树的get方法去获取节点
     * 3.2如果当前的桶不采用红黑树，即桶中节点结构为链式结构，遍历链表，直到key匹配
     * 4.找到节点返回null，否则返回null。
     *
     * @param hash 指定参数key的哈希值
     * @param key  指定参数key
     * @return 返回node，如果没有则返回null
     */</span>
    <span class="kd">final</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">getNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">first</span><span class="o">,</span> <span class="n">e</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
        <span class="no">K</span> <span class="n">k</span><span class="o">;</span>
        <span class="c1">//如果哈希表不为空，而且key对应的桶上不为空</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
                <span class="o">(</span><span class="n">first</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//如果桶中的第一个节点就和指定参数hash和key匹配上了</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span> <span class="c1">// always check first node</span>
                    <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
                <span class="c1">//返回桶中的第一个节点</span>
                <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
            <span class="c1">//如果桶中的第一个节点没有匹配上，而且有后续节点</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">//如果当前的桶采用红黑树，则调用红黑树的get方法去获取节点</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">first</span> <span class="k">instanceof</span> <span class="nc">TreeNode</span><span class="o">)</span>
                    <span class="k">return</span> <span class="o">((</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;)</span> <span class="n">first</span><span class="o">).</span><span class="na">getTreeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
                <span class="c1">//如果当前的桶不采用红黑树，即桶中节点结构为链式结构</span>
                <span class="k">do</span> <span class="o">{</span>
                    <span class="c1">//遍历链表，直到key匹配</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                            <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
                        <span class="k">return</span> <span class="n">e</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//如果哈希表为空，或者没有找到节点，返回null</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 如果map中含有key为指定参数key的键值对，返回true
     *
     * @param key 指定参数key
     * @return 如果map中含有key为指定参数key的键值对，返回true
     * key.
     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsKey</span><span class="o">(</span><span class="nc">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">getNode</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 将指定参数key和指定参数value插入map中，如果key已经存在，那就替换key对应的value
     * put(K key, V value)可以分为三个步骤：
     * 1.通过hash(Object key)方法计算key的哈希值。
     * 2.通过putVal(hash(key), key, value, false, true)方法实现功能。
     * 3.返回putVal方法返回的结果。
     *
     * @param key   指定key
     * @param value 指定value
     * @return 如果value被替换，则返回旧的value，否则返回null。当然，可能key对应的value就是null
     */</span>
    <span class="kd">public</span> <span class="no">V</span> <span class="nf">put</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 倒数第二个参数false：表示允许旧值替换</span>
        <span class="c1">// 最后一个参数true：表示HashMap不处于创建模式</span>
        <span class="k">return</span> <span class="nf">putVal</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Map.put和其他相关方法的实现需要的方法
     * putVal方法可以分为下面的几个步骤:
     * 1.如果哈希表为空，调用resize()创建一个哈希表。
     * 2.如果指定参数hash在表中没有对应的桶，即为没有碰撞，直接将键值对插入到哈希表中即可。
     * 3.如果有碰撞，遍历桶，找到key映射的节点
     * 3.1桶中的第一个节点就匹配了，将桶中的第一个节点记录起来。
     * 3.2如果桶中的第一个节点没有匹配，且桶中结构为红黑树，则调用红黑树对应的方法插入键值对。
     * 3.3如果不是红黑树，那么就肯定是链表。遍历链表，如果找到了key映射的节点，就记录这个节点，退出循环。如果没有找到，在链表尾部插入节点。插入后，如果链的长度大于TREEIFY_THRESHOLD这个临界值，则使用treeifyBin方法把链表转为红黑树。
     * 4.如果找到了key映射的节点，且节点不为null
     * 4.1记录节点的vlaue。
     * 4.2如果参数onlyIfAbsent为false，或者oldValue为null，替换value，否则不替换。
     * 4.3返回记录下来的节点的value。
     * 5.如果没有找到key映射的节点（2、3步中讲了，这种情况会插入到hashMap中），插入节点后size会加1，这时要检查size是否大于临界值threshold，如果大于会使用resize方法进行扩容。
     *
     * @param hash         指定参数key的哈希值
     * @param key          指定参数key
     * @param value        指定参数value
     * @param onlyIfAbsent 如果为true，即使指定参数key在map中已经存在，也不会替换value
     * @param evict        如果为false，数组table在创建模式中
     * @return 如果value被替换，则返回旧的value，否则返回null。当然，可能key对应的value就是null。
     */</span>
    <span class="kd">final</span> <span class="no">V</span> <span class="nf">putVal</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">onlyIfAbsent</span><span class="o">,</span>
                   <span class="kt">boolean</span> <span class="n">evict</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span>
        <span class="c1">//如果哈希表为空，调用resize()创建一个哈希表，并用变量n记录哈希表长度</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">resize</span><span class="o">()).</span><span class="na">length</span><span class="o">;</span>
        <span class="cm">/**
         * 如果指定参数hash在表中没有对应的桶，即为没有碰撞
         * Hash函数，(n - 1) &amp; hash 计算key将被放置的槽位
         * (n - 1) &amp; hash 本质上是hash % n，位运算更快,2^n=&gt;(n-1)=&gt;01111111,散列分布均匀的原因来自这里。[因为此时桶的位置由低位hash码决定，且不会浪费一个位置]
         */</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="c1">//直接将键值对插入到map中即可</span>
            <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="k">else</span> <span class="o">{</span><span class="c1">// 桶中已经存在元素</span>
            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
            <span class="no">K</span> <span class="n">k</span><span class="o">;</span>
            <span class="c1">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                    <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
                <span class="c1">// 将第一个元素赋值给e，用e来记录</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                <span class="c1">// 当前桶中无该键值对，且桶是红黑树结构，按照红黑树结构插入</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">p</span> <span class="k">instanceof</span> <span class="nc">TreeNode</span><span class="o">)</span>
                <span class="n">e</span> <span class="o">=</span> <span class="o">((</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;)</span> <span class="n">p</span><span class="o">).</span><span class="na">putTreeVal</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
                <span class="c1">// 当前桶中无该键值对，且桶是链表结构，按照链表结构插入到尾部</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">binCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">;</span> <span class="o">++</span><span class="n">binCount</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 遍历到链表尾部</span>
                    <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
                        <span class="c1">// 检查链表长度是否达到阈值，达到将该槽位节点组织形式转为红黑树</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">binCount</span> <span class="o">&gt;=</span> <span class="no">TREEIFY_THRESHOLD</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">// -1 for 1st</span>
                            <span class="n">treeifyBin</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">);</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="c1">// 链表节点的&lt;key, value&gt;与put操作&lt;key, value&gt;相同时，不做重复操作，跳出循环</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                            <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">// 找到或新建一个key和hashCode与插入元素相等的键值对，进行put操作</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// existing mapping for key</span>
                <span class="c1">// 记录e的value</span>
                <span class="no">V</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
                <span class="cm">/**
                 * onlyIfAbsent为false或旧值为null时，允许替换旧值
                 * 否则无需替换
                 */</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">onlyIfAbsent</span> <span class="o">||</span> <span class="n">oldValue</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
                <span class="c1">// 访问后回调</span>
                <span class="n">afterNodeAccess</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
                <span class="c1">// 返回旧值</span>
                <span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// 更新结构化修改信息</span>
        <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
        <span class="c1">// 键值对数目超过阈值时，进行rehash</span>
        <span class="k">if</span> <span class="o">(++</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">)</span>
            <span class="n">resize</span><span class="o">();</span>
        <span class="c1">// 插入后回调</span>
        <span class="n">afterNodeInsertion</span><span class="o">(</span><span class="n">evict</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 对table进行初始化或者扩容。
     * 如果table为null，则对table进行初始化
     * 
     *[扩容就是将前导0减少的过程。00010000=16 前导0个数3，高效]
     * 如果对table扩容，因为每次扩容都是翻倍，与原来计算（n-1）&amp;hash的结果相比，节点要么就在原来的位置，要么就被分配到“原位置+旧容量”这个位置
     * 
     * resize的步骤总结为:
     * 1.计算扩容后的容量，临界值。
     * 2.将hashMap的临界值修改为扩容后的临界值
     * 3.根据扩容后的容量新建数组，然后将hashMap的table的引用指向新数组。
     * 4.将旧数组的元素复制到table中。
     *
     * @return the table
     */</span>
    <span class="kd">final</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="nf">resize</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//新建oldTab数组保存扩容前的数组table</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">oldTab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
        <span class="c1">//获取原来数组的长度</span>
        <span class="kt">int</span> <span class="n">oldCap</span> <span class="o">=</span> <span class="o">(</span><span class="n">oldTab</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">oldTab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="c1">//原来数组扩容的临界值</span>
        <span class="kt">int</span> <span class="n">oldThr</span> <span class="o">=</span> <span class="n">threshold</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">newCap</span><span class="o">,</span> <span class="n">newThr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//如果扩容前的容量 &gt; 0</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">oldCap</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//如果原来的数组长度大于最大值(2^30)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">oldCap</span> <span class="o">&gt;=</span> <span class="no">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">//扩容临界值提高到正无穷</span>
                <span class="n">threshold</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
                <span class="c1">//无法进行扩容，返回原来的数组</span>
                <span class="k">return</span> <span class="n">oldTab</span><span class="o">;</span>
                <span class="c1">//如果现在容量的两倍小于MAXIMUM_CAPACITY且现在的容量大于DEFAULT_INITIAL_CAPACITY</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">newCap</span> <span class="o">=</span> <span class="n">oldCap</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&lt;</span> <span class="no">MAXIMUM_CAPACITY</span> <span class="o">&amp;&amp;</span>
                    <span class="n">oldCap</span> <span class="o">&gt;=</span> <span class="no">DEFAULT_INITIAL_CAPACITY</span><span class="o">)</span>
                <span class="c1">//临界值变为原来的2倍</span>
                <span class="n">newThr</span> <span class="o">=</span> <span class="n">oldThr</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">oldThr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">//如果旧容量 &lt;= 0，而且旧临界值 &gt; 0</span>
            <span class="c1">//数组的新容量设置为老数组扩容的临界值</span>
            <span class="n">newCap</span> <span class="o">=</span> <span class="n">oldThr</span><span class="o">;</span>
        <span class="k">else</span> <span class="o">{</span> <span class="c1">//如果旧容量 &lt;= 0，且旧临界值 &lt;= 0，新容量扩充为默认初始化容量，新临界值为DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY</span>
            <span class="n">newCap</span> <span class="o">=</span> <span class="no">DEFAULT_INITIAL_CAPACITY</span><span class="o">;</span><span class="c1">//新数组初始容量设置为默认值</span>
            <span class="n">newThr</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="o">(</span><span class="no">DEFAULT_LOAD_FACTOR</span> <span class="o">*</span> <span class="no">DEFAULT_INITIAL_CAPACITY</span><span class="o">);</span><span class="c1">//计算默认容量下的阈值</span>
        <span class="o">}</span>
        <span class="c1">// 计算新的resize上限</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">newThr</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span><span class="c1">//在当上面的条件判断中，只有oldThr &gt; 0成立时，newThr == 0</span>
            <span class="c1">//ft为临时临界值，下面会确定这个临界值是否合法，如果合法，那就是真正的临界值</span>
            <span class="kt">float</span> <span class="n">ft</span> <span class="o">=</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">newCap</span> <span class="o">*</span> <span class="n">loadFactor</span><span class="o">;</span>
            <span class="c1">//当新容量&lt; MAXIMUM_CAPACITY且ft &lt; (float)MAXIMUM_CAPACITY，新的临界值为ft，否则为Integer.MAX_VALUE</span>
            <span class="n">newThr</span> <span class="o">=</span> <span class="o">(</span><span class="n">newCap</span> <span class="o">&lt;</span> <span class="no">MAXIMUM_CAPACITY</span> <span class="o">&amp;&amp;</span> <span class="n">ft</span> <span class="o">&lt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="no">MAXIMUM_CAPACITY</span> <span class="o">?</span>
                    <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">ft</span> <span class="o">:</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">//将扩容后hashMap的临界值设置为newThr</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">newThr</span><span class="o">;</span>
        <span class="c1">//创建新的table，初始化容量为newCap</span>
        <span class="nd">@SuppressWarnings</span><span class="o">({</span><span class="s">"rawtypes"</span><span class="o">,</span> <span class="s">"unchecked"</span><span class="o">})</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">newTab</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[])</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">[</span><span class="n">newCap</span><span class="o">];</span>
        <span class="c1">//修改hashMap的table为新建的newTab</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">newTab</span><span class="o">;</span>
        <span class="c1">//如果旧table不为空，将旧table中的元素复制到新的table中</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">oldTab</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//遍历旧哈希表的每个桶，将旧哈希表中的桶复制到新的哈希表中</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">oldCap</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
                <span class="c1">//如果旧桶不为null，使用e记录旧桶</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">oldTab</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">//将旧桶置为null</span>
                    <span class="n">oldTab</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                    <span class="c1">//如果旧桶中只有一个node</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                        <span class="c1">//将e也就是oldTab[j]放入newTab中e.hash &amp; (newCap - 1)的位置</span>
                        <span class="n">newTab</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">newCap</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                        <span class="c1">//如果旧桶中的结构为红黑树</span>
                    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">e</span> <span class="k">instanceof</span> <span class="nc">TreeNode</span><span class="o">)</span>
                        <span class="c1">//将树中的node分离</span>
                        <span class="o">((</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;)</span> <span class="n">e</span><span class="o">).</span><span class="na">split</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">newTab</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">oldCap</span><span class="o">);</span>
                    <span class="k">else</span> <span class="o">{</span>  <span class="c1">//如果旧桶中的结构为链表,链表重排，jdk1.8做的一系列优化</span>
                        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">loHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">loTail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">hiHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">hiTail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
                        <span class="c1">//遍历整个链表中的节点</span>
                        <span class="k">do</span> <span class="o">{</span>
                            <span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                            <span class="c1">// 原索引</span>
                            <span class="k">if</span> <span class="o">((</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="n">oldCap</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                                <span class="k">if</span> <span class="o">(</span><span class="n">loTail</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                                    <span class="n">loHead</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                                <span class="k">else</span>
                                    <span class="n">loTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                                <span class="n">loTail</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span><span class="c1">// 原索引+oldCap</span>
                                <span class="k">if</span> <span class="o">(</span><span class="n">hiTail</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                                    <span class="n">hiHead</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                                <span class="k">else</span>
                                    <span class="n">hiTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                                <span class="n">hiTail</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                            <span class="o">}</span>
                        <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
                        <span class="c1">// 原索引放到bucket里</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">loTail</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">loTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                            <span class="n">newTab</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">loHead</span><span class="o">;</span>
                        <span class="o">}</span>
                        <span class="c1">// 原索引+oldCap放到bucket里</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">hiTail</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">hiTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                            <span class="n">newTab</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">oldCap</span><span class="o">]</span> <span class="o">=</span> <span class="n">hiHead</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">newTab</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 将链表转化为红黑树
     */</span>
    <span class="kd">final</span> <span class="kt">void</span> <span class="nf">treeifyBin</span><span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hash</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">index</span><span class="o">;</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
        <span class="c1">//如果桶数组table为空，或者桶数组table的长度小于MIN_TREEIFY_CAPACITY，不符合转化为红黑树的条件</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">tab</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">&lt;</span> <span class="no">MIN_TREEIFY_CAPACITY</span><span class="o">)</span>
            <span class="c1">//扩容</span>
            <span class="n">resize</span><span class="o">();</span>
            <span class="c1">//如果符合转化为红黑树的条件，而且hash对应的桶不为null</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">index</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 红黑树的头、尾节点</span>
            <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">hd</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">tl</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="c1">//遍历链表</span>
            <span class="k">do</span> <span class="o">{</span>
                <span class="c1">//替换链表node为树node，建立双向链表</span>
                <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">replacementTreeNode</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
                <span class="c1">// 确定树头节点</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">tl</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">hd</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                <span class="k">else</span> <span class="o">{</span>
                    <span class="n">p</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">tl</span><span class="o">;</span>
                    <span class="n">tl</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">tl</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
            <span class="c1">//遍历链表插入每个节点到红黑树</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">hd</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span><span class="err">，</span>
                <span class="n">hd</span><span class="o">.</span><span class="na">treeify</span><span class="o">(</span><span class="n">tab</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 将参数map中的所有键值对映射插入到hashMap中，如果有碰撞，则覆盖value。
     *
     * @param m 参数map
     * @throws NullPointerException 如果map为null
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">putAll</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">putMapEntries</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 删除hashMap中key映射的node
     * remove方法的实现可以分为三个步骤：
     * 1.通过 hash(Object key)方法计算key的哈希值。
     * 2.通过 removeNode 方法实现功能。
     * 3.返回被删除的node的value。
     *
     * @param key 参数key
     * @return 如果没有映射到node，返回null，否则返回对应的value
     */</span>
    <span class="kd">public</span> <span class="no">V</span> <span class="nf">remove</span><span class="o">(</span><span class="nc">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
        <span class="c1">//根据key来删除node。removeNode方法的具体实现在下面</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">removeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span>
                <span class="kc">null</span> <span class="o">:</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Map.remove和相关方法的实现需要的方法
     * removeNode方法的步骤总结为:
     * 1.如果数组table为空或key映射到的桶为空，返回null。
     * 2.如果key映射到的桶上第一个node的就是要删除的node，记录下来。
     * 3.如果桶内不止一个node，且桶内的结构为红黑树，记录key映射到的node。
     * 4.桶内的结构不为红黑树，那么桶内的结构就肯定为链表，遍历链表，找到key映射到的node，记录下来。
     * 5.如果被记录下来的node不为null，删除node，size-1被删除。
     * 6.返回被删除的node。
     *
     * @param hash       key的哈希值
     * @param key        key的哈希值
     * @param value      如果 matchValue 为true，则value也作为确定被删除的node的条件之一，否则忽略
     * @param matchValue 如果为true，则value也作为确定被删除的node的条件之一
     * @param movable    如果为false，删除node时不会删除其他node
     * @return 返回被删除的node，如果没有node被删除，则返回null（针对红黑树的删除方法）
     */</span>
    <span class="kd">final</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">removeNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">value</span><span class="o">,</span>
                                <span class="kt">boolean</span> <span class="n">matchValue</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">movable</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">index</span><span class="o">;</span>
        <span class="c1">//如果数组table不为空且key映射到的桶不为空</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
                <span class="o">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">index</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">e</span><span class="o">;</span>
            <span class="no">K</span> <span class="n">k</span><span class="o">;</span>
            <span class="no">V</span> <span class="n">v</span><span class="o">;</span>
            <span class="c1">//如果桶上第一个node的就是要删除的node</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                    <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
                <span class="c1">//记录桶上第一个node</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span><span class="c1">//如果桶内不止一个node</span>
                <span class="c1">//如果桶内的结构为红黑树</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="k">instanceof</span> <span class="nc">TreeNode</span><span class="o">)</span>
                    <span class="c1">//记录key映射到的node</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="o">((</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;)</span> <span class="n">p</span><span class="o">).</span><span class="na">getTreeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
                <span class="k">else</span> <span class="o">{</span><span class="c1">//如果桶内的结构为链表</span>
                    <span class="k">do</span> <span class="o">{</span><span class="c1">//遍历链表，找到key映射到的node</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                                <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span>
                                        <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span> <span class="o">{</span>
                            <span class="c1">//记录key映射到的node</span>
                            <span class="n">node</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                            <span class="k">break</span><span class="o">;</span>
                        <span class="o">}</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                    <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">//如果得到的node不为null且(matchValue为false||node.value和参数value匹配)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(!</span><span class="n">matchValue</span> <span class="o">||</span> <span class="o">(</span><span class="n">v</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">==</span> <span class="n">value</span> <span class="o">||</span>
                    <span class="o">(</span><span class="n">value</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">value</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">v</span><span class="o">))))</span> <span class="o">{</span>
                <span class="c1">//如果桶内的结构为红黑树</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="k">instanceof</span> <span class="nc">TreeNode</span><span class="o">)</span>
                    <span class="c1">//使用红黑树的删除方法删除node</span>
                    <span class="o">((</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;)</span> <span class="n">node</span><span class="o">).</span><span class="na">removeTreeNode</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">tab</span><span class="o">,</span> <span class="n">movable</span><span class="o">);</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">p</span><span class="o">)</span><span class="c1">//如果桶的第一个node的就是要删除的node</span>
                    <span class="c1">//删除node</span>
                    <span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="k">else</span><span class="c1">//如果桶内的结构为链表，使用链表删除元素的方式删除node</span>
                    <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="o">++</span><span class="n">modCount</span><span class="o">;</span><span class="c1">//结构性修改次数+1</span>
                <span class="o">--</span><span class="n">size</span><span class="o">;</span><span class="c1">//哈希表大小-1</span>
                <span class="n">afterNodeRemoval</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
                <span class="k">return</span> <span class="n">node</span><span class="o">;</span><span class="c1">//返回被删除的node</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span><span class="c1">//如果数组table为空或key映射到的桶为空，返回null。</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 删除map中所有的键值对
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">clear</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span>
        <span class="n">modCount</span><span class="o">++;</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span>
                <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 如果hashMap中的键值对有一对或多对的value为参数value，返回true
     *
     * @param value 参数value
     * @return 如果hashMap中的键值对有一对或多对的value为参数value，返回true
     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">containsValue</span><span class="o">(</span><span class="nc">Object</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span>
        <span class="no">V</span> <span class="n">v</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//遍历数组table</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">//遍历桶中的node</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">((</span><span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">==</span> <span class="n">value</span> <span class="o">||</span>
                            <span class="o">(</span><span class="n">value</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">value</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">v</span><span class="o">)))</span>
                        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 返回hashMap中所有key的视图。
     * 改变hashMap会影响到set，反之亦然。
     * 如果当迭代器迭代set时，hashMap被修改(除非是迭代器自己的remove()方法)，迭代器的结果是不确定的。
     * set支持元素的删除，通过Iterator.remove、Set.remove、removeAll、retainAll、clear操作删除hashMap中对应的键值对。
     * 不支持add和addAll方法。
     *
     * @return 返回hashMap中所有key的set视图
     */</span>
    <span class="kd">public</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="nf">keySet</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="n">ks</span> <span class="o">=</span> <span class="n">keySet</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ks</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ks</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">KeySet</span><span class="o">();</span>
            <span class="n">keySet</span> <span class="o">=</span> <span class="n">ks</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ks</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 内部类KeySet
     */</span>
    <span class="kd">final</span> <span class="kd">class</span> <span class="nc">KeySet</span> <span class="kd">extends</span> <span class="nc">AbstractSet</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">size</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">clear</span><span class="o">()</span> <span class="o">{</span>
            <span class="nc">HashMap</span><span class="o">.</span><span class="na">this</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">KeyIterator</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">containsKey</span><span class="o">(</span><span class="n">o</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span><span class="nc">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">removeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="nc">Spliterator</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="nf">spliterator</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nc">KeySpliterator</span><span class="o">&lt;&gt;(</span><span class="nc">HashMap</span><span class="o">.</span><span class="na">this</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Java 8</span>
        <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">forEach</span><span class="o">(</span><span class="nc">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">K</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">action</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">mc</span> <span class="o">=</span> <span class="n">modCount</span><span class="o">;</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span>
                        <span class="n">action</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">modCount</span> <span class="o">!=</span> <span class="n">mc</span><span class="o">)</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">ConcurrentModificationException</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 返回hashMap中所有value的collection视图
     * 改变hashMap会改变collection，反之亦然。
     * 如果当迭代器迭代collection时，hashMap被修改（除非是迭代器自己的remove()方法），迭代器的结果是不确定的。
     * collection支持元素的删除，通过Iterator.remove、Collection.remove、removeAll、retainAll、clear操作删除hashMap中对应的键值对。
     * 不支持add和addAll方法。
     *
     * @return 返回hashMap中所有key的collection视图
     */</span>
    <span class="kd">public</span> <span class="nc">Collection</span><span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">values</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Collection</span><span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">vs</span> <span class="o">=</span> <span class="n">values</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">vs</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">vs</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Values</span><span class="o">();</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">vs</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">vs</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 内部类Values
     */</span>
    <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Values</span> <span class="kd">extends</span> <span class="nc">AbstractCollection</span><span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">size</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">clear</span><span class="o">()</span> <span class="o">{</span>
            <span class="nc">HashMap</span><span class="o">.</span><span class="na">this</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">ValueIterator</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">containsValue</span><span class="o">(</span><span class="n">o</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="nc">Spliterator</span><span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">spliterator</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nc">ValueSpliterator</span><span class="o">&lt;&gt;(</span><span class="nc">HashMap</span><span class="o">.</span><span class="na">this</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">forEach</span><span class="o">(</span><span class="nc">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">action</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">mc</span> <span class="o">=</span> <span class="n">modCount</span><span class="o">;</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span>
                        <span class="n">action</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">modCount</span> <span class="o">!=</span> <span class="n">mc</span><span class="o">)</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">ConcurrentModificationException</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 返回hashMap中所有键值对的set视图
     * 改变hashMap会影响到set，反之亦然。
     * 如果当迭代器迭代set时，hashMap被修改(除非是迭代器自己的remove()方法)，迭代器的结果是不确定的。
     * set支持元素的删除，通过Iterator.remove、Set.remove、removeAll、retainAll、clear操作删除hashMap中对应的键值对。
     * 不支持add和addAll方法。
     *
     * @return 返回hashMap中所有键值对的set视图
     */</span>
    <span class="kd">public</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;&gt;</span> <span class="nf">entrySet</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">es</span><span class="o">;</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">es</span> <span class="o">=</span> <span class="n">entrySet</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="o">(</span><span class="n">entrySet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">EntrySet</span><span class="o">())</span> <span class="o">:</span> <span class="n">es</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 内部类EntrySet
     */</span>
    <span class="kd">final</span> <span class="kd">class</span> <span class="nc">EntrySet</span> <span class="kd">extends</span> <span class="nc">AbstractSet</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">size</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">clear</span><span class="o">()</span> <span class="o">{</span>
            <span class="nc">HashMap</span><span class="o">.</span><span class="na">this</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;&gt;</span> <span class="nf">iterator</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">EntryIterator</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">))</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;?,</span> <span class="o">?&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;?,</span> <span class="o">?&gt;)</span> <span class="n">o</span><span class="o">;</span>
            <span class="nc">Object</span> <span class="n">key</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">candidate</span> <span class="o">=</span> <span class="n">getNode</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">candidate</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">candidate</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;?,</span> <span class="o">?&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;?,</span> <span class="o">?&gt;)</span> <span class="n">o</span><span class="o">;</span>
                <span class="nc">Object</span> <span class="n">key</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
                <span class="nc">Object</span> <span class="n">value</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
                <span class="k">return</span> <span class="nf">removeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="nc">Spliterator</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;&gt;</span> <span class="nf">spliterator</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nc">EntrySpliterator</span><span class="o">&lt;&gt;(</span><span class="nc">HashMap</span><span class="o">.</span><span class="na">this</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">forEach</span><span class="o">(</span><span class="nc">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">action</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">mc</span> <span class="o">=</span> <span class="n">modCount</span><span class="o">;</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span>
                        <span class="n">action</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">modCount</span> <span class="o">!=</span> <span class="n">mc</span><span class="o">)</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">ConcurrentModificationException</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// JDK8重写的方法</span>

    <span class="cm">/**
     * 通过key映射到对应node，如果没映射到则返回默认值defaultValue
     *
     * @param key
     * @param defaultValue
     * @return key映射到对应的node，如果没映射到则返回默认值defaultValue
     */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="no">V</span> <span class="nf">getOrDefault</span><span class="o">(</span><span class="nc">Object</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">defaultValue</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">getNode</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">defaultValue</span> <span class="o">:</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 在hashMap中插入参数key和value组成的键值对，如果key在hashMap中已经存在，不替换value
     *
     * @param key
     * @param value
     * @return 如果key在hashMap中不存在，返回旧value
     */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="no">V</span> <span class="nf">putIfAbsent</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">putVal</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 删除hashMap中key为参数key，value为参数value的键值对。如果桶中结构为树，则级联删除
     *
     * @param key
     * @param value
     * @return 删除成功，返回true
     */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span><span class="nc">Object</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">removeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 使用newValue替换key和oldValue映射到的键值对中的value
     *
     * @param key
     * @param oldValue
     * @param newValue
     * @return 替换成功，返回true
     */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">replace</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">oldValue</span><span class="o">,</span> <span class="no">V</span> <span class="n">newValue</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
        <span class="no">V</span> <span class="n">v</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">getNode</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">))</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
                <span class="o">((</span><span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">==</span> <span class="n">oldValue</span> <span class="o">||</span> <span class="o">(</span><span class="n">v</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">v</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">oldValue</span><span class="o">))))</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">newValue</span><span class="o">;</span>
            <span class="n">afterNodeAccess</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 使用参数value替换key映射到的键值对中的value
     *
     * @param key
     * @param value
     * @return 替换成功，返回true
     */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="no">V</span> <span class="nf">replace</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">getNode</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">))</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="no">V</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
            <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
            <span class="n">afterNodeAccess</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    
    <span class="cm">/**
     * Map接口的实现类如HashMap,ConcurrentHashMap,HashTable等继承了此方法
     * 通过此方法可以构建JAVA本地缓存，降低程序的计算量，程序的复杂度，使代码简洁，易懂。
     * 
     * 此方法首先判断缓存MAP中是否存在指定key的值，如果不存在，会自动调用mappingFunction(key)计算key的value
     * 然后将key = value放入到缓存Map,java8会使用thread-safe的方式从cache中存取记录。
	 * 如果mappingFunction(key)返回的值为null或抛出异常，则不会有记录存入map
     */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="no">V</span> <span class="nf">computeIfAbsent</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span>
                             <span class="nc">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">mappingFunction</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">mappingFunction</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">first</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">binCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">old</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="o">||</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span>
                <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">resize</span><span class="o">()).</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">first</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">first</span> <span class="k">instanceof</span> <span class="nc">TreeNode</span><span class="o">)</span>
                <span class="n">old</span> <span class="o">=</span> <span class="o">(</span><span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;)</span> <span class="n">first</span><span class="o">).</span><span class="na">getTreeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
                <span class="no">K</span> <span class="n">k</span><span class="o">;</span>
                <span class="k">do</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                            <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span> <span class="o">{</span>
                        <span class="n">old</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="o">++</span><span class="n">binCount</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="no">V</span> <span class="n">oldValue</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">old</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">oldValue</span> <span class="o">=</span> <span class="n">old</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">afterNodeAccess</span><span class="o">(</span><span class="n">old</span><span class="o">);</span>
                <span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="no">V</span> <span class="n">v</span> <span class="o">=</span> <span class="n">mappingFunction</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">old</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">old</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
            <span class="n">afterNodeAccess</span><span class="o">(</span><span class="n">old</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">v</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">t</span><span class="o">.</span><span class="na">putTreeVal</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">first</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">binCount</span> <span class="o">&gt;=</span> <span class="no">TREEIFY_THRESHOLD</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
                <span class="n">treeifyBin</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
        <span class="o">++</span><span class="n">size</span><span class="o">;</span>
        <span class="n">afterNodeInsertion</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">v</span><span class="o">;</span>
    <span class="o">}</span>

    
    <span class="cm">/**
     * 已经存在值的情况下,才计算新值。
     */</span>
    <span class="kd">public</span> <span class="no">V</span> <span class="nf">computeIfPresent</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span>
                              <span class="nc">BiFunction</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">super</span> <span class="no">V</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">remappingFunction</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">remappingFunction</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
        <span class="no">V</span> <span class="n">oldValue</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">getNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">))</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
                <span class="o">(</span><span class="n">oldValue</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="no">V</span> <span class="n">v</span> <span class="o">=</span> <span class="n">remappingFunction</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">oldValue</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
                <span class="n">afterNodeAccess</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
                <span class="k">return</span> <span class="n">v</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span>
                <span class="n">removeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="no">V</span> <span class="nf">compute</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span>
                     <span class="nc">BiFunction</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">super</span> <span class="no">V</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">remappingFunction</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">remappingFunction</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">first</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">binCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">old</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="o">||</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span>
                <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">resize</span><span class="o">()).</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">first</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">first</span> <span class="k">instanceof</span> <span class="nc">TreeNode</span><span class="o">)</span>
                <span class="n">old</span> <span class="o">=</span> <span class="o">(</span><span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;)</span> <span class="n">first</span><span class="o">).</span><span class="na">getTreeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
                <span class="no">K</span> <span class="n">k</span><span class="o">;</span>
                <span class="k">do</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                            <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span> <span class="o">{</span>
                        <span class="n">old</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="o">++</span><span class="n">binCount</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="no">V</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="o">(</span><span class="n">old</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">old</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
        <span class="no">V</span> <span class="n">v</span> <span class="o">=</span> <span class="n">remappingFunction</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">oldValue</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">old</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">old</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
                <span class="n">afterNodeAccess</span><span class="o">(</span><span class="n">old</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span>
                <span class="n">removeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">t</span><span class="o">.</span><span class="na">putTreeVal</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">first</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">binCount</span> <span class="o">&gt;=</span> <span class="no">TREEIFY_THRESHOLD</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
                    <span class="n">treeifyBin</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
            <span class="o">++</span><span class="n">size</span><span class="o">;</span>
            <span class="n">afterNodeInsertion</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">v</span><span class="o">;</span>
    <span class="o">}</span>

    
    <span class="cm">/**
     * Java 8
     * 合并
     * map.merge("foo", "boo", (oldVal, newVal) -&gt; newVal + " was " + oldVal);  
	 * System.out.println(map.get("foo"));   // boo was foo  
     */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="no">V</span> <span class="nf">merge</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">,</span>
                   <span class="nc">BiFunction</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">V</span><span class="o">,</span> <span class="o">?</span> <span class="kd">super</span> <span class="no">V</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">remappingFunction</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">remappingFunction</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">first</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">binCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">old</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="o">||</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span>
                <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">resize</span><span class="o">()).</span><span class="na">length</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">first</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">first</span> <span class="k">instanceof</span> <span class="nc">TreeNode</span><span class="o">)</span>
                <span class="n">old</span> <span class="o">=</span> <span class="o">(</span><span class="n">t</span> <span class="o">=</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;)</span> <span class="n">first</span><span class="o">).</span><span class="na">getTreeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
                <span class="no">K</span> <span class="n">k</span><span class="o">;</span>
                <span class="k">do</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                            <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span> <span class="o">{</span>
                        <span class="n">old</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="o">++</span><span class="n">binCount</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">old</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="no">V</span> <span class="n">v</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">old</span><span class="o">.</span><span class="na">value</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">remappingFunction</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">old</span><span class="o">.</span><span class="na">value</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
            <span class="k">else</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">old</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
                <span class="n">afterNodeAccess</span><span class="o">(</span><span class="n">old</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span>
                <span class="n">removeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">v</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">t</span><span class="o">.</span><span class="na">putTreeVal</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">first</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">binCount</span> <span class="o">&gt;=</span> <span class="no">TREEIFY_THRESHOLD</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
                    <span class="n">treeifyBin</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
            <span class="o">++</span><span class="n">size</span><span class="o">;</span>
            <span class="n">afterNodeInsertion</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">forEach</span><span class="o">(</span><span class="nc">BiConsumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">super</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">action</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mc</span> <span class="o">=</span> <span class="n">modCount</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span>
                    <span class="n">action</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">modCount</span> <span class="o">!=</span> <span class="n">mc</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ConcurrentModificationException</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">replaceAll</span><span class="o">(</span><span class="nc">BiFunction</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">K</span><span class="o">,</span> <span class="o">?</span> <span class="kd">super</span> <span class="no">V</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">function</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">function</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">mc</span> <span class="o">=</span> <span class="n">modCount</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">modCount</span> <span class="o">!=</span> <span class="n">mc</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ConcurrentModificationException</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/* ------------------------------------------------------------ */</span>
    <span class="c1">// 克隆和序列化</span>

    <span class="cm">/**
     * 浅拷贝。
     * clone方法虽然生成了新的HashMap对象，新的HashMap中的table数组虽然也是新生成的，但是数组中的元素还是引用以前的HashMap中的元素。
     * 这就导致在对HashMap中的元素进行修改的时候，即对数组中元素进行修改，会导致原对象和clone对象都发生改变，但进行新增或删除就不会影响对方
     * 因为这相当于是对数组做出的改变，clone对象新生成了一个数组。
     *
     * @return hashMap的浅拷贝
     */</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">clone</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">result</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;)</span> <span class="kd">super</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">CloneNotSupportedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// this shouldn't happen, since we are Cloneable</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">InternalError</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">result</span><span class="o">.</span><span class="na">reinitialize</span><span class="o">();</span>
        <span class="n">result</span><span class="o">.</span><span class="na">putMapEntries</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// These methods are also used when serializing HashSets</span>
    <span class="kd">final</span> <span class="kt">float</span> <span class="nf">loadFactor</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">loadFactor</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">final</span> <span class="kt">int</span> <span class="nf">capacity</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">table</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">table</span><span class="o">.</span><span class="na">length</span> <span class="o">:</span>
                <span class="o">(</span><span class="n">threshold</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">threshold</span> <span class="o">:</span>
                        <span class="no">DEFAULT_INITIAL_CAPACITY</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 序列化hashMap到ObjectOutputStream中
     * 将hashMap的总容量capacity、实际容量size、键值对映射写入到ObjectOutputStream中。键值对映射序列化时是无序的。
     *
     */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">writeObject</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">ObjectOutputStream</span> <span class="n">s</span><span class="o">)</span>
            <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">buckets</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">();</span>
        <span class="c1">// Write out the threshold, loadfactor, and any hidden stuff</span>
        <span class="n">s</span><span class="o">.</span><span class="na">defaultWriteObject</span><span class="o">();</span>
        <span class="c1">//写入总容量</span>
        <span class="n">s</span><span class="o">.</span><span class="na">writeInt</span><span class="o">(</span><span class="n">buckets</span><span class="o">);</span>
        <span class="c1">//写入实际容量</span>
        <span class="n">s</span><span class="o">.</span><span class="na">writeInt</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
        <span class="c1">//写入键值对</span>
        <span class="n">internalWriteEntries</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 到ObjectOutputStream中读取hashMap
     * 将hashMap的总容量capacity、实际容量size、键值对映射读取出来
     */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">readObject</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">ObjectInputStream</span> <span class="n">s</span><span class="o">)</span>
            <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">ClassNotFoundException</span> <span class="o">{</span>
        <span class="c1">// 将hashMap的总容量capacity、实际容量size、键值对映射读取出来</span>
        <span class="n">s</span><span class="o">.</span><span class="na">defaultReadObject</span><span class="o">();</span>
        <span class="c1">//重置hashMap</span>
        <span class="n">reinitialize</span><span class="o">();</span>
        <span class="c1">//如果加载因子不合法，抛出异常</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">loadFactor</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nc">Float</span><span class="o">.</span><span class="na">isNaN</span><span class="o">(</span><span class="n">loadFactor</span><span class="o">))</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidObjectException</span><span class="o">(</span><span class="s">"Illegal load factor: "</span> <span class="o">+</span>
                    <span class="n">loadFactor</span><span class="o">);</span>
        <span class="n">s</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>                <span class="c1">//读出桶的数量，忽略</span>
        <span class="kt">int</span> <span class="n">mappings</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span> <span class="c1">//读出实际容量size</span>
        <span class="c1">//如果读出的实际容量size小于0，抛出异常</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">mappings</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidObjectException</span><span class="o">(</span><span class="s">"Illegal mappings count: "</span> <span class="o">+</span>
                    <span class="n">mappings</span><span class="o">);</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">mappings</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// (if zero, use defaults)</span>
            <span class="c1">// Size the table using given load factor only if within</span>
            <span class="c1">// range of 0.25...4.0</span>
            <span class="c1">//调整hashMap大小</span>
            <span class="kt">float</span> <span class="n">lf</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mf">0.25f</span><span class="o">,</span> <span class="n">loadFactor</span><span class="o">),</span> <span class="mf">4.0f</span><span class="o">);</span>            <span class="c1">// 加载因子</span>
            <span class="kt">float</span> <span class="n">fc</span> <span class="o">=</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">mappings</span> <span class="o">/</span> <span class="n">lf</span> <span class="o">+</span> <span class="mf">1.0f</span><span class="o">;</span>         <span class="c1">//初步得到的总容量，后续还会处理</span>
            <span class="c1">//处理初步得到的容量，确认最终的总容量</span>
            <span class="kt">int</span> <span class="n">cap</span> <span class="o">=</span> <span class="o">((</span><span class="n">fc</span> <span class="o">&lt;</span> <span class="no">DEFAULT_INITIAL_CAPACITY</span><span class="o">)</span> <span class="o">?</span>
                    <span class="no">DEFAULT_INITIAL_CAPACITY</span> <span class="o">:</span>
                    <span class="o">(</span><span class="n">fc</span> <span class="o">&gt;=</span> <span class="no">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">?</span>
                            <span class="no">MAXIMUM_CAPACITY</span> <span class="o">:</span>
                            <span class="n">tableSizeFor</span><span class="o">((</span><span class="kt">int</span><span class="o">)</span> <span class="n">fc</span><span class="o">));</span>
            <span class="c1">//计算临界值，得到初步的临界值</span>
            <span class="kt">float</span> <span class="n">ft</span> <span class="o">=</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="n">cap</span> <span class="o">*</span> <span class="n">lf</span><span class="o">;</span>
            <span class="c1">//得到最终的临界值</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="o">((</span><span class="n">cap</span> <span class="o">&lt;</span> <span class="no">MAXIMUM_CAPACITY</span> <span class="o">&amp;&amp;</span> <span class="n">ft</span> <span class="o">&lt;</span> <span class="no">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">?</span>
                    <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">ft</span> <span class="o">:</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>

            <span class="c1">// Check Map.Entry[].class since it's the nearest public type to</span>
            <span class="c1">// what we're actually creating.</span>
            <span class="nc">SharedSecrets</span><span class="o">.</span><span class="na">getJavaOISAccess</span><span class="o">().</span><span class="na">checkArray</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">[].</span><span class="na">class</span><span class="o">,</span> <span class="n">cap</span><span class="o">);</span>
            <span class="c1">//新建桶数组table</span>
            <span class="nd">@SuppressWarnings</span><span class="o">({</span><span class="s">"rawtypes"</span><span class="o">,</span> <span class="s">"unchecked"</span><span class="o">})</span>
            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[])</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">[</span><span class="n">cap</span><span class="o">];</span>
            <span class="n">table</span> <span class="o">=</span> <span class="n">tab</span><span class="o">;</span>

            <span class="c1">// 读出key和value，并组成键值对插入hashMap中</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mappings</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
                <span class="no">K</span> <span class="n">key</span> <span class="o">=</span> <span class="o">(</span><span class="no">K</span><span class="o">)</span> <span class="n">s</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
                <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
                <span class="no">V</span> <span class="n">value</span> <span class="o">=</span> <span class="o">(</span><span class="no">V</span><span class="o">)</span> <span class="n">s</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
                <span class="n">putVal</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/* ------------------------------------------------------------ */</span>
    <span class="c1">// iterators</span>

    <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">HashIterator</span> <span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>        <span class="c1">// next entry to return</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">current</span><span class="o">;</span>     <span class="c1">// current entry</span>
        <span class="kt">int</span> <span class="n">expectedModCount</span><span class="o">;</span>  <span class="c1">// for fast-fail</span>
        <span class="kt">int</span> <span class="n">index</span><span class="o">;</span>             <span class="c1">// current slot</span>

        <span class="nc">HashIterator</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">expectedModCount</span> <span class="o">=</span> <span class="n">modCount</span><span class="o">;</span>
            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">t</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// advance to first entry</span>
                <span class="k">do</span> <span class="o">{</span>
                <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">next</span> <span class="o">=</span> <span class="n">t</span><span class="o">[</span><span class="n">index</span><span class="o">++])</span> <span class="o">==</span> <span class="kc">null</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">final</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">nextNode</span><span class="o">()</span> <span class="o">{</span>
            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">t</span><span class="o">;</span>
            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">modCount</span> <span class="o">!=</span> <span class="n">expectedModCount</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ConcurrentModificationException</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoSuchElementException</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">next</span> <span class="o">=</span> <span class="o">(</span><span class="n">current</span> <span class="o">=</span> <span class="n">e</span><span class="o">).</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">t</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">do</span> <span class="o">{</span>
                <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">next</span> <span class="o">=</span> <span class="n">t</span><span class="o">[</span><span class="n">index</span><span class="o">++])</span> <span class="o">==</span> <span class="kc">null</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">e</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">()</span> <span class="o">{</span>
            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">current</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">modCount</span> <span class="o">!=</span> <span class="n">expectedModCount</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ConcurrentModificationException</span><span class="o">();</span>
            <span class="n">current</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="no">K</span> <span class="n">key</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">;</span>
            <span class="n">removeNode</span><span class="o">(</span><span class="n">hash</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="n">key</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
            <span class="n">expectedModCount</span> <span class="o">=</span> <span class="n">modCount</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">final</span> <span class="kd">class</span> <span class="nc">KeyIterator</span> <span class="kd">extends</span> <span class="nc">HashIterator</span>
            <span class="kd">implements</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kd">final</span> <span class="no">K</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">nextNode</span><span class="o">().</span><span class="na">key</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">final</span> <span class="kd">class</span> <span class="nc">ValueIterator</span> <span class="kd">extends</span> <span class="nc">HashIterator</span>
            <span class="kd">implements</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kd">final</span> <span class="no">V</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">nextNode</span><span class="o">().</span><span class="na">value</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">final</span> <span class="kd">class</span> <span class="nc">EntryIterator</span> <span class="kd">extends</span> <span class="nc">HashIterator</span>
            <span class="kd">implements</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kd">final</span> <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">nextNode</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/* ---------------------------Java 8 --------------------------------- */</span>
    <span class="c1">// spliterators</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">HashMapSpliterator</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">;</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">current</span><span class="o">;</span>          <span class="c1">//记录当前的节点</span>
        <span class="kt">int</span> <span class="n">index</span><span class="o">;</span>                  <span class="c1">//当前节点的下标</span>
        <span class="kt">int</span> <span class="n">fence</span><span class="o">;</span>                  <span class="c1">//堆大小</span>
        <span class="kt">int</span> <span class="n">est</span><span class="o">;</span>                    <span class="c1">//估计大小</span>
        <span class="kt">int</span> <span class="n">expectedModCount</span><span class="o">;</span>       <span class="c1">// for comodification checks</span>

        <span class="nc">HashMapSpliterator</span><span class="o">(</span><span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="o">,</span>
                           <span class="kt">int</span> <span class="n">fence</span><span class="o">,</span> <span class="kt">int</span> <span class="n">est</span><span class="o">,</span>
                           <span class="kt">int</span> <span class="n">expectedModCount</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">map</span> <span class="o">=</span> <span class="n">m</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">index</span> <span class="o">=</span> <span class="n">origin</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">fence</span> <span class="o">=</span> <span class="n">fence</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">est</span> <span class="o">=</span> <span class="n">est</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">expectedModCount</span> <span class="o">=</span> <span class="n">expectedModCount</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getFence</span><span class="o">()</span> <span class="o">{</span> <span class="c1">// initialize fence and size on first use</span>
            <span class="kt">int</span> <span class="n">hi</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">hi</span> <span class="o">=</span> <span class="n">fence</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">map</span><span class="o">;</span>
                <span class="n">est</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">size</span><span class="o">;</span>
                <span class="n">expectedModCount</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">modCount</span><span class="o">;</span>
                <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">table</span><span class="o">;</span>
                <span class="n">hi</span> <span class="o">=</span> <span class="n">fence</span> <span class="o">=</span> <span class="o">(</span><span class="n">tab</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">hi</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">final</span> <span class="kt">long</span> <span class="nf">estimateSize</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">getFence</span><span class="o">();</span> <span class="c1">// force init</span>
            <span class="k">return</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="n">est</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">KeySpliterator</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span>
            <span class="kd">extends</span> <span class="nc">HashMapSpliterator</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span>
            <span class="kd">implements</span> <span class="nc">Spliterator</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="nc">KeySpliterator</span><span class="o">(</span><span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fence</span><span class="o">,</span> <span class="kt">int</span> <span class="n">est</span><span class="o">,</span>
                       <span class="kt">int</span> <span class="n">expectedModCount</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">origin</span><span class="o">,</span> <span class="n">fence</span><span class="o">,</span> <span class="n">est</span><span class="o">,</span> <span class="n">expectedModCount</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="nc">KeySpliterator</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">trySplit</span><span class="o">()</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">getFence</span><span class="o">(),</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">index</span><span class="o">,</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="o">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">return</span> <span class="o">(</span><span class="n">lo</span> <span class="o">&gt;=</span> <span class="n">mid</span> <span class="o">||</span> <span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span>
                    <span class="k">new</span> <span class="nc">KeySpliterator</span><span class="o">&lt;&gt;(</span><span class="n">map</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">mid</span><span class="o">,</span> <span class="n">est</span> <span class="o">&gt;&gt;&gt;=</span> <span class="mi">1</span><span class="o">,</span>
                            <span class="n">expectedModCount</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">forEachRemaining</span><span class="o">(</span><span class="nc">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">K</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="o">,</span> <span class="n">mc</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">action</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
            <span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">map</span><span class="o">;</span>
            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">table</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">hi</span> <span class="o">=</span> <span class="n">fence</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">mc</span> <span class="o">=</span> <span class="n">expectedModCount</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">modCount</span><span class="o">;</span>
                <span class="n">hi</span> <span class="o">=</span> <span class="n">fence</span> <span class="o">=</span> <span class="o">(</span><span class="n">tab</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span>
                <span class="n">mc</span> <span class="o">=</span> <span class="n">expectedModCount</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tab</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;=</span> <span class="n">hi</span> <span class="o">&amp;&amp;</span>
                    <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">index</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="o">(</span><span class="n">index</span> <span class="o">=</span> <span class="n">hi</span><span class="o">)</span> <span class="o">||</span> <span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
                <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">current</span><span class="o">;</span>
                <span class="n">current</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">do</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
                    <span class="k">else</span> <span class="o">{</span>
                        <span class="n">action</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">modCount</span> <span class="o">!=</span> <span class="n">mc</span><span class="o">)</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">ConcurrentModificationException</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">tryAdvance</span><span class="o">(</span><span class="nc">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">K</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">hi</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">action</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">table</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tab</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;=</span> <span class="o">(</span><span class="n">hi</span> <span class="o">=</span> <span class="n">getFence</span><span class="o">())</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                        <span class="n">current</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">++];</span>
                    <span class="k">else</span> <span class="o">{</span>
                        <span class="no">K</span> <span class="n">k</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">key</span><span class="o">;</span>
                        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                        <span class="n">action</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">k</span><span class="o">);</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">modCount</span> <span class="o">!=</span> <span class="n">expectedModCount</span><span class="o">)</span>
                            <span class="k">throw</span> <span class="k">new</span> <span class="nf">ConcurrentModificationException</span><span class="o">();</span>
                        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">characteristics</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">(</span><span class="n">fence</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">est</span> <span class="o">==</span> <span class="n">map</span><span class="o">.</span><span class="na">size</span> <span class="o">?</span> <span class="nc">Spliterator</span><span class="o">.</span><span class="na">SIZED</span> <span class="o">:</span> <span class="mi">0</span><span class="o">)</span> <span class="o">|</span>
                    <span class="nc">Spliterator</span><span class="o">.</span><span class="na">DISTINCT</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">ValueSpliterator</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span>
            <span class="kd">extends</span> <span class="nc">HashMapSpliterator</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span>
            <span class="kd">implements</span> <span class="nc">Spliterator</span><span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="nc">ValueSpliterator</span><span class="o">(</span><span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fence</span><span class="o">,</span> <span class="kt">int</span> <span class="n">est</span><span class="o">,</span>
                         <span class="kt">int</span> <span class="n">expectedModCount</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">origin</span><span class="o">,</span> <span class="n">fence</span><span class="o">,</span> <span class="n">est</span><span class="o">,</span> <span class="n">expectedModCount</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="nc">ValueSpliterator</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">trySplit</span><span class="o">()</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">getFence</span><span class="o">(),</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">index</span><span class="o">,</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="o">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">return</span> <span class="o">(</span><span class="n">lo</span> <span class="o">&gt;=</span> <span class="n">mid</span> <span class="o">||</span> <span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span>
                    <span class="k">new</span> <span class="nc">ValueSpliterator</span><span class="o">&lt;&gt;(</span><span class="n">map</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">mid</span><span class="o">,</span> <span class="n">est</span> <span class="o">&gt;&gt;&gt;=</span> <span class="mi">1</span><span class="o">,</span>
                            <span class="n">expectedModCount</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">forEachRemaining</span><span class="o">(</span><span class="nc">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="o">,</span> <span class="n">mc</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">action</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
            <span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">map</span><span class="o">;</span>
            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">table</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">hi</span> <span class="o">=</span> <span class="n">fence</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">mc</span> <span class="o">=</span> <span class="n">expectedModCount</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">modCount</span><span class="o">;</span>
                <span class="n">hi</span> <span class="o">=</span> <span class="n">fence</span> <span class="o">=</span> <span class="o">(</span><span class="n">tab</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span>
                <span class="n">mc</span> <span class="o">=</span> <span class="n">expectedModCount</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tab</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;=</span> <span class="n">hi</span> <span class="o">&amp;&amp;</span>
                    <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">index</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="o">(</span><span class="n">index</span> <span class="o">=</span> <span class="n">hi</span><span class="o">)</span> <span class="o">||</span> <span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
                <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">current</span><span class="o">;</span>
                <span class="n">current</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">do</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
                    <span class="k">else</span> <span class="o">{</span>
                        <span class="n">action</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">modCount</span> <span class="o">!=</span> <span class="n">mc</span><span class="o">)</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">ConcurrentModificationException</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">tryAdvance</span><span class="o">(</span><span class="nc">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">hi</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">action</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">table</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tab</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;=</span> <span class="o">(</span><span class="n">hi</span> <span class="o">=</span> <span class="n">getFence</span><span class="o">())</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                        <span class="n">current</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">++];</span>
                    <span class="k">else</span> <span class="o">{</span>
                        <span class="no">V</span> <span class="n">v</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
                        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                        <span class="n">action</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">modCount</span> <span class="o">!=</span> <span class="n">expectedModCount</span><span class="o">)</span>
                            <span class="k">throw</span> <span class="k">new</span> <span class="nf">ConcurrentModificationException</span><span class="o">();</span>
                        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">characteristics</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">(</span><span class="n">fence</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">est</span> <span class="o">==</span> <span class="n">map</span><span class="o">.</span><span class="na">size</span> <span class="o">?</span> <span class="nc">Spliterator</span><span class="o">.</span><span class="na">SIZED</span> <span class="o">:</span> <span class="mi">0</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">EntrySpliterator</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span>
            <span class="kd">extends</span> <span class="nc">HashMapSpliterator</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span>
            <span class="kd">implements</span> <span class="nc">Spliterator</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
        <span class="nc">EntrySpliterator</span><span class="o">(</span><span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fence</span><span class="o">,</span> <span class="kt">int</span> <span class="n">est</span><span class="o">,</span>
                         <span class="kt">int</span> <span class="n">expectedModCount</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">origin</span><span class="o">,</span> <span class="n">fence</span><span class="o">,</span> <span class="n">est</span><span class="o">,</span> <span class="n">expectedModCount</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="nc">EntrySpliterator</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">trySplit</span><span class="o">()</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">getFence</span><span class="o">(),</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">index</span><span class="o">,</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="o">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">return</span> <span class="o">(</span><span class="n">lo</span> <span class="o">&gt;=</span> <span class="n">mid</span> <span class="o">||</span> <span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span>
                    <span class="k">new</span> <span class="nc">EntrySpliterator</span><span class="o">&lt;&gt;(</span><span class="n">map</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">mid</span><span class="o">,</span> <span class="n">est</span> <span class="o">&gt;&gt;&gt;=</span> <span class="mi">1</span><span class="o">,</span>
                            <span class="n">expectedModCount</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">forEachRemaining</span><span class="o">(</span><span class="nc">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="o">,</span> <span class="n">mc</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">action</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
            <span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">map</span><span class="o">;</span>
            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">table</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">hi</span> <span class="o">=</span> <span class="n">fence</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">mc</span> <span class="o">=</span> <span class="n">expectedModCount</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">modCount</span><span class="o">;</span>
                <span class="n">hi</span> <span class="o">=</span> <span class="n">fence</span> <span class="o">=</span> <span class="o">(</span><span class="n">tab</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span>
                <span class="n">mc</span> <span class="o">=</span> <span class="n">expectedModCount</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tab</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;=</span> <span class="n">hi</span> <span class="o">&amp;&amp;</span>
                    <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">index</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="o">(</span><span class="n">index</span> <span class="o">=</span> <span class="n">hi</span><span class="o">)</span> <span class="o">||</span> <span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
                <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">current</span><span class="o">;</span>
                <span class="n">current</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">do</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">++];</span>
                    <span class="k">else</span> <span class="o">{</span>
                        <span class="n">action</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">modCount</span> <span class="o">!=</span> <span class="n">mc</span><span class="o">)</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">ConcurrentModificationException</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">tryAdvance</span><span class="o">(</span><span class="nc">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">hi</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">action</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">table</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tab</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;=</span> <span class="o">(</span><span class="n">hi</span> <span class="o">=</span> <span class="n">getFence</span><span class="o">())</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                        <span class="n">current</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">++];</span>
                    <span class="k">else</span> <span class="o">{</span>
                        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">current</span><span class="o">;</span>
                        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                        <span class="n">action</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">modCount</span> <span class="o">!=</span> <span class="n">expectedModCount</span><span class="o">)</span>
                            <span class="k">throw</span> <span class="k">new</span> <span class="nf">ConcurrentModificationException</span><span class="o">();</span>
                        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">characteristics</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">(</span><span class="n">fence</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">est</span> <span class="o">==</span> <span class="n">map</span><span class="o">.</span><span class="na">size</span> <span class="o">?</span> <span class="nc">Spliterator</span><span class="o">.</span><span class="na">SIZED</span> <span class="o">:</span> <span class="mi">0</span><span class="o">)</span> <span class="o">|</span>
                    <span class="nc">Spliterator</span><span class="o">.</span><span class="na">DISTINCT</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/* ------------------------------------------------------------ */</span>
    <span class="c1">// LinkedHashMap support</span>


    <span class="cm">/*
     * The following package-protected methods are designed to be
     * overridden by LinkedHashMap, but not by any other subclass.
     * Nearly all other internal methods are also package-protected
     * but are declared final, so can be used by LinkedHashMap, view
     * classes, and HashSet.
     */</span>

    <span class="c1">// 创建一个链表结点</span>
    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">newNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">&lt;&gt;(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">next</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 替换一个链表节点</span>
    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">replacementNode</span><span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">&lt;&gt;(</span><span class="n">p</span><span class="o">.</span><span class="na">hash</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="na">value</span><span class="o">,</span> <span class="n">next</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 创建一个红黑树节点</span>
    <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">newTreeNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">&lt;&gt;(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">next</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 替换一个红黑树节点</span>
    <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">replacementTreeNode</span><span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">TreeNode</span><span class="o">&lt;&gt;(</span><span class="n">p</span><span class="o">.</span><span class="na">hash</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="na">value</span><span class="o">,</span> <span class="n">next</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Reset to initial default state.  Called by clone and readObject.
     */</span>
    <span class="kt">void</span> <span class="nf">reinitialize</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">table</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">entrySet</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">keySet</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">modCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Callbacks to allow LinkedHashMap post-actions</span>
    <span class="kt">void</span> <span class="nf">afterNodeAccess</span><span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">afterNodeInsertion</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">evict</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">afterNodeRemoval</span><span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="c1">// 写入hashMap键值对到ObjectOutputStream中</span>
    <span class="kt">void</span> <span class="nf">internalWriteEntries</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">ObjectOutputStream</span> <span class="n">s</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">s</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
                    <span class="n">s</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/* ------------------------------------------------------------ */</span>
    <span class="c1">// Tree bins</span>

    <span class="cm">/**
     * JDK1.8新增，用来支持桶的红黑树结构实现
     * 性质1. 节点是红色或黑色。
     * 性质2. 根是黑色。
     * 性质3. 所有叶子都是黑色（叶子是NIL节点）。
     * 性质4. 每个红色节点必须有两个黑色的子节点。(从每个叶子到根的所有路径上不能有两个连续的红色节点。)
     * 性质5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。
     */</span>

    <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">LinkedHashMap</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">parent</span><span class="o">;</span>  <span class="c1">//节点的父亲</span>
        <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">left</span><span class="o">;</span>    <span class="c1">//节点的左孩子</span>
        <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">right</span><span class="o">;</span>   <span class="c1">//节点的右孩子</span>
        <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">prev</span><span class="o">;</span>    <span class="c1">//节点的前一个节点</span>
        <span class="kt">boolean</span> <span class="n">red</span><span class="o">;</span>            <span class="c1">//true表示红节点，false表示黑节点</span>

        <span class="nc">TreeNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">val</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="n">next</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="cm">/**
         * 获取红黑树的根
         */</span>
        <span class="kd">final</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">root</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="k">this</span><span class="o">,</span> <span class="n">p</span><span class="o">;</span> <span class="o">;</span> <span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="k">return</span> <span class="n">r</span><span class="o">;</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="cm">/**
         * 确保root是桶中的第一个元素 ，将root移到中中的第一个
         */</span>
        <span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">moveRootToFront</span><span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">,</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tab</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">root</span><span class="o">.</span><span class="na">hash</span><span class="o">;</span>
                <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">first</span> <span class="o">=</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;)</span> <span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">!=</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">rn</span><span class="o">;</span>
                    <span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
                    <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">rp</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">((</span><span class="n">rn</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                        <span class="o">((</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;)</span> <span class="n">rn</span><span class="o">).</span><span class="na">prev</span> <span class="o">=</span> <span class="n">rp</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">rp</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                        <span class="n">rp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">rn</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">first</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                        <span class="n">first</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
                    <span class="n">root</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
                    <span class="n">root</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">assert</span> <span class="nf">checkInvariants</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="cm">/**
         * 查找hash为h，key为k的节点
         */</span>
        <span class="kd">final</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">h</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">k</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">kc</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
            <span class="k">do</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">ph</span><span class="o">,</span> <span class="n">dir</span><span class="o">;</span>
                <span class="no">K</span> <span class="n">pk</span><span class="o">;</span>
                <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">pl</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">pr</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">q</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">ph</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">hash</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">h</span><span class="o">)</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">pl</span><span class="o">;</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">ph</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">)</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">pr</span><span class="o">;</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">pk</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">k</span> <span class="o">||</span> <span class="o">(</span><span class="n">k</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">k</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">pk</span><span class="o">)))</span>
                    <span class="k">return</span> <span class="n">p</span><span class="o">;</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">pl</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">pr</span><span class="o">;</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">pr</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">pl</span><span class="o">;</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">kc</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span>
                        <span class="o">(</span><span class="n">kc</span> <span class="o">=</span> <span class="n">comparableClassFor</span><span class="o">(</span><span class="n">k</span><span class="o">))</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                        <span class="o">(</span><span class="n">dir</span> <span class="o">=</span> <span class="n">compareComparables</span><span class="o">(</span><span class="n">kc</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">pk</span><span class="o">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="o">(</span><span class="n">dir</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">pl</span> <span class="o">:</span> <span class="n">pr</span><span class="o">;</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">q</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">kc</span><span class="o">))</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="k">return</span> <span class="n">q</span><span class="o">;</span>
                <span class="k">else</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">pl</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * 获取树节点，通过根节点查找
         */</span>
        <span class="kd">final</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">getTreeNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">h</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">((</span><span class="n">parent</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">root</span><span class="o">()</span> <span class="o">:</span> <span class="k">this</span><span class="o">).</span><span class="na">find</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="cm">/**
         * 比较2个对象的大小
         */</span>
        <span class="kd">static</span> <span class="kt">int</span> <span class="nf">tieBreakOrder</span><span class="o">(</span><span class="nc">Object</span> <span class="n">a</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">d</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">b</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span>
                    <span class="o">(</span><span class="n">d</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">().</span>
                            <span class="n">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">()))</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">identityHashCode</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="nc">System</span><span class="o">.</span><span class="na">identityHashCode</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">?</span>
                        <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">d</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * 将链表转为二叉树
         *
         * @return root of tree
         */</span>
        <span class="kd">final</span> <span class="kt">void</span> <span class="nf">treeify</span><span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">root</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="k">this</span><span class="o">,</span> <span class="n">next</span><span class="o">;</span> <span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">next</span> <span class="o">=</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;)</span> <span class="n">x</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">x</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                    <span class="n">x</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="n">root</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="no">K</span> <span class="n">k</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">;</span>
                    <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">hash</span><span class="o">;</span>
                    <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">kc</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                    <span class="k">for</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span> <span class="o">;</span> <span class="o">)</span> <span class="o">{</span>
                        <span class="kt">int</span> <span class="n">dir</span><span class="o">,</span> <span class="n">ph</span><span class="o">;</span>
                        <span class="no">K</span> <span class="n">pk</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">;</span>
                        <span class="k">if</span> <span class="o">((</span><span class="n">ph</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">hash</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">h</span><span class="o">)</span>
                            <span class="n">dir</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">ph</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">)</span>
                            <span class="n">dir</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                        <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">kc</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
                                <span class="o">(</span><span class="n">kc</span> <span class="o">=</span> <span class="n">comparableClassFor</span><span class="o">(</span><span class="n">k</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">||</span>
                                <span class="o">(</span><span class="n">dir</span> <span class="o">=</span> <span class="n">compareComparables</span><span class="o">(</span><span class="n">kc</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">pk</span><span class="o">))</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
                            <span class="n">dir</span> <span class="o">=</span> <span class="n">tieBreakOrder</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">pk</span><span class="o">);</span>

                        <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">xp</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                        <span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="o">(</span><span class="n">dir</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">p</span><span class="o">.</span><span class="na">left</span> <span class="o">:</span> <span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">x</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">xp</span><span class="o">;</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">dir</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>
                                <span class="n">xp</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
                            <span class="k">else</span>
                                <span class="n">xp</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
                            <span class="n">root</span> <span class="o">=</span> <span class="n">balanceInsertion</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
                            <span class="k">break</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">moveRootToFront</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="cm">/**
         * 将二叉树转为链表
         */</span>
        <span class="kd">final</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">untreeify</span><span class="o">(</span><span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">hd</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">tl</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span> <span class="n">q</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">replacementNode</span><span class="o">(</span><span class="n">q</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">tl</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">hd</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                <span class="k">else</span>
                    <span class="n">tl</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                <span class="n">tl</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">hd</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * 添加一个键值对
         */</span>
        <span class="kd">final</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">putTreeVal</span><span class="o">(</span><span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">,</span>
                                        <span class="kt">int</span> <span class="n">h</span><span class="o">,</span> <span class="no">K</span> <span class="n">k</span><span class="o">,</span> <span class="no">V</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">kc</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="kt">boolean</span> <span class="n">searched</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">root</span> <span class="o">=</span> <span class="o">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">root</span><span class="o">()</span> <span class="o">:</span> <span class="k">this</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span> <span class="o">;</span> <span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">dir</span><span class="o">,</span> <span class="n">ph</span><span class="o">;</span>
                <span class="no">K</span> <span class="n">pk</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">ph</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">hash</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">h</span><span class="o">)</span>
                    <span class="n">dir</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">ph</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">)</span>
                    <span class="n">dir</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">pk</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">k</span> <span class="o">||</span> <span class="o">(</span><span class="n">k</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">k</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">pk</span><span class="o">)))</span>
                    <span class="k">return</span> <span class="n">p</span><span class="o">;</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">kc</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
                        <span class="o">(</span><span class="n">kc</span> <span class="o">=</span> <span class="n">comparableClassFor</span><span class="o">(</span><span class="n">k</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">||</span>
                        <span class="o">(</span><span class="n">dir</span> <span class="o">=</span> <span class="n">compareComparables</span><span class="o">(</span><span class="n">kc</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">pk</span><span class="o">))</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">searched</span><span class="o">)</span> <span class="o">{</span>
                        <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">,</span> <span class="n">ch</span><span class="o">;</span>
                        <span class="n">searched</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="k">if</span> <span class="o">(((</span><span class="n">ch</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
                                <span class="o">(</span><span class="n">q</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">kc</span><span class="o">))</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">||</span>
                                <span class="o">((</span><span class="n">ch</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
                                        <span class="o">(</span><span class="n">q</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">kc</span><span class="o">))</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">))</span>
                            <span class="k">return</span> <span class="n">q</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="n">dir</span> <span class="o">=</span> <span class="n">tieBreakOrder</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">pk</span><span class="o">);</span>
                <span class="o">}</span>

                <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">xp</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="o">(</span><span class="n">dir</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">p</span><span class="o">.</span><span class="na">left</span> <span class="o">:</span> <span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">xpn</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                    <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">newTreeNode</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">xpn</span><span class="o">);</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">dir</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>
                        <span class="n">xp</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
                    <span class="k">else</span>
                        <span class="n">xp</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
                    <span class="n">xp</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
                    <span class="n">x</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">xp</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">xpn</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                        <span class="o">((</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;)</span> <span class="n">xpn</span><span class="o">).</span><span class="na">prev</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
                    <span class="n">moveRootToFront</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">balanceInsertion</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">x</span><span class="o">));</span>
                    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="cm">/**
         * Removes the given node, that must be present before this call.
         * This is messier than typical red-black deletion code because we
         * cannot swap the contents of an interior node with a leaf
         * successor that is pinned by "next" pointers that are accessible
         * independently during traversal. So instead we swap the tree
         * linkages. If the current tree appears to have too few nodes,
         * the bin is converted back to a plain bin. (The test triggers
         * somewhere between 2 and 6 nodes, depending on tree structure).
         */</span>
        <span class="kd">final</span> <span class="kt">void</span> <span class="nf">removeTreeNode</span><span class="o">(</span><span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">,</span>
                                  <span class="kt">boolean</span> <span class="n">movable</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tab</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">;</span>
            <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">first</span> <span class="o">=</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;)</span> <span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">],</span> <span class="n">root</span> <span class="o">=</span> <span class="n">first</span><span class="o">,</span> <span class="n">rl</span><span class="o">;</span>
            <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">succ</span> <span class="o">=</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;)</span> <span class="n">next</span><span class="o">,</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">pred</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">first</span> <span class="o">=</span> <span class="n">succ</span><span class="o">;</span>
            <span class="k">else</span>
                <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">succ</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">succ</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">succ</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pred</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">first</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">parent</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">root</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span>
                    <span class="o">(</span><span class="n">rl</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">rl</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">untreeify</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>  <span class="c1">// too small</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">this</span><span class="o">,</span> <span class="n">pl</span> <span class="o">=</span> <span class="n">left</span><span class="o">,</span> <span class="n">pr</span> <span class="o">=</span> <span class="n">right</span><span class="o">,</span> <span class="n">replacement</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">pl</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">pr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">pr</span><span class="o">,</span> <span class="n">sl</span><span class="o">;</span>
                <span class="k">while</span> <span class="o">((</span><span class="n">sl</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="c1">// find successor</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">sl</span><span class="o">;</span>
                <span class="kt">boolean</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">red</span><span class="o">;</span>
                <span class="n">s</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">red</span><span class="o">;</span>
                <span class="n">p</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span> <span class="c1">// swap colors</span>
                <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
                <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">parent</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">pr</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// p was s's direct parent</span>
                    <span class="n">p</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
                    <span class="n">s</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">sp</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">parent</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">((</span><span class="n">p</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">sp</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">sp</span><span class="o">.</span><span class="na">left</span><span class="o">)</span>
                            <span class="n">sp</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                        <span class="k">else</span>
                            <span class="n">sp</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">if</span> <span class="o">((</span><span class="n">s</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">pr</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                        <span class="n">pr</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">p</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">p</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">sr</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">sr</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">s</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">pl</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">pl</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">s</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">pp</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">root</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">pp</span><span class="o">.</span><span class="na">left</span><span class="o">)</span>
                    <span class="n">pp</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
                <span class="k">else</span>
                    <span class="n">pp</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">sr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">replacement</span> <span class="o">=</span> <span class="n">sr</span><span class="o">;</span>
                <span class="k">else</span>
                    <span class="n">replacement</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">pl</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">replacement</span> <span class="o">=</span> <span class="n">pl</span><span class="o">;</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">pr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">replacement</span> <span class="o">=</span> <span class="n">pr</span><span class="o">;</span>
            <span class="k">else</span>
                <span class="n">replacement</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">replacement</span> <span class="o">!=</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">replacement</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">parent</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">pp</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">root</span> <span class="o">=</span> <span class="n">replacement</span><span class="o">;</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">pp</span><span class="o">.</span><span class="na">left</span><span class="o">)</span>
                    <span class="n">pp</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">replacement</span><span class="o">;</span>
                <span class="k">else</span>
                    <span class="n">pp</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">replacement</span><span class="o">;</span>
                <span class="n">p</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">red</span> <span class="o">?</span> <span class="n">root</span> <span class="o">:</span> <span class="n">balanceDeletion</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">replacement</span><span class="o">);</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">replacement</span> <span class="o">==</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// detach</span>
                <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">parent</span><span class="o">;</span>
                <span class="n">p</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">pp</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">pp</span><span class="o">.</span><span class="na">left</span><span class="o">)</span>
                        <span class="n">pp</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">pp</span><span class="o">.</span><span class="na">right</span><span class="o">)</span>
                        <span class="n">pp</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">movable</span><span class="o">)</span>
                <span class="n">moveRootToFront</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="cm">/**
         * 将结点太多的桶分割
         *
         * @param map   the map
         * @param tab   the table for recording bin heads
         * @param index the index of the table being split
         * @param bit   the bit of hash to split on
         */</span>
        <span class="kd">final</span> <span class="kt">void</span> <span class="nf">split</span><span class="o">(</span><span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">,</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="kt">int</span> <span class="n">bit</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
            <span class="c1">// Relink into lo and hi lists, preserving order</span>
            <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">loHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">loTail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">hiHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">hiTail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">lc</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">hc</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">b</span><span class="o">,</span> <span class="n">next</span><span class="o">;</span> <span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">next</span> <span class="o">=</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;)</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="n">e</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">((</span><span class="n">e</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">loTail</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                        <span class="n">loHead</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                    <span class="k">else</span>
                        <span class="n">loTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                    <span class="n">loTail</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                    <span class="o">++</span><span class="n">lc</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">((</span><span class="n">e</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">hiTail</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                        <span class="n">hiHead</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                    <span class="k">else</span>
                        <span class="n">hiTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                    <span class="n">hiTail</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
                    <span class="o">++</span><span class="n">hc</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">loHead</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">lc</span> <span class="o">&lt;=</span> <span class="no">UNTREEIFY_THRESHOLD</span><span class="o">)</span>
                    <span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">loHead</span><span class="o">.</span><span class="na">untreeify</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
                <span class="k">else</span> <span class="o">{</span>
                    <span class="n">tab</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">loHead</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">hiHead</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="c1">// (else is already treeified)</span>
                        <span class="n">loHead</span><span class="o">.</span><span class="na">treeify</span><span class="o">(</span><span class="n">tab</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">hiHead</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">hc</span> <span class="o">&lt;=</span> <span class="no">UNTREEIFY_THRESHOLD</span><span class="o">)</span>
                    <span class="n">tab</span><span class="o">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">bit</span><span class="o">]</span> <span class="o">=</span> <span class="n">hiHead</span><span class="o">.</span><span class="na">untreeify</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
                <span class="k">else</span> <span class="o">{</span>
                    <span class="n">tab</span><span class="o">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">bit</span><span class="o">]</span> <span class="o">=</span> <span class="n">hiHead</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">loHead</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                        <span class="n">hiHead</span><span class="o">.</span><span class="na">treeify</span><span class="o">(</span><span class="n">tab</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="cm">/* ------------------------------------------------------------ */</span>
        <span class="c1">// 红黑树方法，都是从CLR中修改的</span>

        <span class="cm">/**
         * 左旋转
         *
         * @param root
         * @param p
         * @param &lt;K&gt;
         * @param &lt;V&gt;
         * @return
         */</span>
        <span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">rotateLeft</span><span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">root</span><span class="o">,</span>
                                                <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">r</span><span class="o">,</span> <span class="n">pp</span><span class="o">,</span> <span class="n">rl</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">r</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">rl</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">rl</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">pp</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="o">(</span><span class="n">root</span> <span class="o">=</span> <span class="n">r</span><span class="o">).</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">pp</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="n">p</span><span class="o">)</span>
                    <span class="n">pp</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
                <span class="k">else</span>
                    <span class="n">pp</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
                <span class="n">r</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                <span class="n">p</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * 右旋转
         *
         * @param root
         * @param p
         * @param &lt;K&gt;
         * @param &lt;V&gt;
         * @return
         */</span>
        <span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">rotateRight</span><span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">root</span><span class="o">,</span>
                                                 <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">l</span><span class="o">,</span> <span class="n">pp</span><span class="o">,</span> <span class="n">lr</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">l</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">lr</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">lr</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">pp</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="o">(</span><span class="n">root</span> <span class="o">=</span> <span class="n">l</span><span class="o">).</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">pp</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="n">p</span><span class="o">)</span>
                    <span class="n">pp</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span>
                <span class="k">else</span>
                    <span class="n">pp</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span>
                <span class="n">l</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
                <span class="n">p</span><span class="o">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">l</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * 保证插入后平衡
         *
         * @param root
         * @param x
         * @param &lt;K&gt;
         * @param &lt;V&gt;
         * @return
         */</span>
        <span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">balanceInsertion</span><span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">root</span><span class="o">,</span>
                                                      <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">x</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">xp</span><span class="o">,</span> <span class="n">xpp</span><span class="o">,</span> <span class="n">xppl</span><span class="o">,</span> <span class="n">xppr</span><span class="o">;</span> <span class="o">;</span> <span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">xp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">x</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(!</span><span class="n">xp</span><span class="o">.</span><span class="na">red</span> <span class="o">||</span> <span class="o">(</span><span class="n">xpp</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">xp</span> <span class="o">==</span> <span class="o">(</span><span class="n">xppl</span> <span class="o">=</span> <span class="n">xpp</span><span class="o">.</span><span class="na">left</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">((</span><span class="n">xppr</span> <span class="o">=</span> <span class="n">xpp</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">xppr</span><span class="o">.</span><span class="na">red</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">xppr</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                        <span class="n">xp</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                        <span class="n">xpp</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">xpp</span><span class="o">;</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">xp</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">root</span> <span class="o">=</span> <span class="n">rotateLeft</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">xp</span><span class="o">);</span>
                            <span class="n">xpp</span> <span class="o">=</span> <span class="o">(</span><span class="n">xp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">xp</span><span class="o">.</span><span class="na">parent</span><span class="o">;</span>
                        <span class="o">}</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">xp</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">xp</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">xpp</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                                <span class="n">xpp</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                                <span class="n">root</span> <span class="o">=</span> <span class="n">rotateRight</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">xpp</span><span class="o">);</span>
                            <span class="o">}</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">xppl</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">xppl</span><span class="o">.</span><span class="na">red</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">xppl</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                        <span class="n">xp</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                        <span class="n">xpp</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">xpp</span><span class="o">;</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">xp</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">root</span> <span class="o">=</span> <span class="n">rotateRight</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">xp</span><span class="o">);</span>
                            <span class="n">xpp</span> <span class="o">=</span> <span class="o">(</span><span class="n">xp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">xp</span><span class="o">.</span><span class="na">parent</span><span class="o">;</span>
                        <span class="o">}</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">xp</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">xp</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">xpp</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                                <span class="n">xpp</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                                <span class="n">root</span> <span class="o">=</span> <span class="n">rotateLeft</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">xpp</span><span class="o">);</span>
                            <span class="o">}</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="cm">/**
         * 删除后调整平衡
         *
         * @param root
         * @param x
         * @param &lt;K&gt;
         * @param &lt;V&gt;
         * @return
         */</span>
        <span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">balanceDeletion</span><span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">root</span><span class="o">,</span>
                                                     <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">xp</span><span class="o">,</span> <span class="n">xpl</span><span class="o">,</span> <span class="n">xpr</span><span class="o">;</span> <span class="o">;</span> <span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="n">root</span><span class="o">)</span>
                    <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">((</span><span class="n">xp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">x</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">red</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">x</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">xpl</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">==</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">((</span><span class="n">xpr</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">xpr</span><span class="o">.</span><span class="na">red</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">xpr</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                        <span class="n">xp</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">root</span> <span class="o">=</span> <span class="n">rotateLeft</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">xp</span><span class="o">);</span>
                        <span class="n">xpr</span> <span class="o">=</span> <span class="o">(</span><span class="n">xp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">xp</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">xpr</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">xp</span><span class="o">;</span>
                    <span class="k">else</span> <span class="o">{</span>
                        <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">sl</span> <span class="o">=</span> <span class="n">xpr</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">xpr</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
                        <span class="k">if</span> <span class="o">((</span><span class="n">sr</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">sr</span><span class="o">.</span><span class="na">red</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                                <span class="o">(</span><span class="n">sl</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">sl</span><span class="o">.</span><span class="na">red</span><span class="o">))</span> <span class="o">{</span>
                            <span class="n">xpr</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                            <span class="n">x</span> <span class="o">=</span> <span class="n">xp</span><span class="o">;</span>
                        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">sr</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">sr</span><span class="o">.</span><span class="na">red</span><span class="o">)</span> <span class="o">{</span>
                                <span class="k">if</span> <span class="o">(</span><span class="n">sl</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                                    <span class="n">sl</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                                <span class="n">xpr</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                                <span class="n">root</span> <span class="o">=</span> <span class="n">rotateRight</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">xpr</span><span class="o">);</span>
                                <span class="n">xpr</span> <span class="o">=</span> <span class="o">(</span><span class="n">xp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span>
                                        <span class="kc">null</span> <span class="o">:</span> <span class="n">xp</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
                            <span class="o">}</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">xpr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                                <span class="n">xpr</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="o">(</span><span class="n">xp</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="kc">false</span> <span class="o">:</span> <span class="n">xp</span><span class="o">.</span><span class="na">red</span><span class="o">;</span>
                                <span class="k">if</span> <span class="o">((</span><span class="n">sr</span> <span class="o">=</span> <span class="n">xpr</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                                    <span class="n">sr</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                            <span class="o">}</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">xp</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                                <span class="n">xp</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                                <span class="n">root</span> <span class="o">=</span> <span class="n">rotateLeft</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">xp</span><span class="o">);</span>
                            <span class="o">}</span>
                            <span class="n">x</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// symmetric</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">xpl</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">xpl</span><span class="o">.</span><span class="na">red</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">xpl</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                        <span class="n">xp</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">root</span> <span class="o">=</span> <span class="n">rotateRight</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">xp</span><span class="o">);</span>
                        <span class="n">xpl</span> <span class="o">=</span> <span class="o">(</span><span class="n">xp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">xp</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">xpl</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">xp</span><span class="o">;</span>
                    <span class="k">else</span> <span class="o">{</span>
                        <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">sl</span> <span class="o">=</span> <span class="n">xpl</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">xpl</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
                        <span class="k">if</span> <span class="o">((</span><span class="n">sl</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">sl</span><span class="o">.</span><span class="na">red</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                                <span class="o">(</span><span class="n">sr</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">sr</span><span class="o">.</span><span class="na">red</span><span class="o">))</span> <span class="o">{</span>
                            <span class="n">xpl</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                            <span class="n">x</span> <span class="o">=</span> <span class="n">xp</span><span class="o">;</span>
                        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">sl</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">sl</span><span class="o">.</span><span class="na">red</span><span class="o">)</span> <span class="o">{</span>
                                <span class="k">if</span> <span class="o">(</span><span class="n">sr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                                    <span class="n">sr</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                                <span class="n">xpl</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                                <span class="n">root</span> <span class="o">=</span> <span class="n">rotateLeft</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">xpl</span><span class="o">);</span>
                                <span class="n">xpl</span> <span class="o">=</span> <span class="o">(</span><span class="n">xp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">parent</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span>
                                        <span class="kc">null</span> <span class="o">:</span> <span class="n">xp</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
                            <span class="o">}</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">xpl</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                                <span class="n">xpl</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="o">(</span><span class="n">xp</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="kc">false</span> <span class="o">:</span> <span class="n">xp</span><span class="o">.</span><span class="na">red</span><span class="o">;</span>
                                <span class="k">if</span> <span class="o">((</span><span class="n">sl</span> <span class="o">=</span> <span class="n">xpl</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                                    <span class="n">sl</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                            <span class="o">}</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">xp</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                                <span class="n">xp</span><span class="o">.</span><span class="na">red</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                                <span class="n">root</span> <span class="o">=</span> <span class="n">rotateRight</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">xp</span><span class="o">);</span>
                            <span class="o">}</span>
                            <span class="n">x</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="cm">/**
         * 检测是否符合红黑树
         */</span>
        <span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="kt">boolean</span> <span class="nf">checkInvariants</span><span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">tp</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">parent</span><span class="o">,</span> <span class="n">tl</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">tr</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">right</span><span class="o">,</span>
                    <span class="n">tb</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">prev</span><span class="o">,</span> <span class="n">tn</span> <span class="o">=</span> <span class="o">(</span><span class="nc">TreeNode</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;)</span> <span class="n">t</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tb</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tb</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="n">t</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tn</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tn</span><span class="o">.</span><span class="na">prev</span> <span class="o">!=</span> <span class="n">t</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tp</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">tp</span><span class="o">.</span><span class="na">left</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">tp</span><span class="o">.</span><span class="na">right</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tl</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">tl</span><span class="o">.</span><span class="na">parent</span> <span class="o">!=</span> <span class="n">t</span> <span class="o">||</span> <span class="n">tl</span><span class="o">.</span><span class="na">hash</span> <span class="o">&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">hash</span><span class="o">))</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tr</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">tr</span><span class="o">.</span><span class="na">parent</span> <span class="o">!=</span> <span class="n">t</span> <span class="o">||</span> <span class="n">tr</span><span class="o">.</span><span class="na">hash</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">.</span><span class="na">hash</span><span class="o">))</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">red</span> <span class="o">&amp;&amp;</span> <span class="n">tl</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tl</span><span class="o">.</span><span class="na">red</span> <span class="o">&amp;&amp;</span> <span class="n">tr</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tr</span><span class="o">.</span><span class="na">red</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tl</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">checkInvariants</span><span class="o">(</span><span class="n">tl</span><span class="o">))</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tr</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">checkInvariants</span><span class="o">(</span><span class="n">tr</span><span class="o">))</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://blog.dreamylost.cn" target="_blank">梦境迷离</a></li><li>本文链接：<a href="https://blog.dreamylost.cn/java%E6%BA%90%E7%A0%81/Java%E6%BA%90%E7%A0%81-HashMap.html" target="_blank">https://blog.dreamylost.cn/java%E6%BA%90%E7%A0%81/Java%E6%BA%90%E7%A0%81-HashMap.html</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/java%E6%BA%90%E7%A0%81/Java%E6%BA%90%E7%A0%81-Has', clientID: '061aadb5d449c0877d7d', clientSecret: '9aa7af7c248a7e36a07a86993e11a7acf7fbd353', repo: 'dreamylost-comments', owner: 'jxnu-liguobin', admin: ['jxnu-liguobin'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@built/assets/search_data.json?v=1702960983', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2019 <span title="梦境迷离">梦境迷离</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/jxnu-liguobin/jxnu-liguobin.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://blog.dreamylost.cn/" title="首页" target="">首页</a></li><li> <a href="https://blog.dreamylost.cn/categories/" title="分类" target="">分类</a></li><li> <a href="https://blog.dreamylost.cn/archives/" title="归档" target="">归档</a></li><li> <a href="https://blog.dreamylost.cn/open-source/" title="开源" target="">开源</a></li><li> <a href="https://blog.dreamylost.cn/wiki/" title="维基" target="">维基</a></li><li> <a href="https://blog.dreamylost.cn/links/" title="链接" target="">链接</a></li><li> <a href="https://blog.dreamylost.cn/about/" title="关于" target="">关于</a></li><li><a href="https://blog.dreamylost.cn/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2019-09-20 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
