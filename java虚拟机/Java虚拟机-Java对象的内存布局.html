<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>Java对象的内存布局 &mdash; 梦境迷离</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="canonical" href="https://jxnu-liguobin.github.io/java%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.html"><link rel="alternate" type="application/atom+xml" title="梦境迷离" href="https://jxnu-liguobin.github.io/feed.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/favicon.ico"><meta property="og:title" content="Java对象的内存布局"><meta name="keywords" content="梦境迷离, jxnu-liguobin"><meta name="og:keywords" content="梦境迷离, jxnu-liguobin"><meta name="description" content=""><meta name="og:description" content=""><meta property="og:url" content="https://jxnu-liguobin.github.io/java%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.html"><meta property="og:site_name" content="梦境迷离"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2020-10-14"> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://jxnu-liguobin.github.io/" title="梦境迷离"><span class="octicon octicon-mark-github"></span> 梦境迷离</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://jxnu-liguobin.github.io/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://jxnu-liguobin.github.io/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://jxnu-liguobin.github.io/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://jxnu-liguobin.github.io/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://jxnu-liguobin.github.io/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="Java对象的内存布局"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">Java对象的内存布局</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2020/10/14 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://jxnu-liguobin.github.io/categories/#Java虚拟机" title="Java虚拟机">Java虚拟机</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 9194 字，约 27 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><ul id="markdown-toc"><li><a href="#总览" id="markdown-toc-总览">总览</a></li><li><a href="#普通对象指针oop" id="markdown-toc-普通对象指针oop">普通对象指针（OOP）</a></li><li><a href="#java对象布局工具jol" id="markdown-toc-java对象布局工具jol">Java对象布局工具（JOL）</a><ul><li><a href="#示例" id="markdown-toc-示例">示例</a><ul><li><a href="#基础" id="markdown-toc-基础">基础</a></li><li><a href="#哈希码" id="markdown-toc-哈希码">哈希码</a></li><li><a href="#对齐" id="markdown-toc-对齐">对齐</a></li><li><a href="#字段填充" id="markdown-toc-字段填充">字段填充</a></li><li><a href="#锁" id="markdown-toc-锁">锁</a></li><li><a href="#年龄和寿命" id="markdown-toc-年龄和寿命">年龄和寿命</a></li><li><a href="#伪共享和-contended-注解" id="markdown-toc-伪共享和-contended-注解">伪共享和 @Contended 注解</a></li><li><a href="#数组" id="markdown-toc-数组">数组</a></li><li><a href="#压缩引用" id="markdown-toc-压缩引用">压缩引用</a></li></ul></li><li><a href="#总结" id="markdown-toc-总结">总结</a></li><li><a href="#mark-word-结构" id="markdown-toc-mark-word-结构">Mark Word 结构</a></li></ul></li></ul><blockquote><p>在本文中，下面的mark即表示Mark World结构，klass即表示Klass Word结构。它们是<code class="language-plaintext highlighter-rouge">oopDesc</code>中的数据结构。 在本文中，hashcode 就是 identity hash code（是指不经重写过由jvm计算的hashcode）。</p></blockquote><h2 id="总览">总览</h2><p>在本教程中，我们将了解JVM如何在堆中布置对象和数组。首先，我们将从一些理论开始。然后，我们将探讨在不同情况下的不同对象和数组的内存布局。</p><p>通常，运行时数据区域的内存布局不是JVM规范的一部分，并由<a href="https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-2.html">实现者自行决定</a>。因此，每个JVM实现可能具有不同的策略来在内存中布局对象和数组。在本教程中，我们重点介绍一种特定的JVM实现：HotSpot JVM。</p><p>我们也可以互换使用的JVM和HotSpot JVM术语。</p><h2 id="普通对象指针oop">普通对象指针（OOP）</h2><p><strong>HotSpot JVM使用称为普通对象指针（<a href="https://github.com/openjdk/jdk15/tree/master/src/hotspot/share/oops">OOPS</a>）的数据结构来表示指向对象的指针</strong>。JVM中的所有指针（对象和数组）均基于称为<a href="https://github.com/openjdk/jdk15/blob/e208d9aa1f185c11734a07db399bab0be77ef15f/src/hotspot/share/oops/oop.hpp#L52">oopDesc</a>的特殊数据结构。每个oopDesc使用以下信息描述指针：</p><ul><li>一个<a href="https://github.com/openjdk/jdk15/blob/e208d9aa1f185c11734a07db399bab0be77ef15f/src/hotspot/share/oops/oop.hpp#L56">mark word</a></li><li>一个可能被压缩的<a href="https://github.com/openjdk/jdk15/blob/e208d9aa1f185c11734a07db399bab0be77ef15f/src/hotspot/share/oops/oop.hpp#L57">klass word</a></li></ul><blockquote><p>着实不确定该把klass word翻译成什么，其作用是存储语言级别的类信息</p></blockquote><p><a href="https://github.com/openjdk/jdk15/blob/e208d9aa1f185c11734a07db399bab0be77ef15f/src/hotspot/share/oops/markWord.hpp#L33">mark word</a>描述对象头。<strong>HotSpot JVM使用此结构来存储哈希码，偏向锁，锁信息和GC元数据。</strong></p><p>此外，mark word状态仅包含一个<a href="https://github.com/openjdk/jdk15/blob/e208d9aa1f185c11734a07db399bab0be77ef15f/src/hotspot/share/oops/markWord.hpp#L96">uintptr_t</a>，因此，<strong>在32位和64位架构中，其大小在4字节和8字节之间变化。</strong> 同样，偏向对象和普通对象的mark word也不同。但是，我们只考虑普通对象，因为Java 15将<a href="https://openjdk.java.net/jeps/374">弃用偏向锁</a>。</p><p>此外，klass word还封装了语言级别的类信息，例如类名，修饰符，超类信息等。</p><p>对于Java中的普通实例，表示为<a href="https://github.com/openjdk/jdk15/blob/master/src/hotspot/share/oops/instanceOop.hpp">instanceOop</a>，<strong>对象标头由mark和klass加上可能的对齐填充组成。</strong> 在对象标头之后，可能有零个或多个对实例字段的引用。因此，在64位架构中，至少有16个字节，这是因为有8个字节的mark，4个字节的klass和另外4个字节用于填充。</p><p>对于Java中的数组，表示为<a href="https://github.com/openjdk/jdk15/blob/e208d9aa1f185c11734a07db399bab0be77ef15f/src/hotspot/share/oops/arrayOop.hpp#L35">arrayOop</a>，对象头除了mark，klass和填充以外，还包含4字节的数组长度。同样，由于mark的8个字节，klass的4个字节和数组长度的另外4个字节，因此至少应为16个字节。</p><h2 id="java对象布局工具jol">Java对象布局工具（JOL）</h2><h3 id="示例">示例</h3><p>添加依赖：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;dependency&gt;
    &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;
    &lt;artifactId&gt;jol-core&lt;/artifactId&gt;
    &lt;version&gt;0.10&lt;/version&gt;
&lt;/dependency&gt;
</code></pre></div></div><p>让我们从查看常规VM详细信息开始：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="no">VM</span><span class="o">.</span><span class="na">current</span><span class="o">().</span><span class="na">details</span><span class="o">());</span>
</code></pre></div></div><p>这将打印：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Running 64-bit HotSpot VM.
# Objects are 8 bytes aligned.
# Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]
# Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]
</code></pre></div></div><p>这意味着引用占4个字节，布尔和字节占1个字节，短整型和字符占2个字节，整数和浮点数占4个字节，而长整数和双精度浮点数占8个字节。有趣的是，如果我们将它们用作数组元素，它们将消耗相同数量的内存。</p><p>此外，如果我们通过<code class="language-plaintext highlighter-rouge">-XX：-UseCompressedOops</code>禁用压缩引用，则引用大小会变成占用8个字节：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Field sizes by type: 8, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]
# Array element sizes: 8, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]
</code></pre></div></div><p>让我们看一个SimpleInt类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleInt</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">state</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>如果我们打印其类布局：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">ClassLayout</span><span class="o">.</span><span class="na">parseClass</span><span class="o">(</span><span class="nc">SimpleInt</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">toPrintable</span><span class="o">());</span>
</code></pre></div></div><h4 id="基础">基础</h4><p>我们将看到类似以下内容：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SimpleInt object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0    12        (object header)                           N/A
     12     4    int SimpleInt.state                           N/A
Instance size: 16 bytes
Space losses: 0 bytes internal + 0 bytes external = 0 bytes total
</code></pre></div></div><p>如上所示，对象头是12个字节，包括8个字节的mark和4个字节的klass。之后，我们有4个字节用于存储<code class="language-plaintext highlighter-rouge">int state</code>。此类中的任何对象总共将占用16个字节。</p><p>而且，对象头和<code class="language-plaintext highlighter-rouge">state</code>没有值，因为我们正在解析类布局，而不是实例布局。</p><h4 id="哈希码">哈希码</h4><p><code class="language-plaintext highlighter-rouge">hashCode()</code>是所有Java对象的常用方法之一。<strong>当我们不为类声明<code class="language-plaintext highlighter-rouge">hashCode()</code>方法时，Java将为其计算默认的哈希码。</strong></p><p>哈希码在对象的生命周期内不会更改。因此，<strong>HotSpot JVM一旦计算出此值，便会将其存储在mark中。</strong></p><p>让我们看一下对象实例的内存布局：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SimpleInt</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SimpleInt</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">ClassLayout</span><span class="o">.</span><span class="na">parseInstance</span><span class="o">(</span><span class="n">instance</span><span class="o">).</span><span class="na">toPrintable</span><span class="o">());</span>
</code></pre></div></div><p>HotSpot JVM延迟计算哈希码：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SimpleInt object internals:
 OFFSET  SIZE   TYPE DESCRIPTION               VALUE
      0     4        (object header)           01 00 00 00 (00000001 00000000 00000000 00000000) (1) # mark
      4     4        (object header)           00 00 00 00 (00000000 00000000 00000000 00000000) (0) # mark
      8     4        (object header)           9b 1b 01 f8 (10011011 00011011 00000001 11111000) (-134145125) # klass
     12     4    int SimpleInt.state           0
Instance size: 16 bytes
Space losses: 0 bytes internal + 0 bytes external = 0 bytes total
</code></pre></div></div><p>如上所示，mark中目前似乎尚未存储任何重要内容。</p><p>但是，如果我们在对象实例上调用<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#identityHashCode-java.lang.Object-">System.identityHashCode()</a>或<code class="language-plaintext highlighter-rouge">Object.hashCode()</code>，这将改变：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The identity hash code is "</span> <span class="o">+</span> <span class="nc">System</span><span class="o">.</span><span class="na">identityHashCode</span><span class="o">(</span><span class="n">instance</span><span class="o">));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">ClassLayout</span><span class="o">.</span><span class="na">parseInstance</span><span class="o">(</span><span class="n">instance</span><span class="o">).</span><span class="na">toPrintable</span><span class="o">());</span>
</code></pre></div></div><p>现在，我们可以将哈希码作为mark的一部分：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The identity hash code is 1702146597
SimpleInt object internals:
 OFFSET  SIZE   TYPE DESCRIPTION               VALUE
      0     4        (object header)           01 25 b2 74 (00000001 00100101 10110010 01110100) (1957831937)
      4     4        (object header)           65 00 00 00 (01100101 00000000 00000000 00000000) (101)
      8     4        (object header)           9b 1b 01 f8 (10011011 00011011 00000001 11111000) (-134145125)
     12     4    int SimpleInt.state           0
</code></pre></div></div><p>HotSpot JVM将哈希码存储为mark中的“25b27465”。最高有效字节为65，因为JVM以little-endian格式存储该值。因此，要恢复以十进制表示的哈希码值（1702146597），我们必须以相反的顺序读取“25b27465”字节序列：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>65 74 b2 25 = 01100101 01110100 10110010 00100101 = 1702146597
</code></pre></div></div><h4 id="对齐">对齐</h4><p>默认情况下，JVM向对象添加足够的填充以使其大小为8的倍数。</p><p>例如，我们看一下SimpleLong类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleLong</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">state</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>如果我们解析类布局：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">ClassLayout</span><span class="o">.</span><span class="na">parseClass</span><span class="o">(</span><span class="nc">SimpleLong</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">toPrintable</span><span class="o">());</span>
</code></pre></div></div><p>然后，JOL将打印内存布局：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SimpleLong object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0    12        (object header)                           N/A
     12     4        (alignment/padding gap)                  
     16     8   long SimpleLong.state                          N/A
Instance size: 24 bytes
Space losses: 4 bytes internal + 0 bytes external = 4 bytes total
</code></pre></div></div><p>如上所示，对象头和long类型的<code class="language-plaintext highlighter-rouge">state</code>字段总共消耗20个字节。<strong>要使此大小为8字节的倍数，JVM会添加4字节的填充。</strong></p><p>我们还可以通过<code class="language-plaintext highlighter-rouge">-XX:ObjectAlignmentInBytes</code>调整标志来更改默认对齐大小。例如，对于同一个类，<code class="language-plaintext highlighter-rouge">-XX:ObjectAlignmentInBytes=16</code>的内存布局将是：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SimpleLong object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0    12        (object header)                           N/A
     12     4        (alignment/padding gap)                  
     16     8   long SimpleLong.state                          N/A
     24     8        (loss due to the next object alignment)
Instance size: 32 bytes
Space losses: 4 bytes internal + 8 bytes external = 12 bytes total
</code></pre></div></div><p>对象头和long变量总共仍然占用20个字节。因此，我们应该再增加12个字节，使其成为16的倍数。</p><p>如上所示，它增加了4个内部填充字节以在16号偏移处开始long变量（启用更对齐的访问）。然后它将剩余的8个字节加到long变量之后。</p><h4 id="字段填充">字段填充</h4><p><strong>当一个类具有多个字段时，JVM可以以最小化填充浪费的方式分配这些字段。</strong> 例如，对于FieldsArrangement类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FieldsArrangement</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">char</span> <span class="n">second</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">double</span> <span class="n">third</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">fourth</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">fifth</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>字段声明顺序及其在内存布局中的顺序不同：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OFFSET  SIZE      TYPE DESCRIPTION                               VALUE
      0    12           (object header)                           N/A
     12     4       int FieldsArrangement.fourth                  N/A
     16     8    double FieldsArrangement.third                   N/A
     24     2      char FieldsArrangement.second                  N/A
     26     1   boolean FieldsArrangement.first                   N/A
     27     1   boolean FieldsArrangement.fifth                   N/A
     28     4           (loss due to the next object alignment)
</code></pre></div></div><p>其背后的主要动机是最大程度地减少填充浪费。</p><h4 id="锁">锁</h4><p>JVM还维护mark内的锁定信息。让我们来看看实际情况：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Lock</span> <span class="o">{}</span>
</code></pre></div></div><p>如果我们创建此类的实例，则其内存布局为：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Lock object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           01 00 00 00 
      4     4        (object header)                           00 00 00 00
      8     4        (object header)                           85 23 02 f8
     12     4        (loss due to the next object alignment)
Instance size: 16 bytes
</code></pre></div></div><p>但是，如果我们对此实例使用同步：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>synchronized (lock) {
    System.out.println(ClassLayout.parseInstance(lock).toPrintable());
}
</code></pre></div></div><p>内存布局更改为：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Lock object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           f0 78 12 03
      4     4        (object header)                           00 70 00 00
      8     4        (object header)                           85 23 02 f8
     12     4        (loss due to the next object alignment)
</code></pre></div></div><p>如上所示，<strong>当我们使用monitor lock时（代码块中的synchronized由monitorenter和monitorexit指令显示实现，方法上的synchronized由ACC_SYNCHRONIZED标记隐式依赖monitor对象），mark的bit-pattern会发生变化。</strong></p><h4 id="年龄和寿命">年龄和寿命</h4><p><strong>为了将对象提升为老一代（当然，在分代GC中），JVM需要跟踪每个对象的生存周期。</strong> 如上所述，JVM还在mark中维护此信息。</p><p>为了模拟minor GC，我们将通过将对象分配给volatile变量来创建大量垃圾。这样，我们可以防止JIT编译器消除死代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">volatile</span> <span class="nc">Object</span> <span class="n">consumer</span><span class="o">;</span>
<span class="nc">Object</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
<span class="kt">long</span> <span class="n">lastAddr</span> <span class="o">=</span> <span class="no">VM</span><span class="o">.</span><span class="na">current</span><span class="o">().</span><span class="na">addressOf</span><span class="o">(</span><span class="n">instance</span><span class="o">);</span>
<span class="nc">ClassLayout</span> <span class="n">layout</span> <span class="o">=</span> <span class="nc">ClassLayout</span><span class="o">.</span><span class="na">parseInstance</span><span class="o">(</span><span class="n">instance</span><span class="o">);</span>
 
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10_000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">currentAddr</span> <span class="o">=</span> <span class="no">VM</span><span class="o">.</span><span class="na">current</span><span class="o">().</span><span class="na">addressOf</span><span class="o">(</span><span class="n">instance</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">currentAddr</span> <span class="o">!=</span> <span class="n">lastAddr</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">layout</span><span class="o">.</span><span class="na">toPrintable</span><span class="o">());</span>
    <span class="o">}</span>
 
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">10_000</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">consumer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
    <span class="o">}</span>
 
    <span class="n">lastAddr</span> <span class="o">=</span> <span class="n">currentAddr</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p><strong>每当有生命物体的地址发生变化时，这可能是由于minor GC和survivor区之间的移动所导致。</strong> 对于每次更改，我们还将打印新的对象布局以查看老化的对象。</p><p>这是mark的前4个字节随时间变化的方式：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>09 00 00 00 (00001001 00000000 00000000 00000000)
              ^^^^
11 00 00 00 (00010001 00000000 00000000 00000000)
              ^^^^
19 00 00 00 (00011001 00000000 00000000 00000000)
              ^^^^
21 00 00 00 (00100001 00000000 00000000 00000000)
              ^^^^
29 00 00 00 (00101001 00000000 00000000 00000000)
              ^^^^
31 00 00 00 (00110001 00000000 00000000 00000000)
              ^^^^
31 00 00 00 (00110001 00000000 00000000 00000000)
              ^^^^
</code></pre></div></div><h4 id="伪共享和-contended-注解">伪共享和 @Contended 注解</h4><p><code class="language-plaintext highlighter-rouge">jdk.internal.vm.annotation.Contended</code>注解（或Java 8上的sun.misc.Contended）是JVM隔离带注解的字段以避免<a href="https://alidg.me/blog/2020/4/24/thread-local-random#false-sharing">伪共享</a>的提示。</p><p>简而言之，<code class="language-plaintext highlighter-rouge">Contended</code>注解在每个带注解的字段周围添加了一些填充，以将每个字段隔离在其自己的缓存行上。因此，这将影响内存布局。</p><p>为了更好地理解这一点，让我们看一个示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Isolated</span> <span class="o">{</span>
 
    <span class="nd">@Contended</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">v1</span><span class="o">;</span>
 
    <span class="nd">@Contended</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">v2</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>如果我们检查此类的内存​​布局，则会看到类似以下内容的内容：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Isolated object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0    12        (object header)                           N/A
     12   128        (alignment/padding gap)                  
    140     4    int Isolated.i                                N/A
    144   128        (alignment/padding gap)                  
    272     8   long Isolated.l                                N/A
Instance size: 280 bytes
Space losses: 256 bytes internal + 0 bytes external = 256 bytes total
</code></pre></div></div><p>如上所示，JVM在每个带注解的字段周围添加了128个字节的填充。<strong>大多数现代计算机中的缓存行大小约为64/128字节，因此填充为128字节。</strong> 当然，我们可以使用<code class="language-plaintext highlighter-rouge">-XX:ContendedPaddingWidth</code>调整标志来控制Contended填充大小。</p><p>请注意，<code class="language-plaintext highlighter-rouge">Contended</code>注解是JDK内部的，因此我们应避免使用它。</p><p>此外，我们应该使用<code class="language-plaintext highlighter-rouge">-XX:-RestrictContended</code>调整标志来运行代码；否则，注解将不会生效。基本上，默认情况下，此注解仅用于内部使用，并且禁用RestrictContended将为公共API解锁此功能。</p><h4 id="数组">数组</h4><p>如前所述，数组长度也是数组oop的一部分。例如，对于包含3个元素的布尔数组：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span><span class="o">[]</span> <span class="n">booleans</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">3</span><span class="o">];</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">ClassLayout</span><span class="o">.</span><span class="na">parseInstance</span><span class="o">(</span><span class="n">booleans</span><span class="o">).</span><span class="na">toPrintable</span><span class="o">());</span>
</code></pre></div></div><p>内存布局如下所示：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Z object internals:
 OFFSET  SIZE      TYPE DESCRIPTION                               VALUE
      0     4           (object header)                           01 00 00 00 # mark
      4     4           (object header)                           00 00 00 00 # mark
      8     4           (object header)                           05 00 00 f8 # klass
     12     4           (object header)                           03 00 00 00 # array length
     16     3   boolean [Z.&lt;elements&gt;                             N/A
     19     5           (loss due to the next object alignment)
Instance size: 24 bytes
Space losses: 0 bytes internal + 5 bytes external = 5 bytes total
</code></pre></div></div><p>在这里，我们有16个字节的对象头，其中包含8个字节的mark，4个字节的klass和4个字节的长度。在对象头之后，我们有3个字节的布尔数组包含3个元素。</p><h4 id="压缩引用">压缩引用</h4><p>到目前为止，我们的示例在启用了压缩引用的64位架构中执行。</p><p>对齐8个字节后，我们最多可以使用32GB的带有压缩引用的堆（我们可以使用压缩指针计算最大可能的堆大小，超过则指针压缩会失效）。如果我们超出此限制，或者甚至手动禁用压缩引用，那么klass字将占用8个字节而不是4个字节。</p><p>让我们看一下使用<code class="language-plaintext highlighter-rouge">-XX:-UseCompressedOops</code>调整标志禁用压缩的oop时同一数组示例的内存布局：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Z object internals:
 OFFSET  SIZE      TYPE DESCRIPTION                               VALUE
      0     4           (object header)                           01 00 00 00 # mark
      4     4           (object header)                           00 00 00 00 # mark
      8     4           (object header)                           28 60 d2 11 # klass
     12     4           (object header)                           01 00 00 00 # klass
     16     4           (object header)                           03 00 00 00 # length
     20     4           (alignment/padding gap)                  
     24     3   boolean [Z.&lt;elements&gt;                             N/A
     27     5           (loss due to the next object alignment)
</code></pre></div></div><p>如预计的那样，klass现在还有4个字节。</p><h3 id="总结">总结</h3><p>在本教程中，我们了解了JVM如何在堆中布置对象和数组。</p><p>要进行更详细的探索，强烈建议您查看JVM源代码的<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/oops/">oops</a>部分。另外，AlekseyShipilëv在此领域有<a href="https://shipilev.net/jvm/objects-inside-out/">更深入的文章</a>。</p><p>此外，JOL的更多示例 可作为项目源代码的一部分获得。</p><p>原文：https://www.baeldung.com/java-memory-layout</p><h3 id="mark-word-结构">Mark Word 结构</h3><p>Mark Word在64位虚拟机下，也就是占用64位大小即8个字节的空间。内具体容包括：</p><p><a href="https://github.com/openjdk/jdk15/blob/e208d9aa1f185c11734a07db399bab0be77ef15f/src/hotspot/share/oops/markWord.cpp">源码</a></p><ul><li>unused 未使用的</li><li>hashcode 上文提到的hash code，本文出现的hashcode都是指identity hash code</li><li>thread 偏向锁记录的线程标识</li><li>epoch 验证偏向锁有效性的时间戳</li><li>age 分代年龄</li><li>biased_lock 偏向锁标志</li><li>lock 锁标志</li><li>pointer_to_lock_record 轻量锁 lock record 指针</li><li>pointer_to_heavy weight_monitor 重量锁 monitor指针</li></ul><p>这部分和程序关系很大，下面是一些典型的问题：</p><p><strong>为什么晋升到老年代的年龄设置(XX:MaxTenuringThreshold)不能超过15 ？</strong></p><p>因为就给了age四个bit空间，最大就是1111（二进制）也就是15，多了没地方存。</p><p><strong>为什么你的synchronized锁住的对象，没有“传说中的”偏向锁优化 ？</strong></p><p>因为hashcode并不是对象实例化完就计算好的，是调用计算出来放在mark word里的。</p><p>你调用过hashcode方法（或者隐式调用：存到hashset里，map的key，调用了默认未经重写的toString()方法等等），把“坑位”占了，偏向锁想存的线程id没地方存了，自然就直接是轻量级锁了。（或者你只是单纯的测试的时候忘了加<code class="language-plaintext highlighter-rouge">-XX:BiasedLockingStartupDelay=0</code>了）</p><p><a href="https://www.baeldung.com/java-memory-layout">Memory Layout of Objects in Java</a></p><p><a href="https://juejin.im/post/6844904113306615822">“对象头(object header)”里知多少</a></p><p><a href="https://blog.codecentric.de/en/2014/02/35gb-heap-less-32gb-java-jvm-memory-oddities/">Why 35GB Heap is Less Than 32GB</a> 拥有35G内存机器的盆友对分配了32G堆内存的虚拟机进行的测试，发现能存储的内容反而更少了，也就是本文提到的指针压缩问题。</p><p><a href="https://gist.github.com/arturmkrtchyan/43d6135e8a15798cc46c">ObjectHeader.txt</a> 对象头在三种情况的布局(64位、64位压缩指针、32位)</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://jxnu-liguobin.github.io" target="_blank">梦境迷离</a></li><li>本文链接：<a href="https://jxnu-liguobin.github.io/java%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.html" target="_blank">https://jxnu-liguobin.github.io/java%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.html</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/java%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E8%99%9A%E6%', clientID: '061aadb5d449c0877d7d', clientSecret: '9aa7af7c248a7e36a07a86993e11a7acf7fbd353', repo: 'dreamylost-comments', owner: 'jxnu-liguobin', admin: ['jxnu-liguobin'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://jxnu-liguobin.github.io/assets/search_data.json?v=1617164836', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2019 <span title="梦境迷离">梦境迷离</span> <a href="http://www.beian.miit.gov.cn/publish/query/indexFirst.action" rel="nofollow" target="_blank">赣ICP备17017283号-1</a> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/jxnu-liguobin/jxnu-liguobin.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://jxnu-liguobin.github.io/" title="首页" target="">首页</a></li><li> <a href="https://jxnu-liguobin.github.io/categories/" title="分类" target="">分类</a></li><li> <a href="https://jxnu-liguobin.github.io/wiki/" title="维基" target="">维基</a></li><li> <a href="https://jxnu-liguobin.github.io/links/" title="链接" target="">链接</a></li><li> <a href="https://jxnu-liguobin.github.io/about/" title="关于" target="">关于</a></li><li><a href="https://jxnu-liguobin.github.io/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2019-09-20 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
