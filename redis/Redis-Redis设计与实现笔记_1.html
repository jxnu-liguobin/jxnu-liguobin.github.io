<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>Redis设计与实现笔记_1 &mdash; 梦境迷离</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="canonical" href="https://blog.dreamylost.cn/redis/Redis-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0_1.html"><link rel="alternate" type="application/atom+xml" title="梦境迷离" href="https://blog.dreamylost.cn/feed.xml"><link rel="shortcut icon" href="https://dreamylost.cn/favicon.ico"><meta property="og:title" content="Redis设计与实现笔记_1"><meta name="keywords" content="梦境迷离, jxnu-liguobin"><meta name="og:keywords" content="梦境迷离, jxnu-liguobin"><meta name="description" content=""><meta name="og:description" content=""><meta property="og:url" content="https://blog.dreamylost.cn/redis/Redis-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0_1.html"><meta property="og:site_name" content="梦境迷离"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-01-23"> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/main.js"></script> <script data-ad-client="ca-pub-8236444920328818" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://blog.dreamylost.cn/" title="梦境迷离"><span class="octicon octicon-mark-github"></span> 梦境迷离</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://blog.dreamylost.cn/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://blog.dreamylost.cn/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://blog.dreamylost.cn/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://blog.dreamylost.cn/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://blog.dreamylost.cn/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="Redis设计与实现笔记_1"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">Redis设计与实现笔记_1</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/01/23 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://blog.dreamylost.cn/categories/#Redis" title="Redis">Redis</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 5030 字，约 15 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"> <img style="height:72px;width:72px" src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/images/qrcode.jpg" alt="梦境迷离" /></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" > <ins class="adsbygoogle content-header-ad" data-ad-client="ca-pub-8236444920328818" data-ad-slot="3977594606"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> <br /><article class="article-content markdown-body"><ul id="markdown-toc"><li><a href="#1字符串" id="markdown-toc-1字符串">1.字符串</a></li><li><a href="#2链表" id="markdown-toc-2链表">2.链表</a></li><li><a href="#3字典" id="markdown-toc-3字典">3.字典</a></li><li><a href="#4跳跃表" id="markdown-toc-4跳跃表">4.跳跃表</a></li><li><a href="#5整数集合" id="markdown-toc-5整数集合">5.整数集合</a></li><li><a href="#6压缩列表" id="markdown-toc-6压缩列表">6.压缩列表</a></li><li><a href="#7对象" id="markdown-toc-7对象">7.对象</a></li></ul><h3 id="1字符串">1.字符串</h3><ul><li>结构体 使用redis3.0源码，之后的源码由于考虑到内存对齐，结构体有多个。下面其他数据结构都是使用3.0的源码。<ul><li>sds.h/sdshdr</li></ul><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">struct</span> <span class="n">sdshdr</span> <span class="p">{</span>
     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span> <span class="c1">//记录buf中已经使用的数量，为sds保存的字符串的长度</span>
     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">free</span><span class="p">;</span> <span class="c1">//记录buf中未使用的数量</span>
     <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span> <span class="c1">//保存字符串</span>
  <span class="p">};</span>
</code></pre></div></div></li><li>使用场景 当Redis需要的不仅是一个字符串字面量，而是一个可以被修改的字符串值时，使用sds表示字符串值</li><li>常数时间复杂度获取字符串长度</li><li>杜绝缓冲区溢出</li><li>减少修改字符串长度时所需的内存分配次数<ul><li>增加时采用预分配策略</li><li>删除时采用惰性释放策略</li></ul></li><li>二进制安全</li><li>兼容部分C字符串函数</li></ul><h3 id="2链表">2.链表</h3><ul><li>结构体<ul><li>adlist.h/list</li><li>adlist.h/listNode</li></ul><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">typedef</span> <span class="k">struct</span> <span class="n">list</span> <span class="p">{</span>
     <span class="n">listNode</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span> <span class="c1">// 链表头指针</span>
     <span class="n">listNode</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span> <span class="c1">// 链表尾指针</span>
     <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">dup</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span> <span class="c1">//节点复制函数</span>
     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span> <span class="c1">//节点释放函数</span>
     <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span> <span class="c1">//节点对比函数，这三个函数用于为节点值设定特定类型的函数来实现保存不同类型的值。多态</span>
     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span> <span class="c1">//链表包含的节点数量</span>
  <span class="p">}</span> <span class="n">list</span><span class="p">;</span>
    
  <span class="k">typedef</span> <span class="k">struct</span> <span class="n">listNode</span> <span class="p">{</span>
     <span class="k">struct</span> <span class="n">listNode</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span> <span class="c1">//链表前置节点指针</span>
     <span class="k">struct</span> <span class="n">listNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span> <span class="c1">//链表后缀节点指针</span>
     <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span> <span class="c1">//链表的值</span>
  <span class="p">}</span> <span class="n">listNode</span><span class="p">;</span>
</code></pre></div></div></li><li>使用场景<ul><li>列表键包含数量比较多的元素，或列表中包含的元素都是长度比较长的字符串，使用链表作为列表键的底层实现</li></ul></li><li>双端链表，可以快速获取前置和后置节点，时间复杂度为O(1)</li><li>无环</li><li>使用list结构来持有listNode结构，list结构为链表提供了head、tail、len三个属性，可快速获取头尾和链表长度，时间复杂度为O(1)</li><li>list结构提供了dup、free、match三个属性，用于为节点值设置类型特点函数，故list可以用于存储各种不同类型的值</li></ul><h3 id="3字典">3.字典</h3><ul><li>结构体<ul><li>dict.h/dict 字典</li><li>dict.h/dictht 哈希表</li><li>dict.h/dictEntry 哈希表的节点</li><li>dict.h/dictType 用于设置哈希表节点的类型的结构</li></ul><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictEntry</span> <span class="p">{</span>
     <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span> <span class="c1">//哈希表的键值对中的键</span>
     <span class="k">union</span> <span class="p">{</span> <span class="c1">//哈希表的值，联合：同一时刻只能有一个成员允许含有一个值</span>
         <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>
         <span class="kt">uint64_t</span> <span class="n">u64</span><span class="p">;</span>
         <span class="kt">int64_t</span> <span class="n">s64</span><span class="p">;</span>
         <span class="kt">double</span> <span class="n">d</span><span class="p">;</span>
     <span class="p">}</span> <span class="n">v</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">dictEntry</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span> <span class="c1">//指向下一个哈希表节点，形成链表</span>
  <span class="p">}</span> <span class="n">dictEntry</span><span class="p">;</span>
    
  <span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictType</span> <span class="p">{</span>
     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">hashFunction</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span> <span class="c1">//哈希函数</span>
     <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">keyDup</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span> <span class="c1">//键复制函数</span>
     <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">valDup</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span> <span class="c1">//值复制函数</span>
     <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">keyCompare</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">);</span> <span class="c1">//键对比函数</span>
     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">keyDestructor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span> <span class="c1">//键析构函数</span>
     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">valDestructor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span> <span class="c1">//值析构函数</span>
  <span class="p">}</span> <span class="n">dictType</span><span class="p">;</span>
    
  <span class="cm">/* This is our hash table structure. Every dictionary has two of this as we
   * implement incremental rehashing, for the old to the new table. */</span>
  <span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictht</span> <span class="p">{</span>
      <span class="n">dictEntry</span> <span class="o">**</span><span class="n">table</span><span class="p">;</span> <span class="c1">//哈希表数组</span>
      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span> <span class="c1">//哈希表大小</span>
      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sizemask</span><span class="p">;</span> <span class="c1">//哈希表大小掩码，用于计算索引，总是为size-1</span>
      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">used</span><span class="p">;</span> <span class="c1">//记录哈希表已有节点的数量</span>
  <span class="p">}</span> <span class="n">dictht</span><span class="p">;</span>
    
  <span class="k">typedef</span> <span class="k">struct</span> <span class="n">dict</span> <span class="p">{</span>
      <span class="n">dictType</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span> <span class="c1">//类型特点函数</span>
      <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">;</span> <span class="c1">//私有数据</span>
      <span class="n">dictht</span> <span class="n">ht</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">//2个哈希表，一个用于重哈希</span>
      <span class="kt">long</span> <span class="n">rehashidx</span><span class="p">;</span> <span class="cm">/* rehashing not in progress if rehashidx == -1 */</span> <span class="c1">//rehash索引</span>
      <span class="kt">int</span> <span class="n">iterators</span><span class="p">;</span> <span class="cm">/* number of iterators currently running */</span>
  <span class="p">}</span> <span class="n">dict</span>
</code></pre></div></div></li><li>使用场景<ul><li>哈希键包含的键值对比较多，或键值对中的元素的都是比较长的字符串，使用字典作为哈希键的底层实现</li><li>Redis数据库</li></ul></li><li>每个字典有两个哈希表<ul><li>ht[0] 平时使用，rehash时，包含的键值对数量只减不增</li><li>ht[1] rehash时使用，在字典查找键时，先在ht[0]中找，再到ht[1]中找</li><li>删改查需要操作两个ht，新增仅操作ht[1]</li></ul></li><li>rehash并非一次性完成，而是渐进式地完成<ul><li>使用rehashidx实现渐进式rehash<ul><li>初始为-1，开始rehash时置为0</li><li>每次增删改查操作都递增1</li><li>完成rehash时，置为-1</li></ul></li></ul></li><li>使用MurmurHash2算法来计算键的哈希值</li><li>哈希表使用链地址法来解决哈希冲突，同一索引上的多个键值对会被连接成一个单向链表<ul><li>链表采用头插法</li></ul></li><li>哈希表的自适操作<ul><li>拓展<ul><li>服务器当前没有在执行bgsave或bgrewriteaof且负载因子大于等于1</li><li>服务器当前正在执行bgsave或bgrewriteaof且负载因子大于等于5</li></ul></li><li>收缩<ul><li>哈希表的负载因子小于0.1</li></ul></li></ul></li><li>rehash步骤<ul><li>为ht[1]分配空间，空间大小取决于要执行的操作和ht[0]当前包含的键值对数量（ht[0].used属性的值）</li><li>将保存在ht[0]中的所有键值对rehash到ht[1]上，rehash指的是重新计算索引值和哈希值</li><li>当ht[0]包含的所有键值对都迁移到了ht[1]后，ht[0]变为空表，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下次rehash准备</li></ul></li></ul><h3 id="4跳跃表">4.跳跃表</h3><ul><li>结构体<ul><li>server.h/zskiplist 3.0及以下版本在redis.h中</li><li>server.h/zskiplistNode</li></ul><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cm">/* ZSETs use a specialized version of Skiplists */</span>
  <span class="k">typedef</span> <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="p">{</span>
    <span class="n">robj</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span> <span class="c1">//成员对象</span>
    <span class="kt">double</span> <span class="n">score</span><span class="p">;</span> <span class="c1">//分值</span>
    <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">backward</span><span class="p">;</span> <span class="c1">//后退指针</span>
    <span class="k">struct</span> <span class="n">zskiplistLevel</span> <span class="p">{</span> <span class="c1">//跳跃表的层</span>
        <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">forward</span><span class="p">;</span> <span class="c1">//前进指针</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">span</span><span class="p">;</span> <span class="c1">//跨度</span>
    <span class="p">}</span> <span class="n">level</span><span class="p">[];</span>
  <span class="p">}</span> <span class="n">zskiplistNode</span><span class="p">;</span>
    
  <span class="k">typedef</span> <span class="k">struct</span> <span class="n">zskiplist</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">zskiplistNode</span> <span class="o">*</span><span class="n">header</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span> <span class="c1">//表头和表尾节点</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">length</span><span class="p">;</span> <span class="c1">//表中节点的数量</span>
    <span class="kt">int</span> <span class="n">level</span><span class="p">;</span> <span class="c1">//表中层数最大的节点的层数</span>
  <span class="p">}</span> <span class="n">zskiplist</span><span class="p">;</span>
</code></pre></div></div></li><li>使用场景<ul><li>有序集合包含的元素比较多，或有序集合中元素的成员是比较长的字符串（即zskiplistNode的obj属性），使用跳跃表作为有序集合的底层实现</li></ul></li><li>Redis的跳跃表由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（表头、表尾、长度），而zskiplistNode则用于表示跳跃表节点</li><li>每个跳跃表的层高都是1至32之间的随机数</li><li>同一个跳跃表中，多个节点可以保护相同的值，但每个节点的成员对象必须是唯一的</li><li>跳跃表的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序（字典序）</li></ul><h3 id="5整数集合">5.整数集合</h3><ul><li>结构体<ul><li>intset.h/intset</li></ul><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">typedef</span> <span class="k">struct</span> <span class="n">intset</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">encoding</span><span class="p">;</span> <span class="c1">//编码方式</span>
    <span class="kt">uint32_t</span> <span class="n">length</span><span class="p">;</span> <span class="c1">//集合包含的元素数量</span>
    <span class="kt">int8_t</span> <span class="n">contents</span><span class="p">[];</span> <span class="c1">//保存元素的数组，取决于encoding的值，会升级</span>
  <span class="p">}</span> <span class="n">intset</span><span class="p">;</span>
</code></pre></div></div></li><li>使用场景<ul><li>当集合只包含整数值的元素，并且这个集合元素的数量不多时，使用整数集合作为集合键的底层实现</li></ul></li><li>整数集合底层实现为数组，这个数组以有序，无重复的方式保存元素，在有需要时会根据添加的元素的类型，改变这个数组的类型</li><li>整数集合的升级<ul><li>提升操作上的灵活性</li><li>尽可能地节约内存</li><li>不支持降级</li></ul></li></ul><h3 id="6压缩列表">6.压缩列表</h3><ul><li>结构体<ul><li>无</li></ul></li><li>使用场景<ul><li>列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，使用压缩列表作为底层实现</li><li>哈希键只包含少量键值对，并且每个键和值要么就是小整数值，要么就是长度比较短的字符串，使用压缩列表作为底层实现</li></ul></li><li>为节约内存而开发的顺序型数据结构（本身无新定义的结构体）</li><li>可以包含多个节点，每个节点可以保存一个字节数组或整数值</li><li>添加新节点到压缩列表，或从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作的出现几率并不高<ul><li>连锁更新<ul><li>指增加或删除压缩列表的节点后，引发的必须更新previous_entry_length属性的操作</li><li>最坏需要N次空间重分配操作</li><li>每次分配的最坏复杂度为O(N)，故连锁更新的最坏复杂度为O(N^2)</li><li>压缩列表里要恰好有多个连续的、长度介于250~253字节之间的节点，才可能引发连锁更新，实际并不多见</li><li>即使出现连锁更新，但被更新的元素不多，也不会对性能造成影响</li><li>ziplistPush等命令的平均复杂度为O(N)</li></ul></li></ul></li><li>压缩列表的节点<ul><li>previous_entry_length 记录前一个节点的长度，可以为1或5，单位字节<ul><li>前一节点的长度小于254字节，previous_entry_length属性需要用1字节长空间来保存这个值</li><li>前一节点的长度大于等于254字节，previous_entry_length属性需要用5字节长空间来保存这个值</li></ul></li><li>encoding 记录了节点的content属性保存的数据的类型和长度，可以为1，2，5，单位字节（整数仅使用1字节，整数编码6种，字节数组编码3种，最高两位总是作为编码的类型）</li><li>content 节点的值，可以为整数或字节数组，值的类型和长度由encoding属性决定</li></ul></li></ul><h3 id="7对象">7.对象</h3><ul><li>结构体<ul><li>server.h/redisObject 3.0及以下版本在redis.h中</li></ul><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisObject</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">type</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span> <span class="c1">//对象类型</span>
    <span class="kt">unsigned</span> <span class="n">encoding</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span> <span class="c1">//编码</span>
    <span class="kt">unsigned</span> <span class="n">lru</span><span class="o">:</span><span class="n">LRU_BITS</span><span class="p">;</span> <span class="cm">/* lru time (relative to server.lruclock) */</span> <span class="c1">//记录LRU/LFU信息，与maxmemory选项和回收内存有关</span>
    <span class="kt">int</span> <span class="n">refcount</span><span class="p">;</span> <span class="c1">//引用计数</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="c1">//指向底层实现数据结构的指针</span>
  <span class="p">}</span> <span class="n">robj</span><span class="p">;</span>
</code></pre></div></div></li><li>与保存数据相关的三个属性<ul><li>type Redis对象底层使用的数据结构类型<ul><li>字符串对象（整数值、embstr编码的sds、sds）</li><li>列表对象（压缩列表、双端链表）</li><li>哈希对象（压缩列表、字典）</li><li>集合对象（整数集、字典）</li><li>有序集合对象（压缩列表、跳跃表和字典）</li></ul></li><li>encoding 记录对象所使用的编码（每个编码对应一种底层结构）</li><li>ptr 指向底层实现数据结构的指针</li></ul></li><li>Redis数据库中的每个键值对的键和值都是一个对象</li><li>Redis有上述五种类型的对象，每种类型至少有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率</li><li>服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令（检查键的值对象的类型）</li><li>Redis的对象系统使用带有引用计数实现的内存回收机制，当一个对象不再被使用，对象所占用的内存会被自动释放</li><li>Redis会共享0~9999的字符串的对象</li><li>对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间（空转时间=当前时间-lru属性的时间）</li></ul><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://blog.dreamylost.cn" target="_blank">梦境迷离</a></li><li>本文链接：<a href="https://blog.dreamylost.cn/redis/Redis-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0_1.html" target="_blank">https://blog.dreamylost.cn/redis/Redis-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0_1.html</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/redis/Redis-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A', clientID: '061aadb5d449c0877d7d', clientSecret: '9aa7af7c248a7e36a07a86993e11a7acf7fbd353', repo: 'dreamylost-comments', owner: 'jxnu-liguobin', admin: ['jxnu-liguobin'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@built/assets/search_data.json?v=1669375354', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"> <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-8236444920328818" data-ad-slot="6220614560" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2019 <span title="梦境迷离">梦境迷离</span> <a href="http://www.beian.miit.gov.cn/publish/query/indexFirst.action" rel="nofollow" target="_blank">赣ICP备17017283号-1</a> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/jxnu-liguobin/jxnu-liguobin.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://blog.dreamylost.cn/" title="首页" target="">首页</a></li><li> <a href="https://blog.dreamylost.cn/categories/" title="分类" target="">分类</a></li><li> <a href="https://blog.dreamylost.cn/wiki/" title="维基" target="">维基</a></li><li> <a href="https://blog.dreamylost.cn/links/" title="链接" target="">链接</a></li><li> <a href="https://blog.dreamylost.cn/about/" title="关于" target="">关于</a></li><li><a href="https://blog.dreamylost.cn/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2019-09-20 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-147390701-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
