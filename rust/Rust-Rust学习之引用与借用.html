<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>Rust学习之引用和借用 &mdash; 梦境迷离</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="canonical" href="https://blog.dreamylost.cn/rust/Rust-Rust%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8.html"><link rel="alternate" type="application/atom+xml" title="梦境迷离" href="https://blog.dreamylost.cn/feed.xml"><link rel="shortcut icon" href="https://dreamylost.cn/favicon.ico"><meta property="og:title" content="Rust学习之引用和借用"><meta name="keywords" content="梦境迷离, jxnu-liguobin"><meta name="og:keywords" content="梦境迷离, jxnu-liguobin"><meta name="description" content=""><meta name="og:description" content=""><meta property="og:url" content="https://blog.dreamylost.cn/rust/Rust-Rust%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8.html"><meta property="og:site_name" content="梦境迷离"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2020-01-15"> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/main.js"></script> <script data-ad-client="ca-pub-8236444920328818" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://blog.dreamylost.cn/" title="梦境迷离"><span class="octicon octicon-mark-github"></span> 梦境迷离</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://blog.dreamylost.cn/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://blog.dreamylost.cn/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://blog.dreamylost.cn/archives/" class=" site-header-nav-item" target="" title="归档">归档</a> <a href="https://blog.dreamylost.cn/open-source/" class=" site-header-nav-item" target="" title="开源">开源</a> <a href="https://blog.dreamylost.cn/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://blog.dreamylost.cn/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://blog.dreamylost.cn/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="Rust学习之引用和借用"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">Rust学习之引用和借用</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2020/01/15 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://blog.dreamylost.cn/categories/#Rust" title="Rust">Rust</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 4543 字，约 13 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"> <img style="height:72px;width:72px" src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/images/qrcode.jpg" alt="梦境迷离" /></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><ul id="markdown-toc"><li><a href="#引用和出借" id="markdown-toc-引用和出借">引用和出借</a><ul><li><a href="#可变引用" id="markdown-toc-可变引用">可变引用</a></li><li><a href="#悬垂引用" id="markdown-toc-悬垂引用">悬垂引用</a></li><li><a href="#引用规则" id="markdown-toc-引用规则">引用规则</a></li></ul></li></ul><h1 id="引用和出借">引用和出借</h1><p>前面所有权部分，最后一个例子，我们必须将String返回给调用函数，因此我们仍然可以在调用calculate_length之后使用String。因为该字符串已被移入calculate_length函数。 出借就是借用的意思（borrow）。</p><p>下面将演示您将如何定义和使用对象的引用作为calculate_length函数的参数，而不是获取值的所有权</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
    <span class="c">//类似c/c++传递指针/引用</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="nf">calculate_length</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span>
    <span class="c">//s1在之后还能使用</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"The length of '{}' is {}."</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">calculate_length</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">s</span><span class="nf">.len</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div><p>首先，请注意，变量声明和函数返回值中的所有元组代码都消失了。其次，请注意，我们将＆s1传递给calculate_length，并且在其定义中，我们采用＆String而不是String。</p><p>这些&amp;符号是引用（指针，下面引用都可以认为是指针），它们使您可以引用某些值而无需拥有所有权。下面是一个示意图</p><p><img src="../../public/image/reference-1.png" alt="" /></p><p>&amp;String s 指向 String s1</p><blockquote><p>与＆相反的是取消引用，这是通过运算符*完成的。这里与c指针用法类似。</p></blockquote><p>让我们仔细看看这里的函数调用</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>

<span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="nf">calculate_length</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span>
</code></pre></div></div><p>通过＆s1语法，我们可以创建引用s1的引用，但该引用不属于s1。因为它不拥有它，所以当引用超出范围时，它所指向的值将不会被删除。</p><p>同样，函数的签名使用＆表示参数s的类型是引用。让我们添加一些说明性注释</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">calculate_length</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span> <span class="c">// s是对字符串的引用</span>
    <span class="n">s</span><span class="nf">.len</span><span class="p">()</span>
<span class="p">}</span> <span class="c">// 在这里，s超出范围。但是因为它没有什么所有权，所以它没有发生什么。</span>
</code></pre></div></div><p>变量s有效的作用域与任何函数参数的作用域相同，但是当它超出作用域时，由于没有所有权，我们不会删除引用指向的内容。当函数使用引用作为参数而不是实际值作为参数时，我们将不需要返回这些值来归还所有权，因为我们从未拥有过所有权。</p><p>我们称拥有引用为函数参数借用。与现实生活中一样，如果某人拥有某物，则可以向他们借用。完成后，您必须将其归还。</p><p>那么，如果我们尝试修改要借用的内容会怎样？</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>

    <span class="nf">change</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">change</span><span class="p">(</span><span class="n">some_string</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">some_string</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">", world"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>尝试修改借的值将会报错</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error[E0596]: cannot borrow immutable borrowed content `*some_string` as mutable
 --&gt; error.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- use `&amp;mut String` here to make mutable
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^ cannot borrow as mutable
</code></pre></div></div><p>正如变量在默认情况下是不可变的一样，引用也是如此。我们不允许修改引用的内容。如果非要改则需要使用&amp;mut String。</p><h2 id="可变引用">可变引用</h2><p>我们只需稍作调整就可以解决上面的编译错误。</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>

    <span class="nf">change</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">change</span><span class="p">(</span><span class="n">some_string</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">some_string</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">", world"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>首先，我们必须将s更改为mut。然后，我们必须使用＆mut s创建一个可变引用，并使用some_string: ＆mut String接受一个可变引用。</p><p>但是可变引用有一个很大的限制：您只能在一个特定范围内对一个特定的数据进行一个可变引用。此代码将会失败：</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>

<span class="k">let</span> <span class="n">r1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">;</span>
<span class="k">let</span> <span class="n">r2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">;</span><span class="c">//可变引用只能被出借一次，这里将会报错</span>

<span class="nd">println!</span><span class="p">(</span><span class="s">"{}, {}"</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">);</span>
</code></pre></div></div><p>编译该代码会出错</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here
</code></pre></div></div><p>该限制允许变动，但是以一种可控的方式。新的Rustaceans很难解决这一问题，因为大多数语言都允许您随时更改。</p><p>具有此限制的好处是Rust可以防止在编译时发生数据争用。数据争用类似于争用条件，并且在以下三种行为发生时发生：</p><ul><li>两个或多个指针同时访问相同的数据。</li><li>至少有一个指针用于写入数据。</li><li>没有用于同步访问数据的机制。</li></ul><p>数据争用会导致未定义的行为，并且尝试在运行时进行跟踪时可能难以诊断和修复； Rust不会发生此问题，因为它甚至不会在数据竞争中编译代码！</p><p>与往常一样，我们可以使用大括号创建新的范围，从而允许多个可变引用，而不是同时引用：</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>

<span class="p">{</span>
    <span class="k">let</span> <span class="n">r1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">;</span>

<span class="p">}</span> <span class="c">// r1在这里超出范围，因此我们可以毫无问题地进行新引用。</span>

<span class="k">let</span> <span class="n">r2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">;</span>
</code></pre></div></div><p>对于组合可变引用和不可变引用，存在类似的规则。此代码会导致错误：</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>

<span class="k">let</span> <span class="n">r1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">;</span> <span class="c">// 没问题，与上面两次mut出借不一样，这里是没有mut，所以对于不可变引用，可以使用多次次，且不可在拥有不可变引用时同时拥有可变引用</span>
<span class="k">let</span> <span class="n">r2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">;</span> <span class="c">// 没问题</span>
<span class="k">let</span> <span class="n">r3</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">;</span> <span class="c">// 有问题</span>

<span class="nd">println!</span><span class="p">(</span><span class="s">"{}, {}, and {}"</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span><span class="p">);</span>
</code></pre></div></div><p>编译将会出现下面错误</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; 
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; 
6 |     let r3 = &amp;mut s; 
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{}, {}, and {}", r1, r2, r3);
  |                                -- immutable borrow later used here
</code></pre></div></div><p>当我们拥有不变的引用时，我们也不能拥有可变的引用。不变引用的用户不会期望值从它们下面突然改变！但是，可以使用多个不可变的引用，因为没有人会影响其他人对数据的读取。</p><blockquote><p>请注意，引用的范围从引入它的地方开始，一直持续到最后一次使用该引用。例如，该代码将被编译，因为不可变引用的最后一次使用发生在引入可变引用之前：</p></blockquote><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>

<span class="k">let</span> <span class="n">r1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">;</span> <span class="c">// 没问题</span>
<span class="k">let</span> <span class="n">r2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">;</span> <span class="c">// 没问题</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{} and {}"</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">);</span>
<span class="c">// 在此之后不再使用r1和r2</span>

<span class="k">let</span> <span class="n">r3</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">;</span> <span class="c">// 没问题，因为r1 r2进入println! 并且在此之后会失效</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">r3</span><span class="p">);</span>
</code></pre></div></div><p>不可变引用r1和r2的范围在println! 之后结束。在创建可变引用r3之前，在最后一次使用它们的位置。这些范围不重叠，因此允许使用此代码。</p><p>即使借用错误有时可能令人沮丧，但请记住，Rust编译器尽早（在编译时而不是在运行时）指出了潜在的错误，并向您确切地指出了问题所在。然后，您不必追踪为什么数据不是您想像的那样。</p><h2 id="悬垂引用">悬垂引用</h2><p>在带有指针的语言中，很容易错误地创建一个悬垂指针，即在保留指向该内存的指针的同时释放一些引用（可能已分配给其他人的内存中的位置的指针）。相比之下，在Rust中，编译器保证引用永远不会成为悬垂引用：如果您对某些数据有引用，则编译器将确保数据不会超出对数据的引用范围。</p><p>让我们尝试创建一个悬垂的引用，Rust将通过编译时错误防止该引用：</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">reference_to_nothing</span> <span class="o">=</span> <span class="nf">dangle</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">dangle</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">String</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>

    <span class="o">&amp;</span><span class="n">s</span>
<span class="p">}</span>
</code></pre></div></div><p>编译该代码将会出现编译错误</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error[E0106]: missing lifetime specifier
 --&gt; main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is
  no value for it to be borrowed from
  = help: consider giving it a 'static lifetime
</code></pre></div></div><p>此错误消息指的是我们尚未讨论的功能：生命周期。但是，如果您忽略有关生命周期的部分，则该消息的确包含了导致此代码出现问题的关键：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>this function's return type contains a borrowed value, but there is no value
for it to be borrowed from.
</code></pre></div></div><p>让我们仔细研究一下悬挂代码的每个阶段到底发生了什么：</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">dangle</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">String</span> <span class="p">{</span> <span class="n">dangle</span><span class="err">返回字符串的引用</span>

    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span> <span class="c">// s 是一个新的字符串</span>

    <span class="o">&amp;</span><span class="n">s</span> <span class="c">// 我们返回字符串的引用 &amp;s</span>
<span class="p">}</span> <span class="c">// 在此，s超出范围，并被丢弃。它的内存被释放了。</span>
</code></pre></div></div><p>因为s是在dangle内部创建的，所以当dangle的代码完成时，将释放s。但是我们试图返回对它的引用。这意味着该引用将指向无效的String。Rust不允许我们这样做。</p><p>解决方案是直接返回String：</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">no_dangle</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
    <span class="n">s</span>
<span class="p">}</span>
</code></pre></div></div><p>这可以正常工作。所有权被移出，没有任何东西被释放。</p><h2 id="引用规则">引用规则</h2><p>让我们回顾一下我们对引用的讨论：</p><ul><li>在任何给定时间，您都可以具有一个可变引用或任意数量的不可变引用。</li><li>引用必须始终有效。</li></ul><p><a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">引用与借用 原文 英文</a></p><p>可能存在部分理解不到位或有问题的地方，仅供参考。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://blog.dreamylost.cn" target="_blank">梦境迷离</a></li><li>本文链接：<a href="https://blog.dreamylost.cn/rust/Rust-Rust%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8.html" target="_blank">https://blog.dreamylost.cn/rust/Rust-Rust%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8.html</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/rust/Rust-Rust%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%9', clientID: '061aadb5d449c0877d7d', clientSecret: '9aa7af7c248a7e36a07a86993e11a7acf7fbd353', repo: 'dreamylost-comments', owner: 'jxnu-liguobin', admin: ['jxnu-liguobin'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@built/assets/search_data.json?v=1702960985', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2019 <span title="梦境迷离">梦境迷离</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/jxnu-liguobin/jxnu-liguobin.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://blog.dreamylost.cn/" title="首页" target="">首页</a></li><li> <a href="https://blog.dreamylost.cn/categories/" title="分类" target="">分类</a></li><li> <a href="https://blog.dreamylost.cn/archives/" title="归档" target="">归档</a></li><li> <a href="https://blog.dreamylost.cn/open-source/" title="开源" target="">开源</a></li><li> <a href="https://blog.dreamylost.cn/wiki/" title="维基" target="">维基</a></li><li> <a href="https://blog.dreamylost.cn/links/" title="链接" target="">链接</a></li><li> <a href="https://blog.dreamylost.cn/about/" title="关于" target="">关于</a></li><li><a href="https://blog.dreamylost.cn/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2019-09-20 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
