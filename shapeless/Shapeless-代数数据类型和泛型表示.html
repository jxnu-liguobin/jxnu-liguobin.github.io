<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>代数数据类型和泛型表示 &mdash; 梦境迷离</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="canonical" href="https://blog.dreamylost.cn/shapeless/Shapeless-%E4%BB%A3%E6%95%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%B3%9B%E5%9E%8B%E8%A1%A8%E7%A4%BA.html"><link rel="alternate" type="application/atom+xml" title="梦境迷离" href="https://blog.dreamylost.cn/feed.xml"><link rel="shortcut icon" href="https://dreamylost.cn/favicon.ico"><meta property="og:title" content="代数数据类型和泛型表示"><meta name="keywords" content="梦境迷离, jxnu-liguobin"><meta name="og:keywords" content="梦境迷离, jxnu-liguobin"><meta name="description" content=""><meta name="og:description" content=""><meta property="og:url" content="https://blog.dreamylost.cn/shapeless/Shapeless-%E4%BB%A3%E6%95%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%B3%9B%E5%9E%8B%E8%A1%A8%E7%A4%BA.html"><meta property="og:site_name" content="梦境迷离"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2020-06-20"> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/main.js"></script> <script data-ad-client="ca-pub-8236444920328818" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://blog.dreamylost.cn/" title="梦境迷离"><span class="octicon octicon-mark-github"></span> 梦境迷离</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://blog.dreamylost.cn/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://blog.dreamylost.cn/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://blog.dreamylost.cn/archives/" class=" site-header-nav-item" target="" title="归档">归档</a> <a href="https://blog.dreamylost.cn/open-source/" class=" site-header-nav-item" target="" title="开源">开源</a> <a href="https://blog.dreamylost.cn/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://blog.dreamylost.cn/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://blog.dreamylost.cn/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="代数数据类型和泛型表示"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">代数数据类型和泛型表示</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2020/06/20 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://blog.dreamylost.cn/categories/#Shapeless" title="Shapeless">Shapeless</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 6946 字，约 20 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"> <img style="height:72px;width:72px" src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/images/qrcode.jpg" alt="梦境迷离" /></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" > <ins class="adsbygoogle content-header-ad" data-ad-client="ca-pub-8236444920328818" data-ad-slot="3977594606"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> <br /><article class="article-content markdown-body"><ul id="markdown-toc"><li><a href="#21-概述adt" id="markdown-toc-21-概述adt">2.1 概述：ADT</a><ul><li><a href="#211-adt的其它编码方式" id="markdown-toc-211-adt的其它编码方式">2.1.1 ADT的其它编码方式</a></li></ul></li><li><a href="#22-乘积类型product泛型编码" id="markdown-toc-22-乘积类型product泛型编码">2.2 乘积类型（product）泛型编码</a><ul><li><a href="#221-使用generic转换泛型表示" id="markdown-toc-221-使用generic转换泛型表示">2.2.1 使用Generic转换泛型表示</a></li></ul></li><li><a href="#23-余积类型coproduct泛型编码" id="markdown-toc-23-余积类型coproduct泛型编码">2.3 余积类型（coproduct）泛型编码</a></li><li><a href="#231-使用generic转换泛型编码" id="markdown-toc-231-使用generic转换泛型编码">2.3.1 使用Generic转换泛型编码</a></li><li><a href="#24-小结" id="markdown-toc-24-小结">2.4 小结</a></li></ul><blockquote><p>在线电子书 https://dreamylost.gitbook.io/dreamylost/</p></blockquote><blockquote><p>shapeless v2.3.2</p></blockquote><p>泛型编程主要思想是指用少量的泛型代码解决多种类型问题，为此shapeless提供了两种工具：</p><ol><li>能够在类型级别进行检查（inspected）、访问（traversed）、修改（manipulated）的一系列泛型数据类型；</li><li>能够在代数数据类型（简称ADT，Scala中的样例类和密封特质）和泛型表示之间的自动映射。</li></ol><p>我们先简单介绍一下代数数据类型（ADT）相关理论以及为什么Scala开发者对它如此熟悉，并以此来开始本章。我们还会讲解shapeless如何使用泛型表示，之后讨论如何使它们与实际的ADT相互映射。最后，我们会介绍能实现上述功能的Generic类型类，并介绍使用Generic进行不同类型之间的相互转换，并以此为简单示例来结束本章。</p><h2 id="21-概述adt">2.1 概述：ADT</h2><p>不用纠结代数数据类型（Algebraic data type）与抽象数据类型（abstract data type）的简写（ADT）相同，抽象数据类型是另一个计算机术语，它与代数数据类型不同。代数数据类型（ADT，下文简写为ADT）是面向函数编程的概念，它名字奇特但本质很简单，就是我们习惯上用“和”以及“或”来表达数据的方式。例如：</p><ul><li>一个图形的形状是矩形或圆形</li><li>矩形有宽和高两个属性</li><li>圆有一个半径属性</li></ul><p>在专有名词ADT中，我们称“矩形和圆形”中的这种“和”为乘积（product）（个人觉得此处他应该是指“宽和高”中的和），“一个图形的形状是矩形或圆形”这种“或”为余积（coproduct）。Scala中通常用样例类代表乘积类型，用密封特质代表余积类型。例如下述中Rectangle和Circle都是乘积类型，而Shape是余积类型：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Shape</span> 
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="n">width</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Shape</span> 
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Circle</span><span class="o">(</span><span class="n">radius</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Shape</span>

<span class="k">val</span> <span class="nv">rect</span><span class="k">:</span> <span class="kt">Shape</span> <span class="o">=</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="mf">3.0</span><span class="o">,</span> <span class="mf">4.0</span><span class="o">)</span> 
<span class="k">val</span> <span class="nv">circ</span><span class="k">:</span> <span class="kt">Shape</span> <span class="o">=</span> <span class="nc">Circle</span><span class="o">(</span><span class="mf">1.0</span><span class="o">)</span>
</code></pre></div></div><p>ADT之美就在于它是类型安全的。编译器能够完全理解我们定义的代号（alberas的意思是：像矩形和圆这种我们定义的符号；以及这些符号的操作规则或编码方法规则），所以这能帮助我们对自定义类型写出完整的、类型正确的方法。如下代码能正确处理传入的shape类型并计算其面积：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">area</span><span class="o">(</span><span class="n">shape</span><span class="k">:</span> <span class="kt">Shape</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> 
    <span class="n">shape</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">h</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">w</span> <span class="o">*</span> <span class="n">h</span> 
        <span class="k">case</span> <span class="nc">Circle</span><span class="o">(</span><span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">math</span><span class="o">.</span><span class="py">Pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">r</span> 
    <span class="o">}</span>

<span class="nf">area</span><span class="o">(</span><span class="n">rect</span><span class="o">)</span> 
<span class="c1">// res1: Double = 12.0</span>

<span class="nf">area</span><span class="o">(</span><span class="n">circ</span><span class="o">)</span> 
<span class="c1">// res5: Double = 3.141592653589793</span>
</code></pre></div></div><h3 id="211-adt的其它编码方式">2.1.1 ADT的其它编码方式</h3><p>虽然在Scala中编码方式不止一种，但密封特质和样例类毋庸置疑是ADT的最方便的编码方式。比如Scala标准库中就提供了用元组（Tuple）表式的泛型乘积类型以及用或（Either）表示的泛型余积类型。我们可以用这种方式来重写上面定义的Shape类。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Rectangle2</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Double</span><span class="o">,</span> <span class="nc">Double</span><span class="o">)</span>
<span class="k">type</span> <span class="kt">Circle2</span> <span class="o">=</span> <span class="nc">Double</span> 
<span class="k">type</span> <span class="kt">Shape2</span> <span class="o">=</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">Rectangle2</span>, <span class="kt">Circle2</span><span class="o">]</span>

<span class="k">val</span> <span class="nv">rect2</span><span class="k">:</span> <span class="kt">Shape2</span> <span class="o">=</span> <span class="nc">Left</span><span class="o">((</span><span class="mf">3.0</span><span class="o">,</span> <span class="mf">4.0</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">circ2</span><span class="k">:</span> <span class="kt">Shape2</span> <span class="o">=</span> <span class="nc">Right</span><span class="o">(</span><span class="mf">1.0</span><span class="o">)</span>
</code></pre></div></div><p>尽管这种编码方式没有上面介绍的样例类的方式易读，却有着相同的理念，我们仍然能写出对于Shape2的类型安全的操作方法。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">area2</span><span class="o">(</span><span class="n">shape</span><span class="k">:</span> <span class="kt">Shape2</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span>
    <span class="n">shape</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Left</span><span class="o">((</span><span class="n">w</span><span class="o">,</span> <span class="n">h</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">w</span> <span class="o">*</span> <span class="n">h</span> 
        <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">math</span><span class="o">.</span><span class="py">Pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">r</span> 
    <span class="o">}</span>

<span class="nf">area2</span><span class="o">(</span><span class="n">rect2</span><span class="o">)</span> 
<span class="c1">// res4: Double = 12.0</span>

<span class="nf">area2</span><span class="o">(</span><span class="n">circ2</span><span class="o">)</span> 
<span class="c1">// res5: Double = 3.141592653589793</span>
</code></pre></div></div><p>重要的是Shape2是一个比Shape更加“泛型”的编码方式（相比传统的“拥有类型参数的类型”而言，这里使用泛型一词不是那么正式）。如果一段代码能操作一对Double数据那么它也能操作Rectangle2，反之亦然。Scala开发者更倾向使用像Rectangle和Circle这样容易理解、更专业的语义类型，而不是像Rectangle2和Circle2这样的泛型类型。然而在一些情况下泛型方式可能更好，比如，如果我们将数据持久化到硬盘中，我们并不关心一对Dobule类型数据和Rectangle2类型的不同，我们只需给出两个数字即可。</p><p>shapeless在这两种定义方式中都做的很好：默认情况下我们能友好的使用语义类型，当我们需要互用性（下文具体介绍）时又可以切换到泛型表示方式。当然，shapeless也使用自定义的数据类型来表示泛型的乘积和余积类型，而不是使用Tuple和Either。在下一节会介绍这些类型。</p><h2 id="22-乘积类型product泛型编码">2.2 乘积类型（product）泛型编码</h2><p>上一节我们介绍了使用元组作为乘积类型的泛型表示。遗憾的是，Scala的内置元组类型有一系列的缺点，这些缺点有悖于使用shapeless的初衷：</p><ol><li>不同大小的元组有不同的、无关的类型，难以抛开大小进行抽象编码。</li><li>没有长度为0的元组，而表示0字段的乘积类型却是非常重要的。可以使用Unit，但我们希望所有的泛型表示有一个合理的公共父类型，Unit和Tuple2的根类型是Any，因此结合两者使用是不明智的。</li></ol><p>由于以上原因，shapeless为乘积类型提供了一套不同的泛型编码方式——异构列表（HList）（在命名上Product可能比HList更好，但是Scala的标准库中已经有了scala.Product类型，所以我们选择了HList）。</p><p>HList可以是一个空列表HNil也可以是一对::[H, T]，其中H是任意类型，T是另一个HList。因为每一个::类型都有H和T，所以HList中的每一个元素都是独立的。如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless.</span><span class="o">{</span><span class="nc">HList</span><span class="o">,</span> <span class="o">::,</span> <span class="nc">HNil</span><span class="o">}</span>

<span class="k">val</span> <span class="nv">product</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">::</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">Boolean</span> <span class="kt">::</span> <span class="kt">HNil</span> <span class="o">=</span> 
    <span class="s">"Sunday"</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="kc">false</span> <span class="o">::</span> <span class="nc">HNil</span>
</code></pre></div></div><p>上述中的HList的类型和值相互对应，其对应了三种类型：字符串、整型和布尔。我们能提取头和尾元素及其类型。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">first</span> <span class="k">=</span> <span class="nv">product</span><span class="o">.</span><span class="py">head</span> 
<span class="c1">// first: String = Sunday</span>

<span class="k">val</span> <span class="nv">second</span> <span class="k">=</span> <span class="nv">product</span><span class="o">.</span><span class="py">tail</span><span class="o">.</span><span class="py">head</span> 
<span class="c1">// second: Int = 1</span>

<span class="k">val</span> <span class="nv">rest</span> <span class="k">=</span> <span class="nv">product</span><span class="o">.</span><span class="py">tail</span><span class="o">.</span><span class="py">tail</span> 
<span class="c1">// rest: Boolean :: shapeless.HNil = false :: HNil</span>
</code></pre></div></div><p>编译器知道每一个HList对象的准确长度，所以如果取空列表的head和tail就会造成编译错误。如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">product</span><span class="o">.</span><span class="py">tail</span><span class="o">.</span><span class="py">tail</span><span class="o">.</span><span class="py">tail</span><span class="o">.</span><span class="py">head</span> 
<span class="c1">// &lt;console&gt;:15: error: could not find implicit value for </span>
<span class="c1">// parameter c: shapeless.ops.hlist.IsHCons[shapeless.HNil]</span>
<span class="c1">// product.tail.tail.tail.head</span>
<span class="c1">//                        ^</span>
</code></pre></div></div><p>我们能对HList对象进行操纵和转换，还包括检查和遍历。例如，我们能用::方法将元素插入到列表的最前端。再次注意，元素个数及元素具体类型是如何反映到结果中的（下面将42L通过::与product相连接，可以看到返回的newProduct的元素个数及元素具体类型）。如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">newProduct</span> <span class="k">=</span> <span class="mi">42L</span> <span class="o">::</span> <span class="n">product</span>
<span class="c1">//Long :: String :: Int :: Boolean :: HNil</span>
</code></pre></div></div><p>shapless也为HList提供了更多的复杂操作，如：映射（map）、过滤（filter）以及拼接列表（concatenating list）。我们会在第二部分具体讨论。</p><p>HList对象的这些行为一点也不神奇，我们已经用(A, B)元组以及Unit实现了所有这些功能，::和HNil只是实现这些功能的另一种选择。然而使表示和我们应用中的语义相分离是有好处的，HList恰好提供了分离能力。</p><h3 id="221-使用generic转换泛型表示">2.2.1 使用Generic转换泛型表示</h3><p>shapeless提供了一个叫Generic的类型类，它可以在具体的ADT对象和其泛型表示对象之间进行相互转换。得益于一些幕后的宏魔法，使得我们无需冗余代码即可获取Generic实例。如下实现获取IceCream类的Generic对象：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless.Generic</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">IceCream</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">numCherries</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">inCone</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">iceCreamGen</span> <span class="k">=</span> <span class="nc">Generic</span><span class="o">[</span><span class="kt">IceCream</span><span class="o">]</span> 

<span class="c1">// iceCreamGen: shapeless.Generic[IceCream]{type Repr = String :: Int</span>
<span class="c1">// :: Boolean :: shapeless.HNil} = anon$macro$4$1@6b9323fe</span>
</code></pre></div></div><p>注意Generic实例有一个Repr类型成员，Repr是Generic实例的泛型表示的类型。上面的代码中iceCreamGen实例的Repr类型为String :: Int :: Boolean :: HNil。Generic实例有两个方法：一个将原始对象转换为Repr类型，另一个将Repr类型转为原始对象。如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">iceCream</span> <span class="k">=</span> <span class="nc">IceCream</span><span class="o">(</span><span class="s">"Sundae"</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">false</span><span class="o">)</span>
<span class="c1">// iceCream: IceCream = IceCream(Sundae,1,false)</span>

<span class="k">val</span> <span class="nv">repr</span> <span class="k">=</span> <span class="nv">iceCreamGen</span><span class="o">.</span><span class="py">to</span><span class="o">(</span><span class="n">iceCream</span><span class="o">)</span> 
<span class="c1">// repr: iceCreamGen.Repr = Sundae :: 1 :: false :: HNil</span>

<span class="k">val</span> <span class="nv">iceCream2</span> <span class="k">=</span> <span class="nv">iceCreamGen</span><span class="o">.</span><span class="py">from</span><span class="o">(</span><span class="n">repr</span><span class="o">)</span> 
<span class="c1">// iceCream2: IceCream = IceCream(Sundae,1,false)</span>
</code></pre></div></div><p>如果两个ADT对象Repr类型相同，则我们可以使用它们的Generic实例进行相互转换。如下实现Employee和IceCream对象之间的转换：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Employee</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">number</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">manager</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span>

<span class="c1">// Create an employee from an ice cream:</span>
<span class="k">val</span> <span class="nv">employee</span> <span class="k">=</span> <span class="nc">Generic</span><span class="o">[</span><span class="kt">Employee</span><span class="o">].</span><span class="py">from</span><span class="o">(</span><span class="nc">Generic</span><span class="o">[</span><span class="kt">IceCream</span><span class="o">].</span><span class="py">to</span><span class="o">(</span><span class="n">iceCream</span><span class="o">))</span> 
<span class="c1">// employee: Employee = Employee(Sundae,1,false)</span>
</code></pre></div></div><blockquote><p>其它乘积类型</p><p>值得注意的是在Scala中Tuple实际上也是一种样例类，所以Generic也能应用于Tuple。如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">tupleGen</span> <span class="k">=</span> <span class="nc">Generic</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span>, <span class="kt">Boolean</span><span class="o">)]</span>

<span class="nv">tupleGen</span><span class="o">.</span><span class="py">to</span><span class="o">((</span><span class="s">"Hello"</span><span class="o">,</span> <span class="mi">123</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span> 


<span class="nv">tupleGen</span><span class="o">.</span><span class="py">from</span><span class="o">(</span><span class="s">"Hello"</span> <span class="o">::</span> <span class="mi">123</span> <span class="o">::</span> <span class="kc">true</span> <span class="o">::</span> <span class="nc">HNil</span><span class="o">)</span>

</code></pre></div></div><p>Generic也能用于超过22个字段的样例类。如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">BigData</span><span class="o">(</span> 
    <span class="n">a</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span><span class="n">b</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span><span class="n">c</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span><span class="n">d</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span><span class="n">e</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span><span class="n">f</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span><span class="n">g</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span><span class="n">h</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span><span class="n">i</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span><span class="n">j</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span> 
    <span class="n">k</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span><span class="n">l</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span><span class="n">m</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span><span class="n">n</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span><span class="n">o</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span><span class="n">p</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span><span class="n">q</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span><span class="n">r</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span><span class="n">s</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span><span class="n">t</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span> 
    <span class="n">u</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span><span class="n">v</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span><span class="n">w</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span>
<span class="nc">Generic</span><span class="o">[</span><span class="kt">BigData</span><span class="o">].</span><span class="py">from</span><span class="o">(</span><span class="nc">Generic</span><span class="o">[</span><span class="kt">BigData</span><span class="o">].</span><span class="py">to</span><span class="o">(</span><span class="nc">BigData</span><span class="o">(</span> 
    <span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">11</span><span class="o">,</span><span class="mi">12</span><span class="o">,</span><span class="mi">13</span><span class="o">,</span><span class="mi">14</span><span class="o">,</span><span class="mi">15</span><span class="o">,</span><span class="mi">16</span><span class="o">,</span><span class="mi">17</span><span class="o">,</span><span class="mi">18</span><span class="o">,</span><span class="mi">19</span><span class="o">,</span><span class="mi">20</span><span class="o">,</span><span class="mi">21</span><span class="o">,</span><span class="mi">22</span><span class="o">,</span><span class="mi">23</span><span class="o">)))</span> 

<span class="c1">// res6: BigData = </span>
<span class="c1">// BigData (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23)</span>
</code></pre></div></div></blockquote><p>在Scala2.10及更早版本中，Scala的样例类限制为22个字段。 此限制在2.11中移除（元组和函数仍有限制），但是使用HLists将有助于避免Scala中的22个字段的限制。可参考<a href="https://underscore.io/blog/posts/2016/10/11/twenty-two.html">limitations of 22 fields in Scala</a>。</p><h2 id="23-余积类型coproduct泛型编码">2.3 余积类型（coproduct）泛型编码</h2><p>我们已经学习了shapeless如何编码乘积类型，那么余积类型是怎么样的？之前我们学习了使用Either的操作方式，但是它跟元组有相同的缺点。因此，shapeless也提供了与HList相似的编码方式，名为Coproduct。如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless.</span><span class="o">{</span><span class="nc">Coproduct</span><span class="o">,</span> <span class="o">:+:,</span> <span class="nc">CNil</span><span class="o">,</span> <span class="nc">Inl</span><span class="o">,</span> <span class="nc">Inr</span><span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Red</span><span class="o">()</span> 
<span class="k">case</span> <span class="k">class</span> <span class="nc">Amber</span><span class="o">()</span> 
<span class="k">case</span> <span class="k">class</span> <span class="nc">Green</span><span class="o">()</span>

<span class="k">type</span> <span class="kt">Light</span> <span class="o">=</span> <span class="nc">Red</span> <span class="o">:+:</span> <span class="nc">Amber</span> <span class="o">:+:</span> <span class="nc">Green</span> <span class="o">:+:</span> <span class="nc">CNil</span>
</code></pre></div></div><p>简单来说余积的形式是A :+: B :+: C :+: CNil，其意思是“A或B或C”，“:+:”可以被近似地解释为Either。一个余积的总类型编码了所有可能类型，但是每一个具体的余积实例只是其中的一种类型。“:+:”有两个子类：Inl和Inr，与Left和Right相似。通过嵌套Inl和Inr的构造函数来创建一个余积实例。如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">red</span><span class="k">:</span> <span class="kt">Light</span> <span class="o">=</span> <span class="nc">Inl</span><span class="o">(</span><span class="nc">Red</span><span class="o">())</span>
<span class="c1">// red: Light = Inl(Red())</span>

<span class="k">val</span> <span class="nv">green</span><span class="k">:</span> <span class="kt">Light</span> <span class="o">=</span> <span class="nc">Inr</span><span class="o">(</span><span class="nc">Inr</span><span class="o">(</span><span class="nc">Inl</span><span class="o">(</span><span class="nc">Green</span><span class="o">())))</span>
<span class="c1">// green: Light = Inr(Inr(Inl(Green())))</span>
</code></pre></div></div><p>每一个余积类型均以CNil结束，CNil是一个没有值的空类型，与Nothing相似。我们不能实例化CNil或创建一个只有Inr实例的余积类型，在每一个值中均应有一个Inl。</p><p>再次强调，余积类型并不特别，以上功能均可通过Either和Nothing实现。尽管使用Nothing存在技术困难，但是我们能使用其它任意一个无意义的单例类型来代替CNil。</p><h2 id="231-使用generic转换泛型编码">2.3.1 使用Generic转换泛型编码</h2><p>余积类型看似很难解析，然而我们能看到它们非常适合较大的泛型编码场景。除了能解析样例类和样例对象，shapeless的Generic类型类还能解析密封特质和抽象类。如下代码将Generic应用于密封特质：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless.Generic</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Shape</span> 
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="n">width</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Shape</span> 
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Circle</span><span class="o">(</span><span class="n">radius</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Shape</span>

<span class="k">val</span> <span class="nv">gen</span> <span class="k">=</span> <span class="nc">Generic</span><span class="o">[</span><span class="kt">Shape</span><span class="o">]</span> 

<span class="c1">// gen: shapeless.Generic[Shape]{type Repr = Rectangle :+: Circle :+:</span>
<span class="c1">// shapeless.CNil} = anon$macro$1$1@1a28fc61</span>
</code></pre></div></div><p>Shape的Generic实例（gen）的Repr类型是“Rectangle :+: Circle :+: CNil”，它是密封特质Shape的子类的余积。我们能用gen的to和from方法在Shape的子类实例和gen.Repr之间进行相互转换。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">gen</span><span class="o">.</span><span class="py">to</span><span class="o">(</span><span class="nc">Rectangle</span><span class="o">(</span><span class="mf">3.0</span><span class="o">,</span> <span class="mf">4.0</span><span class="o">))</span>
<span class="c1">// res3: gen.Repr = Inl(Rectangle(3.0,4.0))</span>

<span class="nv">gen</span><span class="o">.</span><span class="py">to</span><span class="o">(</span><span class="nc">Circle</span><span class="o">(</span><span class="mf">1.0</span><span class="o">))</span> 
<span class="c1">// res4: gen.Repr = Inr(Inl(Circle(1.0)))</span>
</code></pre></div></div><h2 id="24-小结">2.4 小结</h2><p>这一章我们讨论了Scala中shapeless为ADT提供的泛型表示：用HList表示乘积类型和用Coproduct表示余积类型。也介绍了通过Generic类型类进行ADT实例和它们的泛型表示之间的相互转换。目前，还没有讨论为什么泛型编码如此具有吸引力。本章介绍的ADT之间的相互转换这一使用案例很有趣但是并不是很有用。</p><p>HList和Coproduct的强大之处源于它们的递归结构（此处递归的意思是像::[H, T]这样，T同样代表一个新的::[H, T]，所以称之为递归），我们可以遍历泛型表示并根据它们的组成元素计算值。下一章我们将聚焦于第一个实际应用：自动派生类型类实例。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://blog.dreamylost.cn" target="_blank">梦境迷离</a></li><li>本文链接：<a href="https://blog.dreamylost.cn/shapeless/Shapeless-%E4%BB%A3%E6%95%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%B3%9B%E5%9E%8B%E8%A1%A8%E7%A4%BA.html" target="_blank">https://blog.dreamylost.cn/shapeless/Shapeless-%E4%BB%A3%E6%95%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%B3%9B%E5%9E%8B%E8%A1%A8%E7%A4%BA.html</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/shapeless/Shapeless-%E4%BB%A3%E6%95%B0%E6%95%B0%E', clientID: '061aadb5d449c0877d7d', clientSecret: '9aa7af7c248a7e36a07a86993e11a7acf7fbd353', repo: 'dreamylost-comments', owner: 'jxnu-liguobin', admin: ['jxnu-liguobin'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@built/assets/search_data.json?v=1697167178', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"> <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-8236444920328818" data-ad-slot="6220614560" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2019 <span title="梦境迷离">梦境迷离</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/jxnu-liguobin/jxnu-liguobin.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://blog.dreamylost.cn/" title="首页" target="">首页</a></li><li> <a href="https://blog.dreamylost.cn/categories/" title="分类" target="">分类</a></li><li> <a href="https://blog.dreamylost.cn/archives/" title="归档" target="">归档</a></li><li> <a href="https://blog.dreamylost.cn/open-source/" title="开源" target="">开源</a></li><li> <a href="https://blog.dreamylost.cn/wiki/" title="维基" target="">维基</a></li><li> <a href="https://blog.dreamylost.cn/links/" title="链接" target="">链接</a></li><li> <a href="https://blog.dreamylost.cn/about/" title="关于" target="">关于</a></li><li><a href="https://blog.dreamylost.cn/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2019-09-20 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-147390701-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
