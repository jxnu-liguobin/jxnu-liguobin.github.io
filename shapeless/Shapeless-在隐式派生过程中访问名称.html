<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>在隐式派生过程中访问名称 &mdash; 梦境迷离</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="canonical" href="https://dreamylost.cn/shapeless/Shapeless-%E5%9C%A8%E9%9A%90%E5%BC%8F%E6%B4%BE%E7%94%9F%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%90%8D%E7%A7%B0.html"><link rel="alternate" type="application/atom+xml" title="梦境迷离" href="https://dreamylost.cn/feed.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/favicon.ico"><meta property="og:title" content="在隐式派生过程中访问名称"><meta name="keywords" content="梦境迷离, jxnu-liguobin"><meta name="og:keywords" content="梦境迷离, jxnu-liguobin"><meta name="description" content=""><meta name="og:description" content=""><meta property="og:url" content="https://dreamylost.cn/shapeless/Shapeless-%E5%9C%A8%E9%9A%90%E5%BC%8F%E6%B4%BE%E7%94%9F%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%90%8D%E7%A7%B0.html"><meta property="og:site_name" content="梦境迷离"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2020-06-25"> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/main.js"></script> <script data-ad-client="ca-pub-7093222719567591" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://dreamylost.cn/" title="梦境迷离"><span class="octicon octicon-mark-github"></span> 梦境迷离</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://dreamylost.cn/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://dreamylost.cn/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://dreamylost.cn/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://dreamylost.cn/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://dreamylost.cn/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="在隐式派生过程中访问名称"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">在隐式派生过程中访问名称</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2020/06/25 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://dreamylost.cn/categories/#Shapeless" title="Shapeless">Shapeless</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 12037 字，约 35 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"> <img style="height:72px;width:72px" src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/images/qrcode.jpg" alt="梦境迷离" /></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><ul id="markdown-toc"><li><a href="#51-字面类型" id="markdown-toc-51-字面类型">5.1 字面类型</a></li><li><a href="#52-标记类型与幽灵类型" id="markdown-toc-52-标记类型与幽灵类型">5.2 标记类型与幽灵类型</a><ul><li><a href="#521-记录和labelledgeneric-" id="markdown-toc-521-记录和labelledgeneric-">5.2.1 记录和LabelledGeneric <a id="521-&#x8BB0;&#x5F55;&#x548C;labelledgeneric"></a></a></li></ul></li><li><a href="#53-使用labelledgeneric为乘积类型派生实例" id="markdown-toc-53-使用labelledgeneric为乘积类型派生实例">5.3 使用LabelledGeneric为乘积类型派生实例</a><ul><li><a href="#531-为hlist派生jsonencoder类型类实例" id="markdown-toc-531-为hlist派生jsonencoder类型类实例">5.3.1 为HList派生JsonEncoder类型类实例</a></li><li><a href="#532-为具体的乘积类型派生jsonencoder类型类实例" id="markdown-toc-532-为具体的乘积类型派生jsonencoder类型类实例">5.3.2 为具体的乘积类型派生JsonEncoder类型类实例</a></li></ul></li><li><a href="#54-使用labelledgeneric为余积类型派生类型类实例" id="markdown-toc-54-使用labelledgeneric为余积类型派生类型类实例">5.4 使用LabelledGeneric为余积类型派生类型类实例</a></li><li><a href="#55-小结" id="markdown-toc-55-小结">5.5 小结</a></li></ul><blockquote><p>在线电子书 https://dreamylost.gitbook.io/dreamylost/</p></blockquote><blockquote><p>shapeless v2.3.2</p></blockquote><p>我们自定义的类型类实例经常不止需要使用字段的类型，有时还希望能够使用字段名称及字段类型名称。在这一章我们将学习通过Generic的变体LabelledGeneric来实现这一点。</p><p>开始之前我们先来学习一些理论知识。LabelledGeneric在类型级别使用一些小技巧来提取名称信息。要理解它我们必须先来学习一下字面类型（ literal type）、单例类型（singleton type）、幽灵类型（phantom type）和标记类型（type tagging）。（下文的标记和标签是同一个东西，我的理解是前者偏向动词后者偏向名词）</p><h2 id="51-字面类型">5.1 字面类型</h2><p>一个Scala值可以有多个类型。例如，“hello”字符串最少有三个类型：String、AnyRef和Any（字符串还有一系列其它类型，像Serializable、Comparable，我们先忽略这些）。具体如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"hello"</span> <span class="k">:</span> <span class="kt">String</span> 
<span class="c1">// res0: String = hello</span>

<span class="s">"hello"</span> <span class="k">:</span> <span class="kt">AnyRef</span> 
<span class="c1">// res1: AnyRef = hello</span>

<span class="s">"hello"</span> <span class="k">:</span> <span class="kt">Any</span>
<span class="c1">// res2: Any = hello</span>
</code></pre></div></div><p>有趣的是“hello”同样也是只有一个值的单例类型，与我们定义伴随类得到的单例类型相似。比如定义一个Foo单例类：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Foo</span>

<span class="nc">Foo</span> 
<span class="c1">// res3: Foo.type = Foo$@5c32f469</span>
</code></pre></div></div><p>Foo.type的类型是Foo，并且Foo是Foo类型的唯一值。</p><p>单例类型附加字面值就被称作字面类型，这在Scala中已经存在了很长世间，但是我们并不经常接触它们，因为编译器默认将字面值转向其最近的非单例类型。例如，以下两个表达式在本质上一致的，第一个”hello”直接转为非单例类型String：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"hello"</span> 
<span class="c1">// res4: String = hello</span>

<span class="o">(</span><span class="s">"hello"</span> <span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="c1">// res5: String = hello</span>
</code></pre></div></div><p>shapeless为使用字面类型提供了几个工具。第一，提供了一个名为narrow的宏，实现将一个字面表达式转换为一个类型单例化的字面表达式。下述代码将42这个字面量转换为Int(42)类型：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless.syntax.singleton._</span>

<span class="k">var</span> <span class="n">x</span> <span class="k">=</span> <span class="mf">42.</span><span class="n">narrow</span> 
<span class="c1">// x: Int(42) = 42</span>
</code></pre></div></div><p>注意x变量的类型Int(42)，它是字面类型，是Int的子类，该类只有42这一个值，如果我们给x赋其它值的话，编译器会报错。具体如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="k">=</span> <span class="mi">43</span> 
<span class="c1">// &lt;console&gt;:16: error: type mismatch:</span>
<span class="c1">//  found   : Int(43)</span>
<span class="c1">//  required: Int(42)</span>
<span class="c1">//        x = 43</span>
<span class="c1">//            ^</span>
</code></pre></div></div><p>然而按照普通的继承规则x仍然是一个Int类型，如果对x进行操作将得到一个标准的Int类型。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> 
<span class="c1">// res6: Int = 43</span>
</code></pre></div></div><p>在Scala中我们能在任何字面值上使用narrow。比如：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">1.</span><span class="n">narrow</span> 
<span class="c1">// res7: Int(1) = 1</span>

<span class="nv">true</span><span class="o">.</span><span class="py">narrow</span> 
<span class="c1">// res8: Boolean(true) = true</span>

<span class="s">"hello"</span><span class="o">.</span><span class="py">narrow</span>
<span class="c1">// res9: String("hello") = hello</span>

<span class="c1">// and so on...</span>
</code></pre></div></div><p>但是我们并不能在复合表达式上使用narrow，否则会报错。比如：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">math</span><span class="o">.</span><span class="py">sqrt</span><span class="o">(</span><span class="mi">4</span><span class="o">).</span><span class="py">narrow</span> 
<span class="c1">// &lt;console&gt;:17: error: Expression scala.math.`package`.sqrt(4.0) does </span>
<span class="c1">//    not evaluate to a constant or a stable reference value</span>
<span class="c1">//        math.sqrt(4.0).narrow</span>
<span class="c1">//                  ^</span>
<span class="c1">// &lt;console&gt;:17: error: value narrow is not a member of Double </span>
<span class="c1">// math.sqrt(4.0).narrow</span>
<span class="c1">//                ^</span>
</code></pre></div></div><p>Scala中的字面类型</p><p>截至目前，Scala并没有为字面类型提供专用语法，编译器里存在字面类型但是并不能在代码中直接表达它们。然而，在Lightbend Scala 2.11.9版、2.12.1版以及Typelevel Scala 2.11.8版已经实现了对字面类型的直接支持，在这些Scala版本中我们能直接采用如下方式定义一个数字：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">theAnswer</span><span class="k">:</span> <span class="err">42</span> <span class="o">=</span> <span class="mi">42</span>
<span class="c1">// theAnswer: 42 = 42</span>
</code></pre></div></div><p>“42”类型与之前输出中看到的Int(42)类型一致，为了向上兼容在输出中你会继续看到Int(42)，但是权威的语法应该是“42”。</p><h2 id="52-标记类型与幽灵类型">5.2 标记类型与幽灵类型</h2><p>shapeless使用字面类型来规范样例类字段的名称，通过用字段名称的字面类型标记字段类型的方式来实现这一功能。在学习shapeless如何完成这些之前，我们先来简单实现此功能以此证明这不是什么神奇的事情。假如我们有一个数字：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">number</span> <span class="k">=</span> <span class="mi">42</span>
</code></pre></div></div><p>number变量在编译时和运行时都是Int类型：在运行时，有一个真实值和一系列方法并能被我们调用；在编译时，编译器根据此类型来推断哪些代码片段工作在一起并用来搜索隐式值。</p><p>我们能使用幽灵类型标记number变量使得可以在编译时修改它的类型而又无需修改它的运行时行为。幽灵类型是没有运行时语义的类型。比如一个不包含任何方法的特质：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Cherries</span>
</code></pre></div></div><p>我们能使用asInstanceOf标记number变量，类型参数传入一个编译时既是Int类型又是Cherries类型而运行时是Int类型的值。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">numCherries</span> <span class="k">=</span> <span class="nv">number</span><span class="o">.</span><span class="py">asInstanceOf</span><span class="o">[</span><span class="kt">Int</span> <span class="kt">with</span> <span class="kt">Cherries</span><span class="o">]</span>
<span class="c1">// numCherries: Int with Cherries = 42</span>
</code></pre></div></div><p>shapeless使用这一技巧在ADT中使用字段名称和子类的名称的单例类型来标记字段和子类自身。为了方便shapeless提供了两种标记语法来避免像asInstanceOf这样的不友好代码。</p><p>第一种语法是-&gt;&gt;，使用箭头左侧的字面表达式的单例类型来标记箭头右侧的表达式。如下代码实现使用numCherries标记someNumber变量：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless.labelled.</span><span class="o">{</span><span class="nc">KeyTag</span><span class="o">,</span> <span class="nc">FieldType</span><span class="o">}</span> 
<span class="k">import</span> <span class="nn">shapeless.syntax.singleton._</span>

<span class="k">val</span> <span class="nv">someNumber</span> <span class="k">=</span> <span class="mi">123</span>

<span class="k">val</span> <span class="nv">numCherries</span> <span class="k">=</span> <span class="s">"numCherries"</span> <span class="o">-&gt;&gt;</span> <span class="n">someNumber</span>
<span class="c1">// numCherries: Int with shapeless.labelled.KeyTag[String("numCherries</span>
<span class="c1">//  "),Int] = 123</span>
</code></pre></div></div><p>相当于使用了下面的幽灵类型标记了someNumber：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">KeyTag</span><span class="o">[</span><span class="err">"</span><span class="kt">numCherries</span><span class="err">"</span>, <span class="kt">Int</span><span class="o">]</span>
</code></pre></div></div><p>KeyTag同时包含了字段的名称和类型，这样的结合对在Repr实例中使用隐式解析搜索入口是很有用的。</p><p>第二种语法将标签作为一个类型而不是一个字面值，当我们知道要使用什么标签但是不能在代码中写出具体的字面值（即上面代码中的”numCherries”）的时候这是有用的。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless.labelled.field</span>

<span class="n">field</span><span class="o">[</span><span class="kt">Cherries</span><span class="o">](</span><span class="mi">123</span><span class="o">)</span>
<span class="c1">// res11: shapeless.labelled.FieldType[Cherries,Int] = 123</span>
</code></pre></div></div><p>FieldType是一个类型别名，它简化了从被标记的类型中提取标记类型K以及基础类型V。FieldType定义如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">FieldType</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">]</span> <span class="k">=</span> <span class="n">V</span> <span class="k">with</span> <span class="nc">KeyTag</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">]</span>
</code></pre></div></div><p>我们即将看到在shapeless的源码中使用同样的方式实现以字段名称和子类名称标记字段和子类自身。</p><p>标签在编译期间很纯净，它也没有运行时表示，那么我们如何将它们转换成在运行时可以使用的值？为此shapeless提供了一个叫做Witness的类型类。将Witness和FieldType相结合就可以从一个被标记的字段中提取字段名称，这是不是很有吸引力。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless.Witness</span>

<span class="k">val</span> <span class="nv">numCherries</span> <span class="k">=</span> <span class="s">"numCherries"</span> <span class="o">-&gt;&gt;</span> <span class="mi">123</span>
<span class="c1">// numCherries: Int with shapeless.labelled.KeyTag[String("numCherries</span>
<span class="c1">//  "),Int] = 123</span>

<span class="c1">// Get the tag from a tagged value:</span>


<span class="k">def</span> <span class="nf">getFieldName</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">FieldType</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">])</span>
    <span class="o">(</span><span class="k">implicit</span> <span class="n">witness</span><span class="k">:</span> <span class="kt">Witness.Aux</span><span class="o">[</span><span class="kt">K</span><span class="o">])</span><span class="k">:</span> <span class="kt">K</span> <span class="o">=</span> <span class="nv">witness</span><span class="o">.</span><span class="py">value</span>

<span class="nf">getFieldName</span><span class="o">(</span><span class="n">numCherries</span><span class="o">)</span> 
<span class="c1">// res13: String = numCherries</span>

<span class="c1">// Get the untagged type of a tagged value:</span>

<span class="k">def</span> <span class="nf">getFieldValue</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">FieldType</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">])</span><span class="k">:</span> <span class="kt">V</span> <span class="o">=</span> <span class="n">value</span>

<span class="nf">getFieldValue</span><span class="o">(</span><span class="n">numCherries</span><span class="o">)</span> 
<span class="c1">// res15: Int = 123</span>
</code></pre></div></div><p>如果我们构建一个带标记元素的HList，我们将获得一个具有Map属性的数据结构。我们能在这个过程中通过标记对字段进行处理，这些处理包含操作和替换它们以及保持所有类型和命名信息。在shapeless中称这种结构为“记录（records）”。</p><h3 id="521-记录和labelledgeneric-">5.2.1 记录和LabelledGeneric <a id="521-&#x8BB0;&#x5F55;&#x548C;labelledgeneric"></a></h3><p>记录是元素被标记的HList类型。如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless.</span><span class="o">{</span><span class="nc">HList</span><span class="o">,</span> <span class="o">::,</span> <span class="nc">HNil</span><span class="o">}</span>

<span class="k">val</span> <span class="nv">garfield</span> <span class="k">=</span> <span class="o">(</span><span class="s">"cat"</span> <span class="o">-&gt;&gt;</span> <span class="s">"Garfield"</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="s">"orange"</span> <span class="o">-&gt;&gt;</span> <span class="kc">true</span><span class="o">)</span> <span class="o">::</span> <span class="nc">HNil</span> 
<span class="c1">// garfield: shapeless.::[String with shapeless.labelled.KeyTag[String(" </span>
    <span class="n">cat</span><span class="s">"),String],shapeless.::[Boolean with shapeless.labelled.KeyTag[ 
    String("</span><span class="n">orange</span><span class="err">"</span><span class="o">),</span><span class="nc">Boolean</span><span class="err">]</span><span class="o">,</span><span class="nv">shapeless</span><span class="o">.</span><span class="py">HNil</span><span class="err">]]</span> <span class="k">=</span> <span class="nc">Garfield</span> <span class="o">::</span> <span class="kc">true</span> <span class="o">::</span> <span class="nc">HNil</span>
</code></pre></div></div><p>清晰起见，我们将garfield的类型分行写成如下形式：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// FieldType["cat",    String]  ::</span>
<span class="c1">// FieldType["orange", Boolean] ::</span>
<span class="c1">// HNil</span>
</code></pre></div></div><p>这里我们不需要深入研究记录，其实它是LabelledGeneric用来进行泛型表示所得到的结果。LabelledGeneric使用具体的ADT（尽管字段名称和类型名称被展示为Symbol类型而不是字符串）实例中相应的字段和类型名称标记乘积或余积类型中的每一个元素。shapeless对记录实现了一系列类似Map的操作，我们将在6.4节中介绍其中的一部分。现在先让我们使用LabelledGeneric派生一些类型类。</p><h2 id="53-使用labelledgeneric为乘积类型派生实例">5.3 使用LabelledGeneric为乘积类型派生实例</h2><p>我们将实现一个能运行的JSON编码实例，以此展示LabelledGeneric。我们定义一个能把数据值转换为JSON抽象语法树（AST）的JsonEncoder类型类，这与Argonaut、Circe、Play JSON、Spray JSON等其它Scala语言写的JSON类库采用的方式相似。</p><p>首先定义JSON对应的数据类型。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">JsonValue</span> 
<span class="k">case</span> <span class="k">class</span> <span class="nc">JsonObject</span><span class="o">(</span><span class="n">fields</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">JsonValue</span><span class="o">)])</span> <span class="k">extends</span> <span class="nc">JsonValue</span> 
<span class="k">case</span> <span class="k">class</span> <span class="nc">JsonArray</span><span class="o">(</span><span class="n">items</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">JsonValue</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">JsonValue</span> 
<span class="k">case</span> <span class="k">class</span> <span class="nc">JsonString</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">JsonValue</span> 
<span class="k">case</span> <span class="k">class</span> <span class="nc">JsonNumber</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">JsonValue</span> 
<span class="k">case</span> <span class="k">class</span> <span class="nc">JsonBoolean</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">JsonValue</span> 
<span class="k">case</span> <span class="k">object</span> <span class="nc">JsonNull</span> <span class="k">extends</span> <span class="nc">JsonValue</span>
</code></pre></div></div><p>然后为将数据值编码为JSON定义一个类型类JsonEncoder。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">JsonEncoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span> 
    <span class="k">def</span> <span class="nf">encode</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">JsonValue</span> 
<span class="o">}</span>

<span class="k">object</span> <span class="nc">JsonEncoder</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">enc</span><span class="k">:</span> <span class="kt">JsonEncoder</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">JsonEncoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">enc</span> 
<span class="o">}</span>
</code></pre></div></div><p>接下来创建几种基础类型的JsonEncoder实例。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">createEncoder</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">func</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">JsonValue</span><span class="o">)</span><span class="k">:</span> <span class="kt">JsonEncoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> 
    <span class="k">new</span> <span class="nc">JsonEncoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">encode</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">JsonValue</span> <span class="o">=</span> <span class="nf">func</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> 
    <span class="o">}</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">stringEncoder</span><span class="k">:</span> <span class="kt">JsonEncoder</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> 
    <span class="nf">createEncoder</span><span class="o">(</span><span class="n">str</span> <span class="k">=&gt;</span> <span class="nc">JsonString</span><span class="o">(</span><span class="n">str</span><span class="o">))</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">doubleEncoder</span><span class="k">:</span> <span class="kt">JsonEncoder</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> 
    <span class="nf">createEncoder</span><span class="o">(</span><span class="n">num</span> <span class="k">=&gt;</span> <span class="nc">JsonNumber</span><span class="o">(</span><span class="n">num</span><span class="o">))</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">intEncoder</span><span class="k">:</span> <span class="kt">JsonEncoder</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> 
    <span class="nf">createEncoder</span><span class="o">(</span><span class="n">num</span> <span class="k">=&gt;</span> <span class="nc">JsonNumber</span><span class="o">(</span><span class="n">num</span><span class="o">))</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">booleanEncoder</span><span class="k">:</span> <span class="kt">JsonEncoder</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span> 
    <span class="nf">createEncoder</span><span class="o">(</span><span class="n">bool</span> <span class="k">=&gt;</span> <span class="nc">JsonBoolean</span><span class="o">(</span><span class="n">bool</span><span class="o">))</span>
</code></pre></div></div><p>再通过组合规则创建几个JsonEncoder实例。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">listEncoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> 
    <span class="o">(</span><span class="k">implicit</span> <span class="n">enc</span><span class="k">:</span> <span class="kt">JsonEncoder</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">JsonEncoder</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> 
    <span class="nf">createEncoder</span><span class="o">(</span><span class="n">list</span> <span class="k">=&gt;</span> <span class="nc">JsonArray</span><span class="o">(</span><span class="nv">list</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">enc</span><span class="o">.</span><span class="py">encode</span><span class="o">)))</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">optionEncoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
    <span class="o">(</span><span class="k">implicit</span> <span class="n">enc</span><span class="k">:</span> <span class="kt">JsonEncoder</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">JsonEncoder</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> 
    <span class="nf">createEncoder</span><span class="o">(</span><span class="n">opt</span> <span class="k">=&gt;</span> <span class="nv">opt</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">enc</span><span class="o">.</span><span class="py">encode</span><span class="o">).</span><span class="py">getOrElse</span><span class="o">(</span><span class="nc">JsonNull</span><span class="o">))</span>
</code></pre></div></div><p>理想情况下当我们将ADT编码为JSON的时候在输出的JSON中最好是正确的字段名称。比如在以下例子中的字段name、numCherries、inCone：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">IceCream</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">numCherries</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">inCone</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">iceCream</span> <span class="k">=</span> <span class="nc">IceCream</span><span class="o">(</span><span class="s">"Sundae"</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">false</span><span class="o">)</span>


<span class="k">val</span> <span class="nv">iceCreamJson</span><span class="k">:</span> <span class="kt">JsonValue</span> <span class="o">=</span> 
    <span class="nc">JsonObject</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span>
        <span class="s">"name"</span>        <span class="o">-&gt;</span> <span class="nc">JsonString</span><span class="o">(</span><span class="s">"Sundae"</span><span class="o">),</span> 
        <span class="s">"numCherries"</span> <span class="o">-&gt;</span> <span class="nc">JsonNumber</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> 
        <span class="s">"inCone"</span>      <span class="o">-&gt;</span> <span class="nc">JsonBoolean</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span> 
    <span class="o">))</span>
</code></pre></div></div><p>这就需要靠LabelledGeneric来实现。下面来为IceCream类型创建JsonEncoder实例并看一下它所产生的泛型表示的类型。具体如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless.LabelledGeneric</span>

<span class="k">val</span> <span class="nv">gen</span> <span class="k">=</span> <span class="nc">LabelledGeneric</span><span class="o">[</span><span class="kt">IceCream</span><span class="o">].</span><span class="py">to</span><span class="o">(</span><span class="n">iceCream</span><span class="o">)</span> 
<span class="c1">// gen: shapeless.::[String with shapeless.labelled.KeyTag[Symbol with </span>
<span class="c1">//    shapeless.tag.Tagged[String("name")],String],shapeless.::[Int with </span>
<span class="c1">//    shapeless.labelled.KeyTag[Symbol with shapeless.tag.Tagged[String(" </span>
<span class="c1">//    numCherries")],Int],shapeless.::[Boolean with shapeless.labelled. </span>
<span class="c1">//    KeyTag[Symbol with shapeless.tag.Tagged[String("inCone")],Boolean], </span>
<span class="c1">//    shapeless.HNil]]] = Sundae :: 1 :: false :: HNil</span>
</code></pre></div></div><p>可以看到生成的HList实例的类型是：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// String with KeyTag[Symbol with Tagged["name"], String] ::</span>
<span class="c1">// Int with KeyTag[Symbol with Tagged["numCherries"], Int] ::</span>
<span class="c1">// Boolean with KeyTag[Symbol with Tagged["inCone"], Boolean] ::</span>
<span class="c1">// HNil</span>
</code></pre></div></div><p>这个对象比我们之前看到的要复杂一点，shapeless不是使用字面字符串类型表示字段名称而是使用Symbol with Tagged[“field name”]类型来表示字段名称。实现的细节不是特别重要，我们仍然能使用Witness和FieldType来提取它们，但是得到的结果是Symbol类型而不是字符串（将来的版本也许会使用字符串作为标签）。</p><h3 id="531-为hlist派生jsonencoder类型类实例">5.3.1 为HList派生JsonEncoder类型类实例</h3><p>下面为HNil和::定义JsonEncoder实例。这些JsonEncoder将生成和操作JsonObject对象，所以我们将创建一个新的JsonObjectEncoder类型来使这些操作变的更加容易。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">JsonObjectEncoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">JsonEncoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">encode</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">JsonObject</span> 
<span class="o">}</span>

<span class="k">def</span> <span class="nf">createObjectEncoder</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fn</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">JsonObject</span><span class="o">)</span><span class="k">:</span> <span class="kt">JsonObjectEncoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">JsonObjectEncoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span> 
        <span class="k">def</span> <span class="nf">encode</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">JsonObject</span> <span class="o">=</span> 
            <span class="nf">fn</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> 
    <span class="o">}</span>
</code></pre></div></div><p>为HNil定义相应的JsonObjectEncoder实例就水到渠成。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless.</span><span class="o">{</span><span class="nc">HList</span><span class="o">,</span> <span class="o">::,</span> <span class="nc">HNil</span><span class="o">,</span> <span class="nc">Lazy</span><span class="o">}</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">hnilEncoder</span><span class="k">:</span> <span class="kt">JsonObjectEncoder</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span> 
    <span class="nf">createObjectEncoder</span><span class="o">(</span><span class="n">hnil</span> <span class="k">=&gt;</span> <span class="nc">JsonObject</span><span class="o">(</span><span class="nc">Nil</span><span class="o">))</span>
</code></pre></div></div><p>hlistEncoder的定义包含几个部分，我们来一个个的解决它们。首先按照Generic的方式来完成初步定义。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">hlistObjectEncoder</span><span class="o">[</span><span class="kt">H</span>, <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span> 
    <span class="k">implicit</span>
    <span class="n">hEncoder</span><span class="k">:</span> <span class="kt">Lazy</span><span class="o">[</span><span class="kt">JsonEncoder</span><span class="o">[</span><span class="kt">H</span><span class="o">]],</span>
    <span class="n">tEncoder</span><span class="k">:</span> <span class="kt">JsonObjectEncoder</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> 
<span class="o">)</span><span class="k">:</span> <span class="kt">JsonEncoder</span><span class="o">[</span><span class="kt">H</span> <span class="kt">::</span> <span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div><p>LabelledGeneric将给我们一个类型被标记的HList，所以先来为FieldType的key类型引入一个新的类型变量。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless.Witness</span> 
<span class="k">import</span> <span class="nn">shapeless.labelled.FieldType</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">hlistObjectEncoder</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">H</span>, <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span> 
    <span class="k">implicit</span>
    <span class="n">hEncoder</span><span class="k">:</span> <span class="kt">Lazy</span><span class="o">[</span><span class="kt">JsonEncoder</span><span class="o">[</span><span class="kt">H</span><span class="o">]],</span> 
    <span class="n">tEncoder</span><span class="k">:</span> <span class="kt">JsonObjectEncoder</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">JsonObjectEncoder</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">H</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div><p>在此方法体内需要获取与K相关的值，可以添加一个隐式的Witness来实现这些。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">hlistObjectEncoder</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">H</span>, <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span> 
    <span class="k">implicit</span> 
    <span class="n">witness</span><span class="k">:</span> <span class="kt">Witness.Aux</span><span class="o">[</span><span class="kt">K</span><span class="o">],</span> 
    <span class="n">hEncoder</span><span class="k">:</span> <span class="kt">Lazy</span><span class="o">[</span><span class="kt">JsonEncoder</span><span class="o">[</span><span class="kt">H</span><span class="o">]],</span> 
    <span class="n">tEncoder</span><span class="k">:</span> <span class="kt">JsonObjectEncoder</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> 
<span class="o">)</span><span class="k">:</span> <span class="kt">JsonObjectEncoder</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">H</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">fieldName</span> <span class="k">=</span> <span class="nv">witness</span><span class="o">.</span><span class="py">value</span>
    <span class="o">???</span> 
<span class="o">}</span>
</code></pre></div></div><p>可以使用witness.value得到K的值，但是编译器无法知道会得到什么类型的标签，即无法知道fieldName的类型，由于LabelledGeneric得到的泛型表示的Key类型为Symbol，所以我们将对K设置一个边界并使用symbol.name将它转成字符串。具体如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">hlistObjectEncoder</span><span class="o">[</span><span class="kt">K</span> <span class="k">&lt;:</span> <span class="kt">Symbol</span>, <span class="kt">H</span>, <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span> 
    <span class="k">implicit</span> 
    <span class="n">witness</span><span class="k">:</span> <span class="kt">Witness.Aux</span><span class="o">[</span><span class="kt">K</span><span class="o">],</span>
    <span class="n">hEncoder</span><span class="k">:</span> <span class="kt">Lazy</span><span class="o">[</span><span class="kt">JsonEncoder</span><span class="o">[</span><span class="kt">H</span><span class="o">]],</span> 
    <span class="n">tEncoder</span><span class="k">:</span> <span class="kt">JsonObjectEncoder</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> 
<span class="o">)</span><span class="k">:</span> <span class="kt">JsonObjectEncoder</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">H</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> 
    <span class="k">val</span> <span class="nv">fieldName</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nv">witness</span><span class="o">.</span><span class="py">value</span><span class="o">.</span><span class="py">name</span> 
    <span class="o">???</span> 
<span class="o">}</span>
</code></pre></div></div><p>剩下的部分使用在第三章介绍的原则即可完成。具体如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">hlistObjectEncoder</span><span class="o">[</span><span class="kt">K</span> <span class="k">&lt;:</span> <span class="kt">Symbol</span>, <span class="kt">H</span>, <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span> 
    <span class="k">implicit</span>
    <span class="n">witness</span><span class="k">:</span> <span class="kt">Witness.Aux</span><span class="o">[</span><span class="kt">K</span><span class="o">],</span> 
    <span class="n">hEncoder</span><span class="k">:</span> <span class="kt">Lazy</span><span class="o">[</span><span class="kt">JsonEncoder</span><span class="o">[</span><span class="kt">H</span><span class="o">]],</span> 
    <span class="n">tEncoder</span><span class="k">:</span> <span class="kt">JsonObjectEncoder</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> 
<span class="o">)</span><span class="k">:</span> <span class="kt">JsonObjectEncoder</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">H</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> 
    <span class="k">val</span> <span class="nv">fieldName</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nv">witness</span><span class="o">.</span><span class="py">value</span><span class="o">.</span><span class="py">name</span> 
    <span class="n">createObjectEncoder</span> <span class="o">{</span> <span class="n">hlist</span> <span class="k">=&gt;</span> 
        <span class="k">val</span> <span class="nv">head</span> <span class="k">=</span> <span class="nv">hEncoder</span><span class="o">.</span><span class="py">value</span><span class="o">.</span><span class="py">encode</span><span class="o">(</span><span class="nv">hlist</span><span class="o">.</span><span class="py">head</span><span class="o">)</span>
        <span class="k">val</span> <span class="nv">tail</span> <span class="k">=</span> <span class="nv">tEncoder</span><span class="o">.</span><span class="py">encode</span><span class="o">(</span><span class="nv">hlist</span><span class="o">.</span><span class="py">tail</span><span class="o">)</span> 
        <span class="nc">JsonObject</span><span class="o">((</span><span class="n">fieldName</span><span class="o">,</span> <span class="n">head</span><span class="o">)</span> <span class="o">::</span> <span class="nv">tail</span><span class="o">.</span><span class="py">fields</span><span class="o">)</span> 
    <span class="o">}</span> 
<span class="o">}</span>
</code></pre></div></div><h3 id="532-为具体的乘积类型派生jsonencoder类型类实例">5.3.2 为具体的乘积类型派生JsonEncoder类型类实例</h3><p>最后我们转回泛型实例，与之前定义的方式相同，唯一不同的是这里使用LabelledGeneric代替Generic。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless.LabelledGeneric</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">genericObjectEncoder</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">H</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span> 
    <span class="k">implicit</span> 
    <span class="n">generic</span><span class="k">:</span> <span class="kt">LabelledGeneric.Aux</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">H</span><span class="o">],</span> 
    <span class="n">hEncoder</span><span class="k">:</span> <span class="kt">Lazy</span><span class="o">[</span><span class="kt">JsonObjectEncoder</span><span class="o">[</span><span class="kt">H</span><span class="o">]]</span> 
<span class="o">)</span><span class="k">:</span> <span class="kt">JsonEncoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> 
    <span class="n">createObjectEncoder</span> <span class="o">{</span> <span class="n">value</span> <span class="k">=&gt;</span> 
        <span class="nv">hEncoder</span><span class="o">.</span><span class="py">value</span><span class="o">.</span><span class="py">encode</span><span class="o">(</span><span class="nv">generic</span><span class="o">.</span><span class="py">to</span><span class="o">(</span><span class="n">value</span><span class="o">))</span> 
    <span class="o">}</span>
</code></pre></div></div><p>这正是我们需要的，有了这些定义我们就能将任何样例类的实例输出为JSON并在结果中保存字段名称。调用代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">JsonEncoder</span><span class="o">[</span><span class="kt">IceCream</span><span class="o">].</span><span class="py">encode</span><span class="o">(</span><span class="n">iceCream</span><span class="o">)</span> 

<span class="c1">// res14: JsonValue = JsonObject(List((name,JsonString(Sundae)), ( </span>
<span class="c1">//  numCherries,JsonNumber(1.0)), (inCone,JsonBoolean(false))))</span>
</code></pre></div></div><h2 id="54-使用labelledgeneric为余积类型派生类型类实例">5.4 使用LabelledGeneric为余积类型派生类型类实例</h2><p>将LabelledGeneric与Coproducts结合使用涉及我们已经介绍的概念的混合。 首先，我们检查一下LabelledGeneric派生的Coproduct类型。 我们将从第3章重新介绍Shape ADT：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless.LabelledGeneric</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Shape</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="n">width</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Shape</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Circle</span><span class="o">(</span><span class="n">radius</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Shape</span>

<span class="nc">LabelledGeneric</span><span class="o">[</span><span class="kt">Shape</span><span class="o">].</span><span class="py">to</span><span class="o">(</span><span class="nc">Circle</span><span class="o">(</span><span class="mf">1.0</span><span class="o">))</span>
<span class="c1">// res5: Rectangle with shapeless.labelled.KeyTag[Symbol with </span>
<span class="c1">//  shapeless.tag.Tagged[String("Rectangle")],Rectangle] :+: Circle with </span>
<span class="c1">//  shapeless.labelled.KeyTag[Symbol with shapeless.tag.Tagged[ </span>
<span class="c1">//  String("Circle")],Circle] :+: shapeless.CNil = Inr(Inl(Circle (1.0)))</span>
</code></pre></div></div><p>这是更易于阅读的Coproduct类型的格式</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Rectangle with KeyTag[Symbol with Tagged["Rectangle"], Rectangle] </span>
<span class="c1">//  :+:</span>
<span class="c1">// Circle with KeyTag[Symbol with Tagged["Circle"], Circle] </span>
<span class="c1">//  :+:</span>
<span class="c1">// CNil</span>
</code></pre></div></div><p>如您所见，结果是Shape子类型的余积，每个子类型都用类型名称标记。 我们可以使用此信息为:+:和CNil编写JsonEncoders：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless.</span><span class="o">{</span><span class="nc">Coproduct</span><span class="o">,</span> <span class="o">:+:,</span> <span class="nc">CNil</span><span class="o">,</span> <span class="nc">Inl</span><span class="o">,</span> <span class="nc">Inr</span><span class="o">,</span> <span class="nc">Witness</span><span class="o">,</span> <span class="nc">Lazy</span><span class="o">}</span> 
<span class="k">import</span> <span class="nn">shapeless.labelled.FieldType</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">cnilObjectEncoder</span><span class="k">:</span> <span class="kt">JsonObjectEncoder</span><span class="o">[</span><span class="kt">CNil</span><span class="o">]</span> <span class="k">=</span> <span class="nf">createObjectEncoder</span><span class="o">(</span><span class="n">cnil</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"Inconceivable!"</span><span class="o">))</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">coproductObjectEncoder</span><span class="o">[</span><span class="kt">K</span> <span class="k">&lt;:</span> <span class="kt">Symbol</span>, <span class="kt">H</span>, <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Coproduct</span><span class="o">](</span><span class="k">implicit</span>
  <span class="n">witness</span><span class="k">:</span> <span class="kt">Witness.Aux</span><span class="o">[</span><span class="kt">K</span><span class="o">],</span>
  <span class="n">hEncoder</span><span class="k">:</span> <span class="kt">Lazy</span><span class="o">[</span><span class="kt">JsonEncoder</span><span class="o">[</span><span class="kt">H</span><span class="o">]],</span>
  <span class="n">tEncoder</span><span class="k">:</span> <span class="kt">JsonObjectEncoder</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">JsonObjectEncoder</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">H</span><span class="o">]</span> <span class="kt">:+:</span> <span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">typeName</span> <span class="k">=</span> <span class="nv">witness</span><span class="o">.</span><span class="py">value</span><span class="o">.</span><span class="py">name</span>
  <span class="n">createObjectEncoder</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Inl</span><span class="o">(</span><span class="n">h</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nc">JsonObject</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">typeName</span> <span class="o">-&gt;</span> <span class="nv">hEncoder</span><span class="o">.</span><span class="py">value</span><span class="o">.</span><span class="py">encode</span><span class="o">(</span><span class="n">h</span><span class="o">)))</span>
    <span class="k">case</span> <span class="nc">Inr</span><span class="o">(</span><span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nv">tEncoder</span><span class="o">.</span><span class="py">encode</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>coproductEncoder与hlistEncoder遵循相同的模式。我们有三个类型参数：K表示类型名称，H表示HList的头部（类型）值，T表示结尾的（类型）值。 我们在结果类型中使用FieldType和:+:来声明这三个之间的关系，并使用Witness来访问类型名称的运行时值。 结果是一个包含单个键/值对的对象，键是类型名称，值是结果：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">shape</span><span class="k">:</span> <span class="kt">Shape</span> <span class="o">=</span> <span class="nc">Circle</span><span class="o">(</span><span class="mf">1.0</span><span class="o">)</span>

<span class="nc">JsonEncoder</span><span class="o">[</span><span class="kt">Shape</span><span class="o">].</span><span class="py">encode</span><span class="o">(</span><span class="n">shape</span><span class="o">)</span>
<span class="c1">// res8: JsonValue = JsonObject(List((Circle,JsonObject(List((radius, </span>
<span class="c1">//   JsonNumber(1.0)))))))</span>
</code></pre></div></div><p>其他的编码可能需要更多的工作。 例如，我们可以在输出中添加“类型”字段，甚至允许用户配置格式。Sam Halliday’s <a href="https://github.com/milessabin/spray-json-shapeless">spray-json-shapeless</a>是一个出色的代码库示例，该代码库在可实现的同时还提供了极大的灵活性。</p><h2 id="55-小结">5.5 小结</h2><p>这一章我们讨论了LabelledGeneric，它是Generic类的一个变体，用来在其泛型表示中提取类型名称和字段名称。</p><p>LabelledGeneric提取的名称被编码为类型级别的标签，所以我们能在隐式解析的过程中找到它们。这一章我们以讨论字面类型和shapeless在它的标签中如何使用字面类型开始，也介绍了Witness类型类，它用来将字面类型具体化为值。</p><p>最后，我们组合LabelledGeneric、字面类型和Witness创建了一个JsonEncoder库，它能在输出中保持字段的名称。</p><p>本章的关键点在于这些代码都不是通过运行时反射的方式实现的，是用类型、隐式值和几个shapeless内部的宏来实现的，所以这些代码在运行时速度快、可靠性高。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://dreamylost.cn" target="_blank">梦境迷离</a></li><li>本文链接：<a href="https://dreamylost.cn/shapeless/Shapeless-%E5%9C%A8%E9%9A%90%E5%BC%8F%E6%B4%BE%E7%94%9F%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%90%8D%E7%A7%B0.html" target="_blank">https://dreamylost.cn/shapeless/Shapeless-%E5%9C%A8%E9%9A%90%E5%BC%8F%E6%B4%BE%E7%94%9F%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%90%8D%E7%A7%B0.html</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/shapeless/Shapeless-%E5%9C%A8%E9%9A%90%E5%BC%8F%E', clientID: '061aadb5d449c0877d7d', clientSecret: '9aa7af7c248a7e36a07a86993e11a7acf7fbd353', repo: 'dreamylost-comments', owner: 'jxnu-liguobin', admin: ['jxnu-liguobin'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@built/assets/search_data.json?v=1617167037', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2019 <span title="梦境迷离">梦境迷离</span> <a href="http://www.beian.miit.gov.cn/publish/query/indexFirst.action" rel="nofollow" target="_blank">赣ICP备17017283号-1</a> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/jxnu-liguobin/jxnu-liguobin.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://dreamylost.cn/" title="首页" target="">首页</a></li><li> <a href="https://dreamylost.cn/categories/" title="分类" target="">分类</a></li><li> <a href="https://dreamylost.cn/wiki/" title="维基" target="">维基</a></li><li> <a href="https://dreamylost.cn/links/" title="链接" target="">链接</a></li><li> <a href="https://dreamylost.cn/about/" title="关于" target="">关于</a></li><li><a href="https://dreamylost.cn/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2019-09-20 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
