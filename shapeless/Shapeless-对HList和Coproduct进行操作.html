<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>对HList和Coproduct进行操作 &mdash; 梦境迷离</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="canonical" href="https://dreamylost.cn/shapeless/Shapeless-%E5%AF%B9HList%E5%92%8CCoproduct%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C.html"><link rel="alternate" type="application/atom+xml" title="梦境迷离" href="https://dreamylost.cn/feed.xml"><link rel="shortcut icon" href="https://dreamylost.cn/favicon.ico"><meta property="og:title" content="对HList和Coproduct进行操作"><meta name="keywords" content="梦境迷离, jxnu-liguobin"><meta name="og:keywords" content="梦境迷离, jxnu-liguobin"><meta name="description" content=""><meta name="og:description" content=""><meta property="og:url" content="https://dreamylost.cn/shapeless/Shapeless-%E5%AF%B9HList%E5%92%8CCoproduct%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C.html"><meta property="og:site_name" content="梦境迷离"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2020-07-05"> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/main.js"></script> <script data-ad-client="ca-pub-8236444920328818" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://dreamylost.cn/" title="梦境迷离"><span class="octicon octicon-mark-github"></span> 梦境迷离</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://dreamylost.cn/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://dreamylost.cn/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://dreamylost.cn/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://dreamylost.cn/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://dreamylost.cn/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="对HList和Coproduc"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">对HList和Coproduct进行操作</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2020/07/05 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://dreamylost.cn/categories/#Shapeless" title="Shapeless">Shapeless</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 12707 字，约 37 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"> <img style="height:72px;width:72px" src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/images/qrcode.jpg" alt="梦境迷离" /></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" > <ins class="adsbygoogle content-header-ad" data-ad-client="ca-pub-8236444920328818" data-ad-slot="3977594606"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> <br /><article class="article-content markdown-body"><ul id="markdown-toc"><li><a href="#61-简单的操作样例" id="markdown-toc-61-简单的操作样例">6.1 简单的“操作”样例</a></li><li><a href="#62-创建一个自定义的操作引理lemma模式" id="markdown-toc-62-创建一个自定义的操作引理lemma模式">6.2 创建一个自定义的“操作”（引理（lemma）模式）</a></li><li><a href="#63-案例学习样例类迁移" id="markdown-toc-63-案例学习样例类迁移">6.3 案例学习：样例类迁移</a><ul><li><a href="#631-migration类型类" id="markdown-toc-631-migration类型类">6.3.1 Migration类型类</a></li><li><a href="#632-第一步移除字段" id="markdown-toc-632-第一步移除字段">6.3.2 第一步：移除字段</a></li><li><a href="#632-第二步调整字段顺序" id="markdown-toc-632-第二步调整字段顺序">6.3.2 第二步：调整字段顺序</a></li><li><a href="#634-第三步增加字段" id="markdown-toc-634-第三步增加字段">6.3.4 第三步：增加字段</a></li></ul></li><li><a href="#64-record-ops" id="markdown-toc-64-record-ops">6.4 Record ops</a><ul><li><a href="#641-选择字段" id="markdown-toc-641-选择字段">6.4.1 选择字段</a></li><li><a href="#642-更新和删除字段" id="markdown-toc-642-更新和删除字段">6.4.2 更新和删除字段</a></li><li><a href="#643-转换为普通的map对象" id="markdown-toc-643-转换为普通的map对象">6.4.3 转换为普通的Map对象</a></li><li><a href="#644-其它操作" id="markdown-toc-644-其它操作">6.4.4 其它操作</a></li></ul></li><li><a href="#65-小结" id="markdown-toc-65-小结">6.5 小结</a></li></ul><blockquote><p>在线电子书 https://dreamylost.gitbook.io/dreamylost/</p></blockquote><blockquote><p>shapeless v2.3.2</p></blockquote><p>第一部分我们学习了为ADT派生类型类实例的方法，可以使用类型类派生的方式来致力于增强几乎任何类型类，尽管复杂的情况下为了操作HList和Coproduct必须写一系列的支持代码。</p><p>第二部分我们将着重介绍shapeless.ops包，它提供了一套有用的工具，可以将其直接用作代码块。每一个“操作（op）”分为两部分：一个在隐式解析过程中使用的类型类和为HList和Coproduct调用而准备的扩展方法。</p><p>有三套通用的方法组对应三个包，分别为：</p><ul><li>shapeless.ops.hlist：它为HList定义了类型类，这些操作可以通过定义在shapeless.syntax.hlist中的扩展方法被HList直接使用。</li><li>shapeless.ops.coproduct：它为Coproduct定义了类型类，这些操作可以通过定义在shapeless.syntax.coproduct中的扩展方法被Coproduct直接使用。</li><li>shapeless.ops.record：它为shapeless记录（在5.2节中介绍的元素被标记的HList）定义了类型类，这些操作可以通过定义在shapeless.syntax.record中的扩展方法被HList使用，只需要显式引入shapeless.record。</li></ul><p>此书没有过多的空间逐一讲解所有“操作”。幸运的是大多数情况下我们的源码都通俗易懂并配有详细的文档。此处不准备提供详尽的指导而是介绍一些主要的理论和要点并向你展示如何从shapeless的基础代码中获取更进一步的信息。</p><h2 id="61-简单的操作样例">6.1 简单的“操作”样例</h2><p>HList有init和last两个扩展方法，它们分别基于shapeless.ops.hlist.Init和shapeless.ops.hlist.Last类型类。Coproduct有相似的方法和类型类。它们都是ops模式的完美样例。下面是这两个扩展方法的简单定义：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="nn">shapeless</span> 
<span class="k">package</span> <span class="nn">syntax</span>

<span class="k">implicit</span> <span class="k">class</span> <span class="nc">HListOps</span><span class="o">[</span><span class="kt">L</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span><span class="n">l</span> <span class="k">:</span> <span class="kt">L</span><span class="o">)</span> <span class="o">{</span> 
    <span class="k">def</span> <span class="nf">last</span><span class="o">(</span><span class="k">implicit</span> <span class="n">last</span><span class="k">:</span> <span class="kt">Last</span><span class="o">[</span><span class="kt">L</span><span class="o">])</span><span class="k">:</span> <span class="kt">last.Out</span> <span class="o">=</span> <span class="nv">last</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="n">l</span><span class="o">)</span> 
    <span class="k">def</span> <span class="nf">init</span><span class="o">(</span><span class="k">implicit</span> <span class="n">init</span><span class="k">:</span> <span class="kt">Init</span><span class="o">[</span><span class="kt">L</span><span class="o">])</span><span class="k">:</span> <span class="kt">init.Out</span> <span class="o">=</span> <span class="nv">init</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="n">l</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div><p>每一个方法的返回类型都由隐式参数的一个依赖类型决定，为每一个类型类定义的实例提供了类型的真实对应关系。下面以Last类型类的框架为例：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Last</span><span class="o">[</span><span class="kt">L</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">]</span> <span class="o">{</span> 
    <span class="k">type</span> <span class="kt">Out</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">L</span><span class="o">)</span><span class="k">:</span> <span class="kt">Out</span> 
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Last</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">Aux</span><span class="o">[</span><span class="kt">L</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">O</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Last</span><span class="o">[</span><span class="kt">L</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="n">O</span> <span class="o">}</span> 
    <span class="k">implicit</span> <span class="k">def</span> <span class="nf">pair</span><span class="o">[</span><span class="kt">H</span><span class="o">]</span><span class="k">:</span> <span class="kt">Aux</span><span class="o">[</span><span class="kt">H</span> <span class="kt">::</span> <span class="kt">HNil</span>, <span class="kt">H</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span> 
    <span class="k">implicit</span> <span class="k">def</span> <span class="nf">list</span><span class="o">[</span><span class="kt">H</span>, <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">]</span>
        <span class="o">(</span><span class="k">implicit</span> <span class="n">last</span><span class="k">:</span> <span class="kt">Last</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Aux</span><span class="o">[</span><span class="kt">H</span> <span class="kt">::</span> <span class="kt">T</span>, <span class="kt">last.Out</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div><p>仔细观察这些实现。首先我们通常可以实现具有几个实际成员的（上例中只有两个）的ops类型类。因此我们能把类型类的伴生对象中所有可能需要的实际成员打包在一起，最终直接调用对应的扩展方法而无需引入shapeless.ops包。调用如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless._</span>

<span class="o">(</span><span class="s">"Hello"</span> <span class="o">::</span> <span class="mi">123</span> <span class="o">::</span> <span class="kc">true</span> <span class="o">::</span> <span class="nc">HNil</span><span class="o">).</span><span class="py">last</span> 
<span class="c1">// res0: Boolean = true</span>

<span class="o">(</span><span class="s">"Hello"</span> <span class="o">::</span> <span class="mi">123</span> <span class="o">::</span> <span class="kc">true</span> <span class="o">::</span> <span class="nc">HNil</span><span class="o">).</span><span class="py">init</span> 
<span class="c1">// res1: String :: Int :: shapeless.HNil = Hello :: 123 :: HNil</span>
</code></pre></div></div><p>第二，这些类型类只能用在至少包含一个元素的HList实例，使得在一定程度上具有对代码进行检查的功能。当我们尝试对一个空的HList调用last方法，编译器会直接报错。如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">HNil</span><span class="o">.</span><span class="py">last</span> 
<span class="c1">// &lt;console&gt;:16: error: Implicit not found: shapeless.Ops.Last[ shapeless.HNil.type]. </span>
<span class="c1">//    shapeless.HNil.type is empty, so there is no last element.</span>
<span class="c1">//        HNil.last</span>
<span class="c1">//             ^</span>
</code></pre></div></div><h2 id="62-创建一个自定义的操作引理lemma模式">6.2 创建一个自定义的“操作”（引理（lemma）模式）</h2><p>如果我们找到一个能满足需求的特殊的“操作”序列，就可以将它们打成一个包并作为一个新的ops类型类，这是我们在4.4节中介绍过的“引理（lemma）”模式的例子。</p><p>下面以创建自定义“操作”来作为练习。合并Last和Init来创建一个Penultimate类型类，它能从HList中取出倒数第二个元素。下面是用Aux类型别名和apply方法完成的定义代码：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless._</span>

<span class="k">trait</span> <span class="nc">Penultimate</span><span class="o">[</span><span class="kt">L</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">Out</span> 
    <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">L</span><span class="o">)</span><span class="k">:</span> <span class="kt">Out</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Penultimate</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">Aux</span><span class="o">[</span><span class="kt">L</span>, <span class="kt">O</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Penultimate</span><span class="o">[</span><span class="kt">L</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="n">O</span> <span class="o">}</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">L</span><span class="o">](</span><span class="k">implicit</span> <span class="n">p</span><span class="k">:</span> <span class="kt">Penultimate</span><span class="o">[</span><span class="kt">L</span><span class="o">])</span><span class="k">:</span> <span class="kt">Aux</span><span class="o">[</span><span class="kt">L</span>, <span class="kt">p.Out</span><span class="o">]</span> <span class="k">=</span> <span class="n">p</span>
<span class="o">}</span>
</code></pre></div></div><p>再次注意上面的apply方法返回了一个Aux[L, O]类型而不是Penultimate[L]类型，这一点能够确保类型成员Out在4.2节中所介绍的对于所获取的实例是可见的，没有被擦除。</p><p>我们只需要定义一个Penultimate实例，该实例使用4.3节中所介绍的技巧将Init和Last结合起来。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless.ops.hlist</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">hlistPenultimate</span><span class="o">[</span><span class="kt">L</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">M</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">O</span><span class="o">](</span> 
    <span class="k">implicit</span>
    <span class="n">init</span><span class="k">:</span> <span class="kt">hlist.Init.Aux</span><span class="o">[</span><span class="kt">L</span>, <span class="kt">M</span><span class="o">],</span> 
    <span class="n">last</span><span class="k">:</span> <span class="kt">hlist.Last.Aux</span><span class="o">[</span><span class="kt">M</span>, <span class="kt">O</span><span class="o">]</span> 
<span class="o">)</span><span class="k">:</span> <span class="kt">Penultimate.Aux</span><span class="o">[</span><span class="kt">L</span>, <span class="kt">O</span><span class="o">]</span> <span class="k">=</span> 
    <span class="k">new</span> <span class="nc">Penultimate</span><span class="o">[</span><span class="kt">L</span><span class="o">]</span> <span class="o">{</span> 
        <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="n">O</span>
        <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">L</span><span class="o">)</span><span class="k">:</span> <span class="kt">O</span> <span class="o">=</span> 
            <span class="nv">last</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="nv">init</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="n">l</span><span class="o">))</span>
    <span class="o">}</span>
</code></pre></div></div><p>我们能用下面的方式使用该实例：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">BigList</span> <span class="o">=</span> <span class="nc">String</span> <span class="o">::</span> <span class="nc">Int</span> <span class="o">::</span> <span class="nc">Boolean</span> <span class="o">::</span> <span class="nc">Double</span> <span class="o">::</span> <span class="nc">HNil</span>

<span class="k">val</span> <span class="nv">bigList</span><span class="k">:</span> <span class="kt">BigList</span> <span class="o">=</span> <span class="s">"foo"</span> <span class="o">::</span> <span class="mi">123</span> <span class="o">::</span> <span class="kc">true</span> <span class="o">::</span> <span class="mf">456.0</span> <span class="o">::</span> <span class="nc">HNil</span>

<span class="nc">Penultimate</span><span class="o">[</span><span class="kt">BigList</span><span class="o">].</span><span class="py">apply</span><span class="o">(</span><span class="n">bigList</span><span class="o">)</span> 
<span class="c1">// res4: Boolean = true</span>
</code></pre></div></div><p>获取Penultimate实例需要编译器同时完成获取Last和Init的实例，所以对于长度不满足的HList继承了与Last和Init的同一类型检查标准。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">TinyList</span> <span class="o">=</span> <span class="nc">String</span> <span class="o">::</span> <span class="nc">HNil</span>

<span class="k">val</span> <span class="nv">tinyList</span> <span class="k">=</span> <span class="s">"bar"</span> <span class="o">::</span> <span class="nc">HNil</span>

<span class="nc">Penultimate</span><span class="o">[</span><span class="kt">TinyList</span><span class="o">].</span><span class="py">apply</span><span class="o">(</span><span class="n">tinyList</span><span class="o">)</span> 
<span class="c1">// &lt;console&gt;:21: error: could not find implicit value for parameter p: Penultimate[TinyList]</span>
<span class="c1">//        Penultimate[TinyList].apply(tinyList)</span>
<span class="c1">//                   ^</span>
</code></pre></div></div><p>对于底层用户我们可以为HList定义扩展方法，使调用变的更容易。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">class</span> <span class="nc">PenultimateOps</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span> 
    <span class="k">def</span> <span class="nf">penultimate</span><span class="o">(</span><span class="k">implicit</span> <span class="n">inst</span><span class="k">:</span> <span class="kt">Penultimate</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">inst.Out</span> <span class="o">=</span> 
        <span class="nv">inst</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">bigList</span><span class="o">.</span><span class="py">penultimate</span> 
<span class="c1">// res7: Boolean = true</span>
</code></pre></div></div><p>通过提供一个基于Generic的实例就可以为所有的乘积类型提供Penultimate类型类操作。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">genericPenultimate</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">R</span>, <span class="kt">O</span><span class="o">](</span> 
    <span class="k">implicit</span>
    <span class="n">generic</span><span class="k">:</span> <span class="kt">Generic.Aux</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">R</span><span class="o">],</span> 
    <span class="n">penultimate</span><span class="k">:</span> <span class="kt">Penultimate.Aux</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">O</span><span class="o">]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">Penultimate.Aux</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">O</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Penultimate</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span> 
        <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="n">O</span> 
        <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">O</span> <span class="o">=</span> 
            <span class="nv">penultimate</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="nv">generic</span><span class="o">.</span><span class="py">to</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
    <span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">IceCream</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">numCherries</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">inCone</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span>

<span class="nc">IceCream</span><span class="o">(</span><span class="s">"Sundae"</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">false</span><span class="o">).</span><span class="py">penultimate</span> 
<span class="c1">// res9: Int = 1</span>
</code></pre></div></div><p>重要的是通过定义Penultimate类型类，我们创建了一个可以在任何地方复用的工具。shapeless为各种各样的目的提供了相应的“操作”，我们把自己定义的“操作”添加到工具箱里也很容易。</p><h2 id="63-案例学习样例类迁移">6.3 案例学习：样例类迁移</h2><p>当在我们的代码中将多个“操作”链接成代码块的时候它的力量就已经显露无遗。下面我们将以一个极具吸引力的例子结束这一章：创建一个类型类用于展示样例类的迁移（这个词借用“数据库迁移”——数据库结构的自动升级的SQL脚本）或称之为进化。例如，如果我们的某个应用的第一版包含下面的样例类：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">IceCreamV1</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">numCherries</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">inCone</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span>
</code></pre></div></div><p>我们的迁移类库应该能够自由的实现手工升级。比如现有以下的后续版本的样例类：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Remove fields:</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">IceCreamV2a</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">inCone</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span>

<span class="c1">// Reorder fields:</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">IceCreamV2b</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">inCone</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">numCherries</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

<span class="c1">// Insert fields (provided we can determine a default value):</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">IceCreamV2c</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">inCone</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">numCherries</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">numWaffles</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</code></pre></div></div><p>理想情况下我们用下述代码迁移我们的IceCreamV1：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IceCreamV1</span><span class="o">(</span><span class="s">"Sundae"</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">false</span><span class="o">).</span><span class="py">migrateTo</span><span class="o">[</span><span class="kt">IceCreamV2a</span><span class="o">]</span>
</code></pre></div></div><p>迁移类型类应该使得迁移过程没有冗余代码。</p><h3 id="631-migration类型类">6.3.1 Migration类型类</h3><p>Migration类型类展示了从源类型到目标类型的转换过程。这两个在我们的派生过程都将作为输入类型，所以都是类型参数。我们不需要Aux类型别名因为没有需要提取的类型成员。Migration类型类的代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Migration</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> 
<span class="o">}</span>
</code></pre></div></div><p>我们这里也提供一个扩展方法使得例子更易读。代码如下:</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">class</span> <span class="nc">MigrationOps</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">migrateTo</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="k">implicit</span> <span class="n">migration</span><span class="k">:</span> <span class="kt">Migration</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> 
        <span class="nv">migration</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> 
<span class="o">}</span>
</code></pre></div></div><h3 id="632-第一步移除字段">6.3.2 第一步：移除字段</h3><p>让我们逐步地找到问题的解决方案。第一步从移除字段开始，移除字段又可以细分为以下几步：</p><ol><li>将A实例转换为它的泛型表示；</li><li>过滤上面得到的HList，只保留B中同样包含的字段；</li><li>将过滤后的输出结果转换为B。</li></ol><p>使用Generic或者LabelledGeneric实现第1步和第3步，并用一个叫做Intersection的“操作”实现第2步。LabelledGeneric看上去是一个明智的选择，因为我们需要根据名称来识别字段。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless._</span> 
<span class="k">import</span> <span class="nn">shapeless.ops.hlist</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">genericMigration</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">ARepr</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">BRepr</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span>
    <span class="k">implicit</span> 
    <span class="n">aGen</span> <span class="k">:</span> <span class="kt">Generic.Aux</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">ARepr</span><span class="o">],</span>
    <span class="n">bGen</span> <span class="k">:</span> <span class="kt">Generic.Aux</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">BRepr</span><span class="o">],</span> 
    <span class="n">inter</span> <span class="k">:</span> <span class="kt">hlist.Intersection.Aux</span><span class="o">[</span><span class="kt">ARepr</span>, <span class="kt">BRepr</span>, <span class="kt">BRepr</span><span class="o">]</span> 
<span class="o">)</span><span class="k">:</span> <span class="kt">Migration</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Migration</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span> 
    <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> 
        <span class="nv">bGen</span><span class="o">.</span><span class="py">from</span><span class="o">(</span><span class="nv">inter</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="nv">aGen</span><span class="o">.</span><span class="py">to</span><span class="o">(</span><span class="n">a</span><span class="o">)))</span> 
<span class="o">}</span>
</code></pre></div></div><p>shapeless源码中的Intersection类型（见<a href="https://github.com/milessabin/shapeless/blob/shapeless-2.3.2/core/src/main/scala/shapeless/ops/hlists.scala#L1297-L1352">https://github.com/milessabin/shapeless/blob/shapeless-2.3.2/core/src/main/scala/shapeless/ops/hlists.scala#L1297-L1352</a>）。它的Aux类型别名有三个参数：两个HList类型的输入和二者相交的HList类型的输出。上述样例代码中我们将ARepr和BRepr指定为输入类型、BRepr指定为输出类型，这意味着只有在B的字段完全是A中的字段的子集的时候隐式解析才能成功，此处完全指的是名称和顺序均需一致。将IceCreamV1迁移到IceCreamV2a的代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IceCreamV1</span><span class="o">(</span><span class="s">"Sundae"</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">true</span><span class="o">).</span><span class="py">migrateTo</span><span class="o">[</span><span class="kt">IceCreamV2a</span><span class="o">]</span> 
<span class="c1">// res6: IceCreamV2a = IceCreamV2a(Sundae,true)</span>
</code></pre></div></div><p>但是如果我们尝试迁移字段不完全匹配的类型，编译器就会报错。比如将IceCreamV1迁移到IceCreamV2b就会造成下面的结果：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IceCreamV1</span><span class="o">(</span><span class="s">"Sundae"</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">true</span><span class="o">).</span><span class="py">migrateTo</span><span class="o">[</span><span class="kt">IceCreamV2b</span><span class="o">]</span> 
<span class="c1">// &lt;console&gt;:23: error: could not find implicit value for parameter</span>
<span class="c1">//    migration: Migration[IceCreamV1,IceCreamV2b]</span>
<span class="c1">//         IceCreamV1("Sundae", 1, true).migrateTo[IceCreamV2b] </span>
<span class="c1">//                                       ^</span>
</code></pre></div></div><h3 id="632-第二步调整字段顺序">6.3.2 第二步：调整字段顺序</h3><p>我们需要使用另一个ops类型类使迁移支持调整字段顺序。<a href="https://github.com/milessabin/shapeless/blob/shapeless-2.3.2/core/src/main/scala/shapeless/ops/hlists.scala#L1973-L1997">Align</a>“操作”能调整一个HList中的字段顺序使之与另一个HList中的字段顺序相匹配。可以使用Align修改上面的genericMigration定义使之完成此功能。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">genericMigration</span><span class="o">[</span> 
    <span class="kt">A</span>, <span class="kt">B</span>, 
    <span class="kt">ARepr</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">BRepr</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, 
    <span class="kt">Unaligned</span> <span class="k">&lt;:</span> <span class="kt">HList</span> 
<span class="o">](</span>
    <span class="k">implicit</span>
    <span class="n">aGen</span> <span class="k">:</span> <span class="kt">LabelledGeneric.Aux</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">ARepr</span><span class="o">],</span>
    <span class="n">bGen</span> <span class="k">:</span> <span class="kt">LabelledGeneric.Aux</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">BRepr</span><span class="o">],</span>
    <span class="n">inter</span> <span class="k">:</span> <span class="kt">hlist.Intersection.Aux</span><span class="o">[</span><span class="kt">ARepr</span>, <span class="kt">BRepr</span>, <span class="kt">Unaligned</span><span class="o">],</span> 
    <span class="n">align</span> <span class="k">:</span> <span class="kt">hlist.Align</span><span class="o">[</span><span class="kt">Unaligned</span>, <span class="kt">BRepr</span><span class="o">]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">Migration</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Migration</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span> 
    <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> 
        <span class="nv">bGen</span><span class="o">.</span><span class="py">from</span><span class="o">(</span><span class="nv">align</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="nv">inter</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="nv">aGen</span><span class="o">.</span><span class="py">to</span><span class="o">(</span><span class="n">a</span><span class="o">))))</span> 
<span class="o">}</span>
</code></pre></div></div><p>此处引入了一个叫做Unaligned的新的类型参数来表示在调整顺序之前ARepr和BRepr两个类型字段相交的结果类型，并使用Align将Unaligned实例转换为BRepr。修改之后我们就能同时迁移减少字段和调整字段顺序。以下两个例子都会正常运行：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IceCreamV1</span><span class="o">(</span><span class="s">"Sundae"</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">true</span><span class="o">).</span><span class="py">migrateTo</span><span class="o">[</span><span class="kt">IceCreamV2a</span><span class="o">]</span> 
<span class="c1">// res8: IceCreamV2a = IceCreamV2a(Sundae,true)</span>

<span class="nc">IceCreamV1</span><span class="o">(</span><span class="s">"Sundae"</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">true</span><span class="o">).</span><span class="py">migrateTo</span><span class="o">[</span><span class="kt">IceCreamV2b</span><span class="o">]</span> 
<span class="c1">// res9: IceCreamV2b = IceCreamV2b(Sundae,true,1)</span>
</code></pre></div></div><p>然而，如果我们尝试对添加字段的类型进行迁移，还是会报错。比如将IceCreamV1转化为IceCreamV2c的结果如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IceCreamV1</span><span class="o">(</span><span class="s">"Sundae"</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">true</span><span class="o">).</span><span class="py">migrateTo</span><span class="o">[</span><span class="kt">IceCreamV2c</span><span class="o">]</span> 
<span class="c1">// &lt;console&gt;:25: error: could not find implicit value for parameter</span>
<span class="c1">//    migration: Migration[IceCreamV1,IceCreamV2c]</span>
<span class="c1">//         IceCreamV1("Sundae", 1, true).migrateTo[IceCreamV2c] </span>
<span class="c1">//                                                ^</span>
</code></pre></div></div><h3 id="634-第三步增加字段">6.3.4 第三步：增加字段</h3><p>为了计算新增字段的默认值我们需要一些技巧。shapeless没有为这种情况提供类型类，但是Cat框架以幺半群（Monoid）的方式提供了这种类型类。下面是Monoid的简单定义：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="nn">cats</span>

<span class="k">trait</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">empty</span><span class="k">:</span> <span class="kt">A</span>
    <span class="k">def</span> <span class="nf">combine</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> 
<span class="o">}</span>
</code></pre></div></div><p>Monoid定义了两个操作：为创建一个“零”值定义的empty操作以及为两个值“相加”而定义的combine操作。在我们的代码中只需empty操作（默认值），但是定义一个combine操作也不麻烦。</p><p>Cat为我们关心的所有基础类型（Int、Double、Boolean和String）提供了Monoid实例。我们可以使用第五章中的技巧为HNil和::定义Monoid实例。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Monoid</span> 
<span class="k">import</span> <span class="nn">cats.instances.all._</span> 
<span class="k">import</span> <span class="nn">shapeless.labelled.</span><span class="o">{</span><span class="n">field</span><span class="o">,</span> <span class="nc">FieldType</span><span class="o">}</span>

<span class="k">def</span> <span class="nf">createMonoid</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">zero</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="n">add</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> 
    <span class="k">new</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">empty</span> <span class="k">=</span> <span class="n">zero</span>
        <span class="k">def</span> <span class="nf">combine</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="nf">add</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
    <span class="o">}</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">hnilMonoid</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span> 
    <span class="n">createMonoid</span><span class="o">[</span><span class="kt">HNil</span><span class="o">](</span><span class="nc">HNil</span><span class="o">)((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">HNil</span><span class="o">)</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">emptyHList</span><span class="o">[</span><span class="kt">K</span> <span class="k">&lt;:</span> <span class="kt">Symbol</span>, <span class="kt">H</span>, <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span> 
    <span class="k">implicit</span>
    <span class="n">hMonoid</span><span class="k">:</span> <span class="kt">Lazy</span><span class="o">[</span><span class="kt">Monoid</span><span class="o">[</span><span class="kt">H</span><span class="o">]],</span> 
    <span class="n">tMonoid</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">FieldType</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">H</span><span class="o">]</span> <span class="kt">::</span> <span class="kt">T</span><span class="o">]</span> <span class="k">=</span> 
    <span class="nf">createMonoid</span><span class="o">(</span><span class="n">field</span><span class="o">[</span><span class="kt">K</span><span class="o">](</span><span class="nv">hMonoid</span><span class="o">.</span><span class="py">value</span><span class="o">.</span><span class="py">empty</span><span class="o">)</span> <span class="o">::</span> <span class="nv">tMonoid</span><span class="o">.</span><span class="py">empty</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> 
            <span class="n">field</span><span class="o">[</span><span class="kt">K</span><span class="o">](</span><span class="nv">hMonoid</span><span class="o">.</span><span class="py">value</span><span class="o">.</span><span class="py">combine</span><span class="o">(</span><span class="nv">x</span><span class="o">.</span><span class="py">head</span><span class="o">,</span> <span class="nv">y</span><span class="o">.</span><span class="py">head</span><span class="o">))</span> <span class="o">::</span> 
                <span class="nv">tMonoid</span><span class="o">.</span><span class="py">combine</span><span class="o">(</span><span class="nv">x</span><span class="o">.</span><span class="py">tail</span><span class="o">,</span> <span class="nv">y</span><span class="o">.</span><span class="py">tail</span><span class="o">)</span>
    <span class="o">}</span>
</code></pre></div></div><p>我们需要将Monoid与一系列的其它ops结合来完成我们最终版的Migration。下面是所有步骤：</p><ol><li>使用LabelledGeneric将A转换为它的泛型表示；</li><li>使用Intersection计算A和B共有字段的HList；</li><li>推断在B中出现但是A中没有出现的字段的类型；</li><li>使用Monoid来推断3中结果类型的默认值；</li><li>将4中得到的新字段与2中得到的共同字段进行结合；</li><li>使用Align调整5中的结果类型的顺序使之与B相同；</li><li>使用LabelledGeneric将6中的输出结果转换为B。</li></ol><p>我们已经学习了如何实现1、2、4、6和7步，可以使用一个叫做Diff的与Intersection相似的操作来实现第3步，并使用另一个叫做Prepend的操作来实现第5步。下面是完整的解决方案：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">genericMigration</span><span class="o">[</span> 
    <span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">ARepr</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">BRepr</span> <span class="k">&lt;:</span> <span class="kt">HList</span>,
    <span class="kt">Common</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">Added</span> <span class="k">&lt;:</span> <span class="kt">HList</span>, <span class="kt">Unaligned</span> <span class="k">&lt;:</span> <span class="kt">HList</span>
<span class="o">](</span>
    <span class="k">implicit</span> 
    <span class="n">aGen</span> <span class="k">:</span> <span class="kt">LabelledGeneric.Aux</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">ARepr</span><span class="o">],</span>
    <span class="n">bGen</span> <span class="k">:</span> <span class="kt">LabelledGeneric.Aux</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">BRepr</span><span class="o">],</span>
    <span class="n">inter</span> <span class="k">:</span> <span class="kt">hlist.Intersection.Aux</span><span class="o">[</span><span class="kt">ARepr</span>, <span class="kt">BRepr</span>, <span class="kt">Common</span><span class="o">],</span>
    <span class="n">diff</span> <span class="k">:</span> <span class="kt">hlist.Diff.Aux</span><span class="o">[</span><span class="kt">BRepr</span>, <span class="kt">Common</span>, <span class="kt">Added</span><span class="o">],</span> 
    <span class="n">monoid</span> <span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">Added</span><span class="o">],</span> 
    <span class="n">prepend</span> <span class="k">:</span> <span class="kt">hlist.Prepend.Aux</span><span class="o">[</span><span class="kt">Added</span>, <span class="kt">Common</span>, <span class="kt">Unaligned</span><span class="o">],</span>
    <span class="n">align</span> <span class="k">:</span> <span class="kt">hlist.Align</span><span class="o">[</span><span class="kt">Unaligned</span>, <span class="kt">BRepr</span><span class="o">]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">Migration</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Migration</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> 
            <span class="nv">bGen</span><span class="o">.</span><span class="py">from</span><span class="o">(</span><span class="nf">align</span><span class="o">(</span><span class="nf">prepend</span><span class="o">(</span><span class="nv">monoid</span><span class="o">.</span><span class="py">empty</span><span class="o">,</span> <span class="nf">inter</span><span class="o">(</span><span class="nv">aGen</span><span class="o">.</span><span class="py">to</span><span class="o">(</span><span class="n">a</span><span class="o">)))))</span> 
    <span class="o">}</span>
</code></pre></div></div><p>注意上述代码没有在值层面使用每一个类型类，使用Diff来推断增加的数据类型，但是在运行时并不需要真的运行diff.apply方法，而是使用Monoid来获取增加的实例。</p><p>有了最终版的类型类实例，就可以使用genericMigration为6.3节中设置的所有情况进行数据迁移。样例如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IceCreamV1</span><span class="o">(</span><span class="s">"Sundae"</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">true</span><span class="o">).</span><span class="py">migrateTo</span><span class="o">[</span><span class="kt">IceCreamV2a</span><span class="o">]</span> 
<span class="c1">// res14: IceCreamV2a = IceCreamV2a(Sundae,true)</span>

<span class="nc">IceCreamV1</span><span class="o">(</span><span class="s">"Sundae"</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">true</span><span class="o">).</span><span class="py">migrateTo</span><span class="o">[</span><span class="kt">IceCreamV2b</span><span class="o">]</span> 
<span class="c1">// res15: IceCreamV2b = IceCreamV2b(Sundae,true,1)</span>

<span class="nc">IceCreamV1</span><span class="o">(</span><span class="s">"Sundae"</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">true</span><span class="o">).</span><span class="py">migrateTo</span><span class="o">[</span><span class="kt">IceCreamV2c</span><span class="o">]</span> 
<span class="c1">// res16: IceCreamV2c = IceCreamV2c(Sundae,true,1,0)</span>
</code></pre></div></div><p>我们能使用ops类型类来完成的功能是非常神奇的。只为Migration类型类定义一个隐式方法——genericMigration，它的具体实现也只有一行代码——即可完成在任何两个样例类之间进行自动迁移。使用标准的类库我们能以与此差不多的代码量写出处理单独一对类型的迁移工具。这就是shapeless的强大之处！</p><h2 id="64-record-ops">6.4 Record ops</h2><p>这一章我们花了一些时间学习了shapeless.ops.hlist和shapeless.ops.coproduct包里的类型类，下面来学习名为shapeless.ops.record的第三个重要的包，并以此结束本章。</p><p>shapeless中的“record ops”对元素被标记的HList提供了类似映射（map）的操作。下面以IceCream类为例，介绍对其进行操作的几个例子。首先获取IceCream的LabelledGeneric类型：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless._</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">IceCream</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">numCherries</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">inCone</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">sundae</span> <span class="k">=</span> <span class="nc">LabelledGeneric</span><span class="o">[</span><span class="kt">IceCream</span><span class="o">].</span> <span class="nf">to</span><span class="o">(</span><span class="nc">IceCream</span><span class="o">(</span><span class="s">"Sundae"</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">false</span><span class="o">))</span> 
<span class="c1">// sundae: String with shapeless.labelled.KeyTag[Symbol with shapeless</span>
<span class="c1">//    .tag.Tagged[String("name")],String] :: Int with shapeless. </span>
<span class="c1">//    labelled.KeyTag[Symbol with shapeless.tag.Tagged[String(" </span>
<span class="c1">//    numCherries")],Int] :: Boolean with shapeless.labelled.KeyTag[</span>
<span class="c1">//    Symbol with shapeless.tag.Tagged[String("inCone")],Boolean] :: </span>
<span class="c1">//    shapeless.HNil = Sundae :: 1 :: false :: HNil</span>
</code></pre></div></div><p>不像我们之前已经看到的HList和Coproduct操作，record ops语法需要对shapeless.record包进行显式引入。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless.record._</span>
</code></pre></div></div><h3 id="641-选择字段">6.4.1 选择字段</h3><p>get扩展方法和它的对应的Selector类型类允许我们根据标签来获取此标签对应的字段的值。样例如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">sundae</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="ss">'name</span><span class="o">)</span> 
<span class="c1">// res1: String = Sundae</span>

<span class="nv">sundae</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="ss">'numCherries</span><span class="o">)</span> 
<span class="c1">// res2: Int = 1</span>
</code></pre></div></div><p>获取未定义的字段会导致编译错误。具体如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">sundae</span><span class="o">.</span><span class="py">get</span><span class="o">(</span><span class="ss">'nomCherries</span><span class="o">)</span> 
<span class="c1">// &lt;console&gt;:20: error: No field Symbol with shapeless.tag.Tagged[ </span>
<span class="c1">//    String("nomCherries")] in record String with shapeless.labelled. </span>
<span class="c1">//    KeyTag[Symbol with shapeless.tag.Tagged[String("name")],String] :: </span>
<span class="c1">//    Int with shapeless.labelled.KeyTag[Symbol with shapeless.tag. </span>
<span class="c1">//    Tagged[String("numCherries")],Int] :: Boolean with shapeless. l</span>
<span class="c1">//    abelled.KeyTag[Symbol with shapeless.tag.Tagged[String("inCone") </span>
<span class="c1">//    ],Boolean] :: shapeless.HNil</span>
<span class="c1">//  sundae.get('nomCherries)</span>
<span class="c1">//            ^</span>
</code></pre></div></div><h3 id="642-更新和删除字段">6.4.2 更新和删除字段</h3><p>updated方法和Updater类型类允许我们根据key值来修改字段。remove方法和Remover类型类允许我们根据key值来删除字段。使用方式如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">sundae</span><span class="o">.</span><span class="py">updated</span><span class="o">(</span><span class="ss">'numCherries</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> 
<span class="c1">// res4: shapeless.::[String with shapeless.labelled.KeyTag[Symbol with </span>
<span class="c1">//    shapeless.tag.Tagged[String("name")],String],shapeless.::[Int with </span>
<span class="c1">//    shapeless.labelled.KeyTag[Symbol with shapeless.tag.Tagged[String(" </span>
<span class="c1">//    numCherries")],Int],shapeless.::[Boolean with shapeless.labelled. </span>
<span class="c1">//    KeyTag[Symbol with shapeless.tag.Tagged[String("inCone")],Boolean], </span>
<span class="c1">//    shapeless.HNil]]] = Sundae :: 3 :: false :: HNil</span>

<span class="nv">sundae</span><span class="o">.</span><span class="py">remove</span><span class="o">(</span><span class="ss">'inCone</span><span class="o">)</span> 
<span class="c1">// res5: (Boolean, shapeless.::[String with shapeless.labelled.KeyTag[ </span>
<span class="c1">//    Symbol with shapeless.tag.Tagged[String("name")],String],shapeless </span>
<span class="c1">//    .::[Int with shapeless.labelled.KeyTag[Symbol with shapeless.tag. </span>
<span class="c1">//    Tagged[String("numCherries")],Int],shapeless.HNil]]) = (false, </span>
<span class="c1">//    Sundae :: 1 :: HNil)</span>
</code></pre></div></div><p>updateWith方法和Modifier类型类允许我们传入一个更新函数来修改字段。以下代码实现将name字段更新为“MASSIVE ”加其原始值：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">sundae</span><span class="o">.</span><span class="py">updateWith</span><span class="o">(</span><span class="ss">'name</span><span class="o">)(</span><span class="s">"MASSIVE "</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span> 
<span class="c1">// res6: shapeless.::[String with shapeless.labelled.KeyTag[Symbol with </span>
<span class="c1">//    shapeless.tag.Tagged[String("name")],String],shapeless.::[Int with </span>
<span class="c1">//    shapeless.labelled.KeyTag[Symbol with shapeless.tag.Tagged[String(" </span>
<span class="c1">//    numCherries")],Int],shapeless.::[Boolean with shapeless.labelled. </span>
<span class="c1">//    KeyTag[Symbol with shapeless.tag.Tagged[String("inCone")],Boolean], </span>
<span class="c1">//    shapeless.HNil]]] = MASSIVE Sundae :: 1 :: false :: HNil</span>
</code></pre></div></div><h3 id="643-转换为普通的map对象">6.4.3 转换为普通的Map对象</h3><p>toMap方法和ToMap类型类可以将一个记录转换为Map对象。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">sundae</span><span class="o">.</span><span class="py">toMap</span>
<span class="c1">// res7: Map[Symbol with shapeless.tag.Tagged[_ &gt;: String("inCone") </span>
<span class="c1">//    with String("numCherries") with String("name") &lt;: String],Any] = </span>
<span class="c1">//    Map('inCone -&gt; false, 'numCherries -&gt; 1, 'name -&gt; Sundae)</span>
</code></pre></div></div><h3 id="644-其它操作">6.4.4 其它操作</h3><p>由于篇幅限制很多操作不能在这里介绍，例如：重命名字段、合并记录、对字段的值进行映射等等，你可以从shapeless.ops.record和shapeless.syntax.record包中得到更多信息。</p><h2 id="65-小结">6.5 小结</h2><p>这一章我们探索了shapeless.ops包中提供的几个类型类。我们以Last和Init作为两个简单的ops模式的样例并以链接现有代码段的方式建立了我们自己的Penultimate和Migration类型类。</p><p>剩下的很多ops类型类与已经学过的这些ops模式具有很多相似之处。最简单的学习方式就是查看shapeless.ops和shapeless.syntax包中的源码。</p><p>后续我们将学习两套需要深层次理论的ops类型类。第七章学习在HList实例上进行类似map和flatMap的函数化操作。第八章学习需要在类型级别表示数字的类型类。这些知识将加深我们对shapeless.ops中的类型类的多样性的理解。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://dreamylost.cn" target="_blank">梦境迷离</a></li><li>本文链接：<a href="https://dreamylost.cn/shapeless/Shapeless-%E5%AF%B9HList%E5%92%8CCoproduct%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C.html" target="_blank">https://dreamylost.cn/shapeless/Shapeless-%E5%AF%B9HList%E5%92%8CCoproduct%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C.html</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/shapeless/Shapeless-%E5%AF%B9HList%E5%92%8CCoprod', clientID: '061aadb5d449c0877d7d', clientSecret: '9aa7af7c248a7e36a07a86993e11a7acf7fbd353', repo: 'dreamylost-comments', owner: 'jxnu-liguobin', admin: ['jxnu-liguobin'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@built/assets/search_data.json?v=1638711878', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"> <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-8236444920328818" data-ad-slot="6220614560" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2019 <span title="梦境迷离">梦境迷离</span> <a href="http://www.beian.miit.gov.cn/publish/query/indexFirst.action" rel="nofollow" target="_blank">赣ICP备17017283号-1</a> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/jxnu-liguobin/jxnu-liguobin.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://dreamylost.cn/" title="首页" target="">首页</a></li><li> <a href="https://dreamylost.cn/categories/" title="分类" target="">分类</a></li><li> <a href="https://dreamylost.cn/wiki/" title="维基" target="">维基</a></li><li> <a href="https://dreamylost.cn/links/" title="链接" target="">链接</a></li><li> <a href="https://dreamylost.cn/about/" title="关于" target="">关于</a></li><li><a href="https://dreamylost.cn/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2019-09-20 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-147390701-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
