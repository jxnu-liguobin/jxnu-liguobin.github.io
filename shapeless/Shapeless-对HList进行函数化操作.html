<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>对HList进行函数化操作 &mdash; 梦境迷离</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="canonical" href="https://blog.dreamylost.cn/shapeless/Shapeless-%E5%AF%B9HList%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E5%8C%96%E6%93%8D%E4%BD%9C.html"><link rel="alternate" type="application/atom+xml" title="梦境迷离" href="https://blog.dreamylost.cn/feed.xml"><link rel="shortcut icon" href="https://dreamylost.cn/favicon.ico"><meta property="og:title" content="对HList进行函数化操作"><meta name="keywords" content="梦境迷离, jxnu-liguobin"><meta name="og:keywords" content="梦境迷离, jxnu-liguobin"><meta name="description" content=""><meta name="og:description" content=""><meta property="og:url" content="https://blog.dreamylost.cn/shapeless/Shapeless-%E5%AF%B9HList%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E5%8C%96%E6%93%8D%E4%BD%9C.html"><meta property="og:site_name" content="梦境迷离"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2020-07-05"> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/main.js"></script> <script data-ad-client="ca-pub-8236444920328818" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://blog.dreamylost.cn/" title="梦境迷离"><span class="octicon octicon-mark-github"></span> 梦境迷离</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://blog.dreamylost.cn/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://blog.dreamylost.cn/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://blog.dreamylost.cn/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://blog.dreamylost.cn/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://blog.dreamylost.cn/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="对HList进行函数化操作"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">对HList进行函数化操作</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2020/07/05 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://blog.dreamylost.cn/categories/#Shapeless" title="Shapeless">Shapeless</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 7796 字，约 23 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"> <img style="height:72px;width:72px" src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/images/qrcode.jpg" alt="梦境迷离" /></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" > <ins class="adsbygoogle content-header-ad" data-ad-client="ca-pub-8236444920328818" data-ad-slot="3977594606"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> <br /><article class="article-content markdown-body"><ul id="markdown-toc"><li><a href="#71-动机对hlist进行映射map操作" id="markdown-toc-71-动机对hlist进行映射map操作">7.1 动机：对HList进行映射（map）操作</a></li><li><a href="#72-多态函数polymorphic-function" id="markdown-toc-72-多态函数polymorphic-function">7.2 多态函数（polymorphic function）</a><ul><li><a href="#721-poly如何工作" id="markdown-toc-721-poly如何工作">7.2.1 Poly如何工作</a></li><li><a href="#722-poly语法规则" id="markdown-toc-722-poly语法规则">7.2.2 Poly语法规则</a></li></ul></li><li><a href="#73-使用poly完成map和flatmap操作" id="markdown-toc-73-使用poly完成map和flatmap操作">7.3 使用Poly完成map和flatMap操作</a></li><li><a href="#74-使用poly完成fold操作" id="markdown-toc-74-使用poly完成fold操作">7.4 使用Poly完成Fold操作</a></li><li><a href="#75-使用poly定义类型类" id="markdown-toc-75-使用poly定义类型类">7.5 使用Poly定义类型类</a></li><li><a href="#76-小结" id="markdown-toc-76-小结">7.6 小结</a></li></ul><blockquote><p>在线电子书 https://dreamylost.gitbook.io/dreamylost/</p></blockquote><blockquote><p>shapeless v2.3.2</p></blockquote><p>普通的Scala程序大量使用像map和flatMap这样的函数化操作。学习到此我们脑子中不免会产生一个问题，能否对HList实例执行相同的函数化操作呢？尽管我们必须做一些与普通的Scala函数化操作稍微不同的事情，但是答案是肯定的，可以使用类型类的技巧并且shapeless提供了一套ops类型类来帮助我们实现这一功能。</p><p>在我们深入学习这些类型类之前，我们需要先学习一下shapeless中如何定义多态函数（polymorphic function），多态函数能够实现对异构数据的map操作。</p><h2 id="71-动机对hlist进行映射map操作">7.1 动机：对HList进行映射（map）操作</h2><p>我们通过学习map方法的原理来引出多态函数。图7.1展示了普通list对象的映射操作。如果我们有一个List[A]对象，并提供一个“A=&gt;B”的函数，据此可得List[B]对象。</p><p><img src="../../public/image/shapeless-1.png" alt="shapeless-1" /></p><p>HList对象元素的异构类型导致这一方式不能正常运行，Scala函数修复了输入和输出类型使得map的结果的每一个元素都必须拥有相同的类型。</p><p>理想情况下我们需要一个像图7.2中的map操作，它判断每一个输入的类型并决定每一个输出的类型，最终得到一个封闭的、能保持HList异构本质的组合变换。</p><p><img src="../../public/image/shapeless-1.png" alt="shapeless-1" /></p><p>不幸的是我们不能使用Scala函数来实现这种操作，需要一些新的方式，这种方式就是多态函数。</p><h2 id="72-多态函数polymorphic-function">7.2 多态函数（polymorphic function）</h2><p>shapeless为实现多态函数提供了一个叫做Poly的类型。简单解释多态函数如何工作即为其结果类型依赖参数类型。注意下一节中不包含真实的shapeless代码——为了灵活性和易用性我们省略了很多不重要的代码。下面结合实际的shapeless中的Poly类来创建一个简单的API以展示我们实现函数化操作的目的。</p><h3 id="721-poly如何工作">7.2.1 Poly如何工作</h3><p>Poly类的核心代码是一个泛型的apply方法，它除了有一个普通A类型的参数，还接受一个Case[P, A]（原文为Case[A]）类型的隐式参数。Case和Poly的定义如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This is not real shapeless code.</span>
<span class="c1">// It's just for demonstration.</span>

<span class="k">trait</span> <span class="nc">Case</span><span class="o">[</span><span class="kt">P</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span> 
    <span class="k">type</span> <span class="kt">Result</span> 
    <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Result</span> 
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Poly</span> <span class="o">{</span> 
    <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">arg</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">cse</span><span class="k">:</span> <span class="kt">Case</span><span class="o">[</span><span class="kt">this.</span><span class="k">type</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">cse.Result</span> <span class="o">=</span> 
        <span class="nv">cse</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div><p>当我们实现一个实际的Poly类的时候，需要为每一个关心的参数类型提供Case实例，Case实例的apply方法定义了对此种类型的数据做何种映射。下面代码实现了实际的函数体：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This is not real shapeless code.</span>
<span class="c1">// It's just for demonstration.</span>

<span class="k">object</span> <span class="nc">myPoly</span> <span class="k">extends</span> <span class="nc">Poly</span> <span class="o">{</span> 
    <span class="k">implicit</span> <span class="k">def</span> <span class="nf">intCase</span> <span class="k">=</span> 
        <span class="k">new</span> <span class="nc">Case</span><span class="o">[</span><span class="kt">this.</span><span class="k">type</span>, <span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
            <span class="k">type</span> <span class="kt">Result</span> <span class="o">=</span> <span class="nc">Double</span> 
            <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">num</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="mf">2.0</span> 
        <span class="o">}</span>

    <span class="k">implicit</span> <span class="k">def</span> <span class="nf">stringCase</span> <span class="k">=</span> 
        <span class="k">new</span> <span class="nc">Case</span><span class="o">[</span><span class="kt">this.</span><span class="k">type</span>, <span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
            <span class="k">type</span> <span class="kt">Result</span> <span class="o">=</span> <span class="nc">Int</span>
            <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">str</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="nv">str</span><span class="o">.</span><span class="py">length</span>
        <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>当我们调用myPoly.apply时，编译器搜索对应的隐式Case实例并调用它。例如下述代码会调用隐式的intCase：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">myPoly</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="mi">123</span><span class="o">)</span>
<span class="c1">// res8: Double = 61.5</span>
</code></pre></div></div><p>我们可以使用一些微妙的作用域技巧，使编译器能够自动定位Case实例而不用任何多余的引入。Case有一个额外的类型参数P，该参数引用Poly的单例类型。Case[P, A]的隐式作用域包括Case、P和A的伴随对象。我们把P设置为myPoly.type，myPoly.type的伴随对象就是myPoly自身。换句话说，不管在哪里调用myPoly.apply方法Poly里定义的隐式Case实例总是处在作用域内。</p><h3 id="722-poly语法规则">7.2.2 Poly语法规则</h3><p>上面的代码不是实际的shapeless代码，但是幸运的是，shapeless提供了更加容易的Poly实例定义方式。下面是以正确的语法定义的myPoly：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless._</span>

<span class="k">object</span> <span class="nc">myPoly</span> <span class="k">extends</span> <span class="nc">Poly1</span> <span class="o">{</span> 
    <span class="k">implicit</span> <span class="k">val</span> <span class="nv">intCase</span><span class="k">:</span> <span class="kt">Case.Aux</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> 
        <span class="nf">at</span><span class="o">(</span><span class="n">num</span> <span class="k">=&gt;</span> <span class="n">num</span> <span class="o">/</span> <span class="mf">2.0</span><span class="o">)</span>

    <span class="k">implicit</span> <span class="k">val</span> <span class="nv">stringCase</span><span class="k">:</span> <span class="kt">Case.Aux</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> 
        <span class="nf">at</span><span class="o">(</span><span class="n">str</span> <span class="k">=&gt;</span> <span class="nv">str</span><span class="o">.</span><span class="py">length</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div><p>此处与之前定义的样例语法有几个关键的不同之处：</p><ol><li>我们继承自Poly1特质而不是Poly，shapeless提供了Poly类型和其一系列的子类，从Poly1到Poly22，它们支持不同参数个数的多态函数。</li><li>Case.Aux类型与Poly的单例类型看上去没有关联，Case.Aux是Poly1里定义的一个类型别名，其实二者是有关联的，在Poly1的定义中我们可以清晰的看到。</li><li>我们使用了一个名叫at的辅助方法来定义case隐式实例，这与3.1.2节中介绍的实例构造子的作用相同，可以减少冗余代码。</li></ol><p>除了语法差异，使用shapeless真实代码定义的myPoly在功能上与样例中定义的myPoly是一致的，我们能给其提供一个Int或String类型的参数，得到一个相应类型的返回结果。具体如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">myPoly</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="mi">123</span><span class="o">)</span> 
<span class="c1">// res10: myPoly.intCase.Result = 61.5</span>

<span class="nv">myPoly</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="s">"hello"</span><span class="o">)</span> 
<span class="c1">// res11: myPoly.stringCase.Result = 5</span>
</code></pre></div></div><p>shapeless同样支持多个参数的Poly，下面是两个参数的例子：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">multiply</span> <span class="k">extends</span> <span class="nc">Poly2</span> <span class="o">{</span> 
    <span class="k">implicit</span> <span class="k">val</span> <span class="nv">intIntCase</span><span class="k">:</span> <span class="kt">Case.Aux</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> 
        <span class="nf">at</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="o">)</span>

    <span class="k">implicit</span> <span class="k">val</span> <span class="nv">intStrCase</span><span class="k">:</span> <span class="kt">Case.Aux</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> 
        <span class="nf">at</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">b</span><span class="o">.</span><span class="py">toString</span> <span class="o">*</span> <span class="n">a</span><span class="o">)</span>
<span class="o">}</span>

<span class="nf">multiply</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span> 
<span class="c1">// res12: multiply.intIntCase.Result = 12</span>

<span class="nf">multiply</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="s">"4"</span><span class="o">)</span> 
<span class="c1">// res13: multiply.intStrCase.Result = 444</span>
</code></pre></div></div><p>因为Case实例只是隐式值，我们能基于类型类定义Case实例并实现在前面章节介绍过的所有高级隐式解析。下面是不同上下文环境下的求数字之和的简单的例子：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.math.Numeric</span>

<span class="k">object</span> <span class="nc">total</span> <span class="k">extends</span> <span class="nc">Poly1</span> <span class="o">{</span> 
    <span class="k">implicit</span> <span class="k">def</span> <span class="nf">base</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">num</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> 
        <span class="kt">Case.Aux</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> 
      <span class="nf">at</span><span class="o">(</span><span class="nv">num</span><span class="o">.</span><span class="py">toDouble</span><span class="o">)</span>

    <span class="k">implicit</span> <span class="k">def</span> <span class="nf">option</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">num</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> 
        <span class="kt">Case.Aux</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span>
      <span class="nf">at</span><span class="o">(</span><span class="n">opt</span> <span class="k">=&gt;</span> <span class="nv">opt</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">num</span><span class="o">.</span><span class="py">toDouble</span><span class="o">).</span><span class="py">getOrElse</span><span class="o">(</span><span class="mf">0.0</span><span class="o">))</span>

    <span class="k">implicit</span> <span class="k">def</span> <span class="nf">list</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">num</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> 
        <span class="kt">Case.Aux</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> 
      <span class="nf">at</span><span class="o">(</span><span class="n">list</span> <span class="k">=&gt;</span> <span class="nv">num</span><span class="o">.</span><span class="py">toDouble</span><span class="o">(</span><span class="nv">list</span><span class="o">.</span><span class="py">sum</span><span class="o">))</span>
<span class="o">}</span>

<span class="nf">total</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span> 
<span class="c1">// res15: Double = 10.0</span>

<span class="nf">total</span><span class="o">(</span><span class="nc">Option</span><span class="o">(</span><span class="mf">20.0</span><span class="o">))</span> 
<span class="c1">// res16: Double = 20.0</span>

<span class="nf">total</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="mi">2L</span><span class="o">,</span> <span class="mi">3L</span><span class="o">))</span> 
<span class="c1">// res17: Double = 6.0</span>
</code></pre></div></div><p>类型推断特质</p><p>Poly将Scala的类型推断移出了编译器的舒适区，只需要让编译器一次多做几个类型推断就能很容易迷惑它。比如下面的代码能够正常编译：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">a</span> <span class="k">=</span> <span class="nv">myPoly</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="mi">123</span><span class="o">)</span> 
<span class="k">val</span> <span class="nv">b</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">a</span>
</code></pre></div></div><p>然而，将上述两行代码组合成一行就会报错。如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">a</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="nv">myPoly</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="mi">123</span><span class="o">)</span> 
<span class="c1">// &lt;console&gt;:17: error: type mismatch;</span>
<span class="c1">//  found   : Int(123)</span>
<span class="c1">//  required: myPoly.ProductCase.Aux[shapeless.HNil,?] </span>
<span class="c1">//    (which expands to) shapeless.poly.Case[myPoly.type,</span>
<span class="c1">//   shapeless.HNil]{type Result = ?}</span>
<span class="c1">//        val a: Double = myPoly.apply(123)</span>
<span class="c1">//                                         ^</span>
</code></pre></div></div><p>如果我们增加一个类型注释，编译正常。如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">a</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="nv">myPoly</span><span class="o">.</span><span class="py">apply</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">123</span><span class="o">)</span>
<span class="c1">// a: Double = 61.5</span>
</code></pre></div></div><p>这种行为很让人困惑和讨厌，也并没有固定的规则能让我们避免这一问题，唯一的方法就是试着不要过度约束编译器，一次只解决一个约束并在编译器报错的时候补充一点提示信息。</p><h2 id="73-使用poly完成map和flatmap操作">7.3 使用Poly完成map和flatMap操作</h2><p>shapeless提供了一套基于Poly的函数化操作，每一个都是作为一个ops类型类来实现的。此处我们以map和flatMap操作为例。下面是map操作的代码：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless._</span>

<span class="k">object</span> <span class="nc">sizeOf</span> <span class="k">extends</span> <span class="nc">Poly1</span> <span class="o">{</span> 
    <span class="k">implicit</span> <span class="k">val</span> <span class="nv">intCase</span><span class="k">:</span> <span class="kt">Case.Aux</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> 
        <span class="nf">at</span><span class="o">(</span><span class="n">identity</span><span class="o">)</span>

    <span class="k">implicit</span> <span class="k">val</span> <span class="nv">stringCase</span><span class="k">:</span> <span class="kt">Case.Aux</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> 
        <span class="nf">at</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">length</span><span class="o">)</span>

    <span class="k">implicit</span> <span class="k">val</span> <span class="nv">booleanCase</span><span class="k">:</span> <span class="kt">Case.Aux</span><span class="o">[</span><span class="kt">Boolean</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> 
        <span class="nf">at</span><span class="o">(</span><span class="n">bool</span> <span class="k">=&gt;</span> <span class="nf">if</span><span class="o">(</span><span class="n">bool</span><span class="o">)</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">}</span>

<span class="o">(</span><span class="mi">10</span> <span class="o">::</span> <span class="s">"hello"</span> <span class="o">::</span> <span class="kc">true</span> <span class="o">::</span> <span class="nc">HNil</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">sizeOf</span><span class="o">)</span> 

<span class="c1">// res1: Int :: Int :: Int :: shapeless.HNil = 10 :: 5 :: 1 :: HNil</span>
</code></pre></div></div><p>注意结果HList的元素类型与sizeOf里的Case实例的输出类型相匹配。只需为HList实例准备一个Poly对象，在此Poly对象中对该HList的所有类型都提供相应的Case实例，就能对该HList实例调用map函数。但是如果编译器不能为某个成员找到其对应的Case实例那么就会报错。如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="mf">1.5</span> <span class="o">::</span> <span class="nc">HNil</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">sizeOf</span><span class="o">)</span> 
<span class="c1">// &lt;console&gt;:17: error: could not find implicit value for parameter </span>
<span class="c1">//    mapper: shapeless.ops.hlist.Mapper[sizeOf.type,Double :: </span>
<span class="c1">//    shapeless.HNil]</span>
<span class="c1">// (1.5 :: HNil).map(sizeOf) </span>
<span class="c1">//                  ^</span>
</code></pre></div></div><p>我们也能对HList实例进行flatMap操作，只要在定义的Poly实例中使每一个Case实例返回的是HList类型即可。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">valueAndSizeOf</span> <span class="k">extends</span> <span class="nc">Poly1</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="nv">intCase</span><span class="k">:</span> <span class="kt">Case.Aux</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span> 
        <span class="nf">at</span><span class="o">(</span><span class="n">num</span> <span class="k">=&gt;</span> <span class="n">num</span> <span class="o">::</span> <span class="n">num</span> <span class="o">::</span> <span class="nc">HNil</span><span class="o">)</span>

    <span class="k">implicit</span> <span class="k">val</span> <span class="nv">stringCase</span><span class="k">:</span> <span class="kt">Case.Aux</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span> <span class="kt">::</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span> 
        <span class="nf">at</span><span class="o">(</span><span class="n">str</span> <span class="k">=&gt;</span> <span class="n">str</span> <span class="o">::</span> <span class="nv">str</span><span class="o">.</span><span class="py">length</span> <span class="o">::</span> <span class="nc">HNil</span><span class="o">)</span>

    <span class="k">implicit</span> <span class="k">val</span> <span class="nv">booleanCase</span><span class="k">:</span> <span class="kt">Case.Aux</span><span class="o">[</span><span class="kt">Boolean</span>, <span class="kt">Boolean</span> <span class="kt">::</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]</span> <span class="k">=</span>
        <span class="nf">at</span><span class="o">(</span><span class="n">bool</span> <span class="k">=&gt;</span> <span class="n">bool</span> <span class="o">::</span> <span class="o">(</span><span class="nf">if</span><span class="o">(</span><span class="n">bool</span><span class="o">)</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span> <span class="o">::</span> <span class="nc">HNil</span><span class="o">)</span>
<span class="o">}</span>

<span class="o">(</span><span class="mi">10</span> <span class="o">::</span> <span class="s">"hello"</span> <span class="o">::</span> <span class="kc">true</span> <span class="o">::</span> <span class="nc">HNil</span><span class="o">).</span><span class="py">flatMap</span><span class="o">(</span><span class="n">valueAndSizeOf</span><span class="o">)</span> 

<span class="c1">// res3: Int :: Int :: String :: Int :: Boolean :: Int :: shapeless.</span>
<span class="c1">//    HNil = 10 :: 10 :: hello :: 5 :: true :: 1 :: HNil</span>
</code></pre></div></div><p>再次强调，如果调用flatMap的HList实例有某个元素类型所对应的Case实例没有定义或者其对应的Case实例返回的结果不是HList类型那么编译器就会报错。如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Using the wrong Poly with flatMap:</span>
<span class="o">(</span><span class="mi">10</span> <span class="o">::</span> <span class="s">"hello"</span> <span class="o">::</span> <span class="kc">true</span> <span class="o">::</span> <span class="nc">HNil</span><span class="o">).</span><span class="py">flatMap</span><span class="o">(</span><span class="n">sizeOf</span><span class="o">)</span> 
<span class="c1">// &lt;console&gt;:18: error: could not find implicit value for parameter</span>
<span class="c1">//    mapper: shapeless.ops.hlist.FlatMapper[sizeOf.type,Int :: String</span>
<span class="c1">//    :: Boolean :: shapeless.HNil]</span>
<span class="c1">//         (10 :: "hello" :: true :: HNil).flatMap(sizeOf)</span>
<span class="c1">//                                 ^</span>
</code></pre></div></div><p>map和flatMap分别基于Mapper和FlatMapper类型类，我们将在7.5节中看到一个直接使用Mapper进行操作的例子。</p><h2 id="74-使用poly完成fold操作">7.4 使用Poly完成Fold操作</h2><p>除了map和flatMap之外，shapeless还提供了基于Poly2的foldLeft和foldRight操作，其区别在于Case实例需要对两个变量进行处理。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless._</span>

<span class="k">object</span> <span class="nc">sum</span> <span class="k">extends</span> <span class="nc">Poly2</span> <span class="o">{</span> 
    <span class="k">implicit</span> <span class="k">val</span> <span class="nv">intIntCase</span><span class="k">:</span> <span class="kt">Case.Aux</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> 
        <span class="nf">at</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span>

    <span class="k">implicit</span> <span class="k">val</span> <span class="nv">intStringCase</span><span class="k">:</span> <span class="kt">Case.Aux</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> 
        <span class="nf">at</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="nv">b</span><span class="o">.</span><span class="py">length</span><span class="o">)</span>
<span class="o">}</span>

<span class="o">(</span><span class="mi">10</span> <span class="o">::</span> <span class="s">"hello"</span> <span class="o">::</span> <span class="mi">100</span> <span class="o">::</span> <span class="nc">HNil</span><span class="o">).</span><span class="py">foldLeft</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="n">sum</span><span class="o">)</span> 
<span class="c1">// res7: Int = 115</span>
</code></pre></div></div><p>同样还能完成reduceLeft、reduceRight、foldMap等操作，每一个操作都有与之相对应的类型类，我们将把研究这些可用的操作作为练习留给读者。</p><h2 id="75-使用poly定义类型类">7.5 使用Poly定义类型类</h2><p>我们能以Poly和像Mapper、FlatMapper一样的类型类为基础，定义我们自己的类型类。作为例子，我们定义一个实现从一个样例类到另一个样例类的map操作的类型类ProductMapper。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">ProductMapper</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">P</span><span class="o">]</span> <span class="o">{</span> 
    <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> 
<span class="o">}</span>
</code></pre></div></div><p>我们能用一个Mapper参数和一对Generic参数来创建一个ProductMapper的实例。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless._</span> 
<span class="k">import</span> <span class="nn">shapeless.ops.hlist</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="nf">genericProductMapper</span><span class="o">[</span> 
    <span class="kt">A</span>, <span class="kt">B</span>,
    <span class="kt">P</span> <span class="k">&lt;:</span> <span class="kt">Poly</span>,
    <span class="kt">ARepr</span> <span class="k">&lt;:</span> <span class="kt">HList</span>,
    <span class="kt">BRepr</span> <span class="k">&lt;:</span> <span class="kt">HList</span> 
<span class="o">](</span>
    <span class="k">implicit</span> 
    <span class="n">aGen</span><span class="k">:</span> <span class="kt">Generic.Aux</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">ARepr</span><span class="o">],</span>
    <span class="n">bGen</span><span class="k">:</span> <span class="kt">Generic.Aux</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">BRepr</span><span class="o">],</span> 
    <span class="n">mapper</span><span class="k">:</span> <span class="kt">hlist.Mapper.Aux</span><span class="o">[</span><span class="kt">P</span>, <span class="kt">ARepr</span>, <span class="kt">BRepr</span><span class="o">]</span> 
<span class="o">)</span><span class="k">:</span> <span class="kt">ProductMapper</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">P</span><span class="o">]</span> <span class="k">=</span> 
    <span class="k">new</span> <span class="nc">ProductMapper</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">P</span><span class="o">]</span> <span class="o">{</span> 
      <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> 
        <span class="nv">bGen</span><span class="o">.</span><span class="py">from</span><span class="o">(</span><span class="nv">mapper</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="nv">aGen</span><span class="o">.</span><span class="py">to</span><span class="o">(</span><span class="n">a</span><span class="o">)))</span> 
<span class="o">}</span>
</code></pre></div></div><p>有趣的是，尽管定义了一个Poly类型的类型参数P，但是在我们的代码的任何位置均不涉及类型P的值。Mapper类型类使用隐式解析来寻找Case实例，所以编译器只需要知道P的单例类型就能从其中加载定义好的相关Case实例。</p><p>我们来创建一个扩展方法以使ProductMapper更容易被调用，用户在调用的时候只需要指定B的类型。可以使用一些间接的方式来让编译器从值参数推导Poly的类型。此处定义了一个Builder类，并为该类提供一个泛型的apply方法，传入一个poly变量和一个隐式的ProductMapper对象，这样就能自动的根据B的类型推断出P的类型。代码如下：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">class</span> <span class="nc">ProductMapperOps</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">class</span> <span class="nc">Builder</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">apply</span><span class="o">[</span><span class="kt">P</span> <span class="k">&lt;:</span> <span class="kt">Poly</span><span class="o">](</span><span class="n">poly</span><span class="k">:</span> <span class="kt">P</span><span class="o">)</span> 
            <span class="o">(</span><span class="k">implicit</span> <span class="n">pm</span><span class="k">:</span> <span class="kt">ProductMapper</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">P</span><span class="o">])</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span>
            <span class="nv">pm</span><span class="o">.</span><span class="py">apply</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> 
    <span class="o">}</span>

    <span class="k">def</span> <span class="nf">mapTo</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Builder</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div><p>下面是上述方法的使用样例：</p><div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">conversions</span> <span class="k">extends</span> <span class="nc">Poly1</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="nv">intCase</span><span class="k">:</span> <span class="kt">Case.Aux</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span> <span class="nf">at</span><span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> 
    <span class="k">implicit</span> <span class="k">val</span> <span class="nv">boolCase</span><span class="k">:</span> <span class="kt">Case.Aux</span><span class="o">[</span><span class="kt">Boolean</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nf">at</span><span class="o">(</span><span class="nf">if</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="nv">strCase</span><span class="k">:</span> <span class="kt">Case.Aux</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nf">at</span><span class="o">(</span><span class="n">identity</span><span class="o">)</span> 
<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">IceCream1</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">numCherries</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">inCone</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> 
<span class="k">case</span> <span class="k">class</span> <span class="nc">IceCream2</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">hasCherries</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">numCones</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

<span class="nc">IceCream1</span><span class="o">(</span><span class="s">"Sundae"</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">false</span><span class="o">).</span><span class="py">mapTo</span><span class="o">[</span><span class="kt">IceCream2</span><span class="o">](</span><span class="n">conversions</span><span class="o">)</span>
<span class="c1">// res2: IceCream2 = IceCream2(Sundae,true,0)</span>
</code></pre></div></div><p>mapTo语法看上去像一个单一的调用，但实际上是两次：一次调用mapTo确定B类型参数，另一次调用Builder.apply方法来指定Poly的类型。一些shapeless的内置的ops扩展方法使用相似的技巧为用户提供方便。</p><h2 id="76-小结">7.6 小结</h2><p>这一章我们讨论了多态函数，它的返回类型基于参数类型的变化而变化。我们看到了shapeless的Poly类型是如何定义的以及如何用它来实现像map、flatMap、foldLeft和foldRight这样的函数化操作。</p><p>每一个对HList实例的操作都是作为扩展方法而实现的，并基于对应的类型类：Mapper、FlatMapper、LeftFolder等等。我们能使用这些类型类、Poly类型和在4.3节中介绍的技巧来创建我们自己的类型类，它涉及复杂的转换过程，最终达到我们想要的效果。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://blog.dreamylost.cn" target="_blank">梦境迷离</a></li><li>本文链接：<a href="https://blog.dreamylost.cn/shapeless/Shapeless-%E5%AF%B9HList%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E5%8C%96%E6%93%8D%E4%BD%9C.html" target="_blank">https://blog.dreamylost.cn/shapeless/Shapeless-%E5%AF%B9HList%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E5%8C%96%E6%93%8D%E4%BD%9C.html</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/shapeless/Shapeless-%E5%AF%B9HList%E8%BF%9B%E8%A1', clientID: '061aadb5d449c0877d7d', clientSecret: '9aa7af7c248a7e36a07a86993e11a7acf7fbd353', repo: 'dreamylost-comments', owner: 'jxnu-liguobin', admin: ['jxnu-liguobin'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@built/assets/search_data.json?v=1697164030', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"> <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-8236444920328818" data-ad-slot="6220614560" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2019 <span title="梦境迷离">梦境迷离</span> <a href="http://www.beian.miit.gov.cn/publish/query/indexFirst.action" rel="nofollow" target="_blank">赣ICP备17017283号-1</a> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/jxnu-liguobin/jxnu-liguobin.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://blog.dreamylost.cn/" title="首页" target="">首页</a></li><li> <a href="https://blog.dreamylost.cn/categories/" title="分类" target="">分类</a></li><li> <a href="https://blog.dreamylost.cn/wiki/" title="维基" target="">维基</a></li><li> <a href="https://blog.dreamylost.cn/links/" title="链接" target="">链接</a></li><li> <a href="https://blog.dreamylost.cn/about/" title="关于" target="">关于</a></li><li><a href="https://blog.dreamylost.cn/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2019-09-20 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-147390701-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
