<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>StampedLock的实现分析 &mdash; 梦境迷离</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="canonical" href="https://blog.dreamylost.cn/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91-StampedLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90.html"><link rel="alternate" type="application/atom+xml" title="梦境迷离" href="https://blog.dreamylost.cn/feed.xml"><link rel="shortcut icon" href="https://dreamylost.cn/favicon.ico"><meta property="og:title" content="StampedLock的实现分析"><meta name="keywords" content="梦境迷离, jxnu-liguobin"><meta name="og:keywords" content="梦境迷离, jxnu-liguobin"><meta name="description" content=""><meta name="og:description" content=""><meta property="og:url" content="https://blog.dreamylost.cn/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91-StampedLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90.html"><meta property="og:site_name" content="梦境迷离"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2018-11-11"> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/main.js"></script> <script data-ad-client="ca-pub-8236444920328818" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://blog.dreamylost.cn/" title="梦境迷离"><span class="octicon octicon-mark-github"></span> 梦境迷离</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://blog.dreamylost.cn/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://blog.dreamylost.cn/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://blog.dreamylost.cn/archives/" class=" site-header-nav-item" target="" title="归档">归档</a> <a href="https://blog.dreamylost.cn/open-source/" class=" site-header-nav-item" target="" title="开源">开源</a> <a href="https://blog.dreamylost.cn/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://blog.dreamylost.cn/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://blog.dreamylost.cn/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="StampedLock的实现分"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">StampedLock的实现分析</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2018/11/11 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://blog.dreamylost.cn/categories/#并发" title="并发">并发</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 6135 字，约 18 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"> <img style="height:72px;width:72px" src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/images/qrcode.jpg" alt="梦境迷离" /></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" > <ins class="adsbygoogle content-header-ad" data-ad-client="ca-pub-8236444920328818" data-ad-slot="3977594606"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> <br /><article class="article-content markdown-body"><ul id="markdown-toc"><li><a href="#stampedlock的实现" id="markdown-toc-stampedlock的实现">StampedLock的实现</a></li><li><a href="#stampedlock如何使用" id="markdown-toc-stampedlock如何使用">StampedLock如何使用</a></li><li><a href="#clh是什么怎么实现" id="markdown-toc-clh是什么怎么实现">CLH是什么？怎么实现</a></li><li><a href="#mcs是什么怎么实现" id="markdown-toc-mcs是什么怎么实现">MCS是什么？怎么实现</a></li></ul><h3 id="stampedlock的实现">StampedLock的实现</h3><ol><li>基于CLH锁-&gt;一种自旋锁，保证没有饥饿发生，FIFO顺序【先进先出】</li><li>维护一个线程队列，申请不成功的记录在此，每个节点保存一个标记位【locked】，用来判断当前线程是否释放锁</li><li>当线程试图获取锁，取得当前队列的尾部节点作为其前序节点，并使用类似while(pred.locked){}判断前序节点是否已经成功释放锁</li><li>只要前序节点没有释放锁，则表示当前线程还不能继续执行，自旋等待。</li><li>如果前序线程已经释放，则当前线程可以继续执行</li><li>释放锁时线程将自己的节点标记位置为false，那么后续等待的线程就能继续执行了</li></ol><p>StampedLock使用起来更复杂。它们使用了一个票据（stamp）的概念，这是一个long值，在加锁和解锁操作时，它被用作一张门票。 这意味着要解锁一个操作你需要传递相应的的门票。如果传递错误的门票，那么可能会抛出一个异常，或者其他意想不到的错误。</p><p>另外一个值得关注的重要问题是，不像ReadWriteLock，StampedLocks是不可重入的。 因此尽管StampedLocks可能更快，但可能产生死锁。在实践中，这意味着你应该始终确保锁以及对应的门票不要逃逸出所在的代码块。</p><p>StampedLock是并发包里面jdk8版本新增的一个锁，该锁提供了三种模式的读写控制，三种模式分别如下：</p><ul><li>写锁writeLock，是个排它锁或者叫独占锁，同时只有一个线程可以获取该锁，当一个线程获取该锁后，其它请求的线程必须等待，当目前没有线程持有读锁或者写锁的时候才可以获取到该锁，请求该锁成功后会返回一个stamp票据变量用来表示该锁的版本，当释放该锁时候需要unlockWrite并传递参数stamp。</li><li>悲观读锁readLock，是个共享锁，在没有线程获取独占写锁的情况下，同时多个线程可以获取该锁，如果已经有线程持有写锁，其他线程请求获取该读锁会被阻塞。这里讲的悲观其实是参考数据库中的乐观悲观锁的，这里说的悲观是说在具体操作数据前悲观的认为其他线程可能要对自己操作的数据进行修改， 所以需要先对数据加锁，这是在读少写多的情况下的一种考虑,请求该锁成功后会返回一个stamp票据变量用来表示该锁的版本，当释放该锁时候需要unlockRead并传递参数stamp。</li><li>乐观读锁tryOptimisticRead，是相对于悲观锁来说的，在操作数据前并没有通过CAS设置锁的状态，如果当前没有线程持有写锁，则简单的返回一个非0的stamp版本信息，获取该stamp后在具体操作数据前还需要调用validate验证下该stamp是否已经不可用， 也就是看当调用tryOptimisticRead返回stamp后到到当前时间间是否有其他线程持有了写锁，如果是那么validate会返回0，否者就可以使用该stamp版本的锁对数据进行操作。由于tryOptimisticRead并没有使用CAS设置锁状态所以不需要显示的释放该锁。 该锁的一个特点是适用于读多写少的场景，因为获取读锁只是使用与或操作进行检验，不涉及CAS操作，所以效率会高很多，但是同时由于没有使用真正的锁，在保证数据一致性上需要拷贝一份要操作的变量到方法栈，并且在操作数据时候可能其他写线程已经修改了数据， 而我们操作的是方法栈里面的数据，也就是一个快照，所以最多返回的不是最新的数据，但是一致性还是得到保障的。</li></ul><p>使用乐观读锁还是很容易犯错误的，必须要小心，必须要保证如下的使用顺序：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="n">stamp</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">tryOptimisticRead</span><span class="o">();</span> <span class="c1">//非阻塞获取版本信息</span>
<span class="n">copyVaraibale2ThreadMemory</span><span class="o">();</span><span class="c1">//拷贝变量到线程本地堆栈</span>
<span class="k">if</span><span class="o">(!</span><span class="n">lock</span><span class="o">.</span><span class="na">validate</span><span class="o">(</span><span class="n">stamp</span><span class="o">)){</span> <span class="c1">// 校验</span>
    <span class="kt">long</span> <span class="n">stamp</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">readLock</span><span class="o">();</span><span class="c1">//获取读锁</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">copyVaraibale2ThreadMemory</span><span class="o">();</span><span class="c1">//拷贝变量到线程本地堆栈</span>
     <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
       <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">(</span><span class="n">stamp</span><span class="o">);</span><span class="c1">//释放悲观锁</span>
    <span class="o">}</span>

<span class="o">}</span>

<span class="n">useThreadMemoryVarables</span><span class="o">();</span><span class="c1">//使用线程本地堆栈里面的数据进行操作</span>
</code></pre></div></div><h3 id="stampedlock如何使用">StampedLock如何使用</h3><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StampedLockDemo1</span> <span class="o">{</span>
	<span class="c1">// Java8引入，StampedLock可以认为是读写锁的改进版本，采用乐观加锁机制</span>
	<span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="nc">StampedLock</span> <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StampedLock</span><span class="o">();</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="nc">Point</span> <span class="n">point</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">();</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">// 写入线程</span>
		<span class="nc">Runnable</span> <span class="n">mRunnable</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>

			<span class="nd">@Override</span>
			<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
				<span class="n">point</span><span class="o">.</span><span class="na">move</span><span class="o">(</span><span class="k">new</span> <span class="nc">Random</span><span class="o">().</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">100</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">().</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">100</span><span class="o">));</span>
			<span class="o">}</span>
		<span class="o">};</span>
		<span class="c1">// 读取线程</span>
		<span class="nc">Runnable</span> <span class="n">rRunnable</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>

			<span class="nd">@Override</span>
			<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
				<span class="n">point</span><span class="o">.</span><span class="na">distanceFromOrigin</span><span class="o">();</span>
			<span class="o">}</span>
		<span class="o">};</span>
		<span class="c1">// 写入</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">mRunnable</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
		<span class="o">}</span>
		<span class="c1">// 读取</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">rRunnable</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="c1">// 来自JDK文档</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
		<span class="kd">private</span> <span class="kt">double</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">;</span>

		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">(</span><span class="kt">double</span> <span class="n">deltaX</span><span class="o">,</span> <span class="kt">double</span> <span class="n">deltaY</span><span class="o">)</span> <span class="o">{</span>
			<span class="c1">// 上一个排他锁</span>
			<span class="kt">long</span> <span class="n">stamp</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">writeLock</span><span class="o">();</span>
			<span class="k">try</span> <span class="o">{</span>
				<span class="n">x</span> <span class="o">=</span> <span class="n">deltaX</span><span class="o">;</span>
				<span class="n">y</span> <span class="o">=</span> <span class="n">deltaY</span><span class="o">;</span>
			<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
				<span class="n">s1</span><span class="o">.</span><span class="na">unlockWrite</span><span class="o">(</span><span class="n">stamp</span><span class="o">);</span>
			<span class="o">}</span>
		<span class="o">}</span>

		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">distanceFromOrigin</span><span class="o">()</span> <span class="o">{</span>
			<span class="c1">// tryOptimisticRead方法尝试一个乐观读，返回一个邮戳，作为这一次锁获取的凭证</span>
			<span class="kt">long</span> <span class="n">stamp</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">tryOptimisticRead</span><span class="o">();</span>
			<span class="c1">// 将全部变量拷贝到方法体栈内</span>
			<span class="kt">double</span> <span class="n">currentX</span> <span class="o">=</span> <span class="n">x</span><span class="o">,</span> <span class="n">currentY</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
			<span class="c1">// 判断stamp是否在读过程发生期间被修改</span>
			<span class="c1">// 如果没有被更改，则读取有效</span>
			<span class="c1">// 如果stamp是不可用的，可以如CAS操作一样，循环使用乐观读</span>
			<span class="c1">// 或者升级锁的级别，升级为悲观锁</span>
			<span class="k">if</span> <span class="o">(!</span><span class="n">s1</span><span class="o">.</span><span class="na">validate</span><span class="o">(</span><span class="n">stamp</span><span class="o">))</span> <span class="o">{</span> <span class="c1">//重点</span>
				<span class="c1">// 获取悲观的读锁，进一步读取数据，此时线程可能被挂起【挂起使用的是Unsafe.park()方法】</span>
				<span class="c1">// park方法遇到线程中断会直接返回。可能存在park的线程再次进入循环，如果不能退出，将占用大量CPU资源</span>
				<span class="n">stamp</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">readLock</span><span class="o">();</span>
				<span class="k">try</span> <span class="o">{</span>
					<span class="n">currentX</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
					<span class="n">currentY</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
				<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
					<span class="n">s1</span><span class="o">.</span><span class="na">unlockRead</span><span class="o">(</span><span class="n">stamp</span><span class="o">);</span>
				<span class="o">}</span>
			<span class="o">}</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">currentX</span> <span class="o">*</span> <span class="n">currentX</span> <span class="o">+</span> <span class="n">currentY</span> <span class="o">*</span> <span class="n">currentY</span><span class="o">);</span>

		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>StampedLock 对现存的锁实现有巨大的改进，特别是在读线程越来越多的场景下：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. StampedLock有一个复杂的API，对于加锁操作，很容易误用其他方法;
2. 当只有2个竞争者的时候，Synchronized是一个很好的通用的锁实现;
3. 当线程增长能够预估，ReentrantLock是一个很好的通用的锁实现;
4. 选择使用ReentrantReadWriteLock时，必须经过小心的适度的测试;所有重大的决定，必须在基于测试数据的基础上做决定;
5. 无锁的实现比基于锁的算法有更好短吞吐量;
</code></pre></div></div><h3 id="clh是什么怎么实现">CLH是什么？怎么实现</h3><p>前情提要</p><p>1、SMP(Symmetric Multi-Processor)</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  SMP（Symmetric Multi-Processing）对称多处理器结构，指服务器中多个CPU对称工作，每个CPU访问内存地址所需时间相同。其主要特征是共享，包含对CPU，内存，I/O等进行共享。

  SMP能够保证内存一致性，但这些共享的资源很可能成为性能瓶颈，随着CPU数量的增加，每个CPU都要访问相同的内存资源，可能导致内存访问冲突，

  可能会导致CPU资源的浪费。常用的PC机就属于这种。
</code></pre></div></div><p>2、NUMA(Non-Uniform Memory Access)</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  非一致存储访问，将CPU分为CPU模块，每个CPU模块由多个CPU组成，并且具有独立的本地内存、I/O槽口等，模块之间可以通过互联模块相互访问，访问本地内存的速度将远远高于访问远地内存(系统内其它节点的内存)的速度，这也是非一致存储访问的由来。NUMA较好地解决SMP的扩展问题，

  当CPU数量增加时，因为访问远地内存的延时远远超过本地内存，系统性能无法线性增加。
</code></pre></div></div><p>CLH(Craig, Landin, and Hagersten locks): 是一个自旋锁，能确保无饥饿性，提供先来先服务的公平性。</p><p>CLH锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  当一个线程需要获取锁时：

  a.创建一个的QNode，将其中的locked设置为true表示需要获取锁
  b.线程对tail域调用getAndSet方法，使自己成为队列的尾部，同时获取一个指向其前趋结点的引用myPred
  c.该线程就在前趋结点的locked字段上旋转，直到前趋结点释放锁
  d.当一个线程需要释放锁时，将当前结点的locked域设置为false，同时回收前趋结点
</code></pre></div></div><p>如下图，线程A需要获取锁，其myNode域为true，tail指向线程A的结点，然后线程B也加入到线程A后面，tail指向线程B的结点。 然后线程A和B都在其myPred域上旋转，一旦它的myPred结点的locked字段变为false，它就可以获取锁。 明显线程A的myPred locked域为false，此时线程A获取到了锁。</p><p><img src="../../public/image/concurrent/CLH.png" alt="" /></p><p>实现</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CLHLock</span> <span class="kd">implements</span> <span class="nc">Lock</span> <span class="o">{</span>  
    <span class="nc">AtomicReference</span><span class="o">&lt;</span><span class="nc">QNode</span><span class="o">&gt;</span> <span class="n">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AtomicReference</span><span class="o">&lt;</span><span class="nc">QNode</span><span class="o">&gt;(</span><span class="k">new</span> <span class="nc">QNode</span><span class="o">());</span>  
    <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">QNode</span><span class="o">&gt;</span> <span class="n">myPred</span><span class="o">;</span>  
    <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">QNode</span><span class="o">&gt;</span> <span class="n">myNode</span><span class="o">;</span>  
  
    <span class="kd">public</span> <span class="nf">CLHLock</span><span class="o">()</span> <span class="o">{</span>  
        <span class="n">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AtomicReference</span><span class="o">&lt;</span><span class="nc">QNode</span><span class="o">&gt;(</span><span class="k">new</span> <span class="nc">QNode</span><span class="o">());</span>  
        <span class="n">myNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">QNode</span><span class="o">&gt;()</span> <span class="o">{</span>  
            <span class="kd">protected</span> <span class="nc">QNode</span> <span class="nf">initialValue</span><span class="o">()</span> <span class="o">{</span>  
                <span class="k">return</span> <span class="k">new</span> <span class="nf">QNode</span><span class="o">();</span>  
            <span class="o">}</span>  
        <span class="o">};</span>  
        <span class="n">myPred</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">QNode</span><span class="o">&gt;()</span> <span class="o">{</span>  
            <span class="kd">protected</span> <span class="nc">QNode</span> <span class="nf">initialValue</span><span class="o">()</span> <span class="o">{</span>  
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>  
            <span class="o">}</span>  
        <span class="o">};</span>  
    <span class="o">}</span>  
  
    <span class="nd">@Override</span>  
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>  
        <span class="nc">QNode</span> <span class="n">qnode</span> <span class="o">=</span> <span class="n">myNode</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>  
        <span class="n">qnode</span><span class="o">.</span><span class="na">locked</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>  
        <span class="nc">QNode</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="na">getAndSet</span><span class="o">(</span><span class="n">qnode</span><span class="o">);</span>  
        <span class="n">myPred</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">pred</span><span class="o">);</span>  
        <span class="k">while</span> <span class="o">(</span><span class="n">pred</span><span class="o">.</span><span class="na">locked</span><span class="o">)</span> <span class="o">{</span>  
        <span class="o">}</span>  
    <span class="o">}</span>  
  
    <span class="nd">@Override</span>  
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span>  
        <span class="nc">QNode</span> <span class="n">qnode</span> <span class="o">=</span> <span class="n">myNode</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>  
        <span class="n">qnode</span><span class="o">.</span><span class="na">locked</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>  
        <span class="n">myNode</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">myPred</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><p>CLH队列锁的优点是空间复杂度低（如果有n个线程，L个锁，每个线程每次只获取一个锁，那么需要的存储空间是O（L+n），n个线程有n个。myNode，L个锁有L个tail），CLH的一种变体被应用在了JAVA并发框架中。</p><p>CLH在SMP系统结构下该方法是非常有效的。但在NUMA系统结构下，每个线程有自己的内存，如果前趋结点的内存位置比较远，自旋判断前趋结点的locked域，性能将大打折扣，一种解决NUMA系统结构的思路是MCS队列锁。</p><h3 id="mcs是什么怎么实现">MCS是什么？怎么实现</h3><p>MSC与CLH最大的不同并不是链表是显示还是隐式，而是线程自旋的规则不同:CLH是在前趋结点的locked域上自旋等待，而MSC是在自己的结点的locked域上自旋等待。正因为如此，它解决了CLH在NUMA系统架构中获取locked域状态内存过远的问题。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  MCS队列锁的具体实现如下：

  a. 队列初始化时没有结点，tail=null
  b. 线程A想要获取锁，于是将自己置于队尾，由于它是第一个结点，它的locked域为false
  c. 线程B和C相继加入队列，a-&gt;next=b,b-&gt;next=c。且B和C现在没有获取锁，处于等待状态，所以它们的locked域为true，尾指针指向线程C对应的结点
  d. 线程A释放锁后，顺着它的next指针找到了线程B，并把B的locked域设置为false。这一动作会触发线程B获取锁
</code></pre></div></div><p><img src="../../public/image/concurrent/MCS.jpg" alt="" /></p><p>实现</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MCSLock</span> <span class="kd">implements</span> <span class="nc">Lock</span> <span class="o">{</span>
    <span class="nc">AtomicReference</span><span class="o">&lt;</span><span class="nc">QNode</span><span class="o">&gt;</span> <span class="n">tail</span><span class="o">;</span>
    <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">QNode</span><span class="o">&gt;</span> <span class="n">myNode</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">QNode</span> <span class="n">qnode</span> <span class="o">=</span> <span class="n">myNode</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="nc">QNode</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="na">getAndSet</span><span class="o">(</span><span class="n">qnode</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">pred</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">qnode</span><span class="o">.</span><span class="na">locked</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">qnode</span><span class="o">;</span>

            <span class="c1">// wait until predecessor gives up the lock</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">qnode</span><span class="o">.</span><span class="na">locked</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">QNode</span> <span class="n">qnode</span> <span class="o">=</span> <span class="n">myNode</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">qnode</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">tail</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">qnode</span><span class="o">,</span> <span class="kc">null</span><span class="o">))</span>
                <span class="k">return</span><span class="o">;</span>
            
            <span class="c1">// wait until predecessor fills in its next field</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">qnode</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">qnode</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">locked</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="n">qnode</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">class</span> <span class="nc">QNode</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">locked</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="nc">QNode</span> <span class="n">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><a href="https://www.cnblogs.com/llkmst/p/4895478.html">参考1</a></p><p><a href="http://ifeve.com/lock-based-vs-lock-free-concurren/#more-8038">参考2</a></p><p><a href="http://ifeve.com/jdk8%e4%b8%adstampedlock%e5%8e%9f%e7%90%86%e6%8e%a2%e7%a9%b6/#more-34646">参考3</a></p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://blog.dreamylost.cn" target="_blank">梦境迷离</a></li><li>本文链接：<a href="https://blog.dreamylost.cn/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91-StampedLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90.html" target="_blank">https://blog.dreamylost.cn/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91-StampedLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90.html</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91-StampedLock', clientID: '061aadb5d449c0877d7d', clientSecret: '9aa7af7c248a7e36a07a86993e11a7acf7fbd353', repo: 'dreamylost-comments', owner: 'jxnu-liguobin', admin: ['jxnu-liguobin'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@built/assets/search_data.json?v=1697170576', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"> <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-8236444920328818" data-ad-slot="6220614560" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2019 <span title="梦境迷离">梦境迷离</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/jxnu-liguobin/jxnu-liguobin.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://blog.dreamylost.cn/" title="首页" target="">首页</a></li><li> <a href="https://blog.dreamylost.cn/categories/" title="分类" target="">分类</a></li><li> <a href="https://blog.dreamylost.cn/archives/" title="归档" target="">归档</a></li><li> <a href="https://blog.dreamylost.cn/open-source/" title="开源" target="">开源</a></li><li> <a href="https://blog.dreamylost.cn/wiki/" title="维基" target="">维基</a></li><li> <a href="https://blog.dreamylost.cn/links/" title="链接" target="">链接</a></li><li> <a href="https://blog.dreamylost.cn/about/" title="关于" target="">关于</a></li><li><a href="https://blog.dreamylost.cn/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2019-09-20 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-147390701-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
