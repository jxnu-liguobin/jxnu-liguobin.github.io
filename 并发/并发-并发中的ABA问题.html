<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>并发中的ABA问题 &mdash; 梦境迷离</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="canonical" href="https://dreamylost.cn/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E4%B8%AD%E7%9A%84ABA%E9%97%AE%E9%A2%98.html"><link rel="alternate" type="application/atom+xml" title="梦境迷离" href="https://dreamylost.cn/feed.xml"><link rel="shortcut icon" href="https://dreamylost.cn/favicon.ico"><meta property="og:title" content="并发中的ABA问题"><meta name="keywords" content="梦境迷离, jxnu-liguobin"><meta name="og:keywords" content="梦境迷离, jxnu-liguobin"><meta name="description" content=""><meta name="og:description" content=""><meta property="og:url" content="https://dreamylost.cn/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E4%B8%AD%E7%9A%84ABA%E9%97%AE%E9%A2%98.html"><meta property="og:site_name" content="梦境迷离"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2020-11-05"> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/main.js"></script> <script data-ad-client="ca-pub-8236444920328818" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://dreamylost.cn/" title="梦境迷离"><span class="octicon octicon-mark-github"></span> 梦境迷离</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://dreamylost.cn/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://dreamylost.cn/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://dreamylost.cn/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://dreamylost.cn/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://dreamylost.cn/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="并发中的ABA问题"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">并发中的ABA问题</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2020/11/05 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://dreamylost.cn/categories/#并发" title="并发">并发</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 4727 字，约 14 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"> <img style="height:72px;width:72px" src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/images/qrcode.jpg" alt="梦境迷离" /></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" > <ins class="adsbygoogle content-header-ad" data-ad-client="ca-pub-8236444920328818" data-ad-slot="3977594606"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> <br /><article class="article-content markdown-body"><ul id="markdown-toc"><li><a href="#比较和交换" id="markdown-toc-比较和交换">比较和交换</a></li><li><a href="#aba问题" id="markdown-toc-aba问题">ABA问题</a><ul><li><a href="#一个示例" id="markdown-toc-一个示例">一个示例</a></li><li><a href="#哪里有问题" id="markdown-toc-哪里有问题">哪里有问题</a></li></ul></li><li><a href="#java示例" id="markdown-toc-java示例">Java示例</a><ul><li><a href="#账户" id="markdown-toc-账户">账户</a></li><li><a href="#存款" id="markdown-toc-存款">存款</a></li><li><a href="#提款" id="markdown-toc-提款">提款</a></li><li><a href="#aba方案" id="markdown-toc-aba方案">ABA方案</a></li></ul></li><li><a href="#基于值与基于引用的方案" id="markdown-toc-基于值与基于引用的方案">基于值与基于引用的方案</a><ul><li><a href="#基于引用的异常" id="markdown-toc-基于引用的异常">基于引用的异常</a></li></ul></li><li><a href="#解决方案" id="markdown-toc-解决方案">解决方案</a><ul><li><a href="#垃圾收集" id="markdown-toc-垃圾收集">垃圾收集</a></li><li><a href="#危险指示器" id="markdown-toc-危险指示器">危险指示器</a></li><li><a href="#不变性" id="markdown-toc-不变性">不变性</a></li><li><a href="#双重比较和交换" id="markdown-toc-双重比较和交换">双重比较和交换</a></li></ul></li></ul><h1 id="比较和交换">比较和交换</h1><p>即compare-and-swap（CAS）</p><p>为了了解根本原因，让我们简要回顾一下“compare-and-swap”的概念。</p><p>CAS是无锁算法中的一种常用技术，<strong>可以确保如果另一个线程同时修改了相同的空间，则一个线程对共享内存的更新将失败。</strong></p><p>我们通过在每次更新中<strong>使用两条信息来实现此目的：更新后的值（newValue）以及原始值（expectedValue）。</strong> 然后CAS将首先将现有值与原始值进行比较。 如果相等，则将现有值与更新后的值交换。</p><p>CAS是一个原子操作，这意味着获取和更新是一个操作。这里重要的是，CAS不获取数据结构上的锁，但是如果更新成功，则返回true，否则返回false。</p><p>以下代码片段概述了CAS的工作方式：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">volatile</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
 
<span class="kt">boolean</span> <span class="nf">cas</span><span class="o">(</span><span class="kt">int</span> <span class="n">expectedValue</span><span class="o">,</span> <span class="kt">int</span> <span class="n">newValue</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">value</span> <span class="o">==</span> <span class="n">expectedValue</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">newValue</span><span class="o">;</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>仅当新值仍具有期望值时，我们才用新值更新该值，否则它将返回false。以下代码片段显示了如何调用CAS：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">testCas</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
 
    <span class="k">while</span><span class="o">(!</span><span class="n">cas</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">x</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>我们尝试更新值，直到CAS操作成功。</p><p><strong>但是，线程有可能陷入饥饿状态。</strong> 如果其他线程同时对同一个变量执行CAS，则可能会发生这种情况，因此该操作永远不会针对特定线程成功（或者将花费不合理的时间才能成功）。但是，如果CAS失败，则我们知道另一个线程已成功，因此，我们也确保了全局进度，这是释放锁所必需的。</p><p><strong>重要的是要注意，硬件应支持CAS，以使其成为真正的原子操作而无需使用锁。</strong></p><p>Java在<code class="language-plaintext highlighter-rouge">sun.misc.Unsafe</code>类中提供了CAS的实现。但是，在大多数情况下，我们不应该直接使用此类，而应使用原子变量（如：<code class="language-plaintext highlighter-rouge">AtomicInteger</code>，<code class="language-plaintext highlighter-rouge">AtomicLong</code>，<code class="language-plaintext highlighter-rouge">AtomicBoolean</code>和<code class="language-plaintext highlighter-rouge">AtomicReference</code>）。</p><p>此外，CAS不能防止A-B-A问题。我们将在下面进行介绍。</p><h1 id="aba问题">ABA问题</h1><p>现在，ABA问题是一个异常，仅比较和交换就使我们失败了。</p><p>例如，假设一个活动读取了一些共享内存（A），以准备对其进行更新。然后，另一个活动临时修改该共享内存（B），然后将其还原（A）。此后，<strong>一旦第一个活动执行了“比较并交换”，它将看起来好像没有进行任何更改，</strong> 从而使检查的完整性无效。</p><p>尽管在很多情况下这不会造成问题，但有时A并不像我们想象的那样等于A。让我们看看实际情况。</p><h2 id="一个示例">一个示例</h2><p>为了通过实际示例演示该问题，让我们研究一个简单的银行帐户类，其中一个整数变量保存实际余额。我们还有两个功能：一个用于提款，一个用于存款。这些操作使用CAS来减少和增加帐户余额。</p><h2 id="哪里有问题">哪里有问题</h2><p>让我们考虑一下线程1和线程2在同一个银行帐户上运行的多线程方案。</p><p>当线程1要取款时，它将读取实际余额，以使用该值稍后比较CAS操作中的金额。但是，由于某种原因，线程1有点慢 – 可能被阻塞了。</p><p><strong>同时，线程2被挂起时，线程2使用相同的机制对帐户执行两项操作。</strong> 首先，它更改了线程1已读取的原始值，然后，将其更改回原始值。</p><p>一旦线程1恢复，它将看起来好像什么都没有改变，并且CAS将成功：</p><p><img src="../../public/image/aba_problem-1.png" alt="" /></p><h1 id="java示例">Java示例</h1><p>为了更好地可视化，让我们看一些代码。在这里，我们将使用Java，但是问题本身并非特定于语言。</p><h2 id="账户">账户</h2><p>首先，我们的Account类将余额保留在<code class="language-plaintext highlighter-rouge">AtomicInteger</code>中，这为我们提供了Java中整数的CAS。此外，还有另一个<code class="language-plaintext highlighter-rouge">AtomicInteger</code>可以计算成功交易的数量。最后，我们有一个<code class="language-plaintext highlighter-rouge">ThreadLocal</code>变量来捕获给定线程的CAS操作失败的次数。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Account</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">AtomicInteger</span> <span class="n">balance</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">AtomicInteger</span> <span class="n">transactionCount</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">currentThreadCASFailureCount</span><span class="o">;</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="存款">存款</h2><p>接下来，我们可以为Account类实现存款方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">deposit</span><span class="o">(</span><span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">current</span> <span class="o">=</span> <span class="n">balance</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="kt">boolean</span> <span class="n">result</span> <span class="o">=</span> <span class="n">balance</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">current</span><span class="o">,</span> <span class="n">current</span> <span class="o">+</span> <span class="n">amount</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">transactionCount</span><span class="o">.</span><span class="na">incrementAndGet</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">currentCASFailureCount</span> <span class="o">=</span> <span class="n">currentThreadCASFailureCount</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="n">currentThreadCASFailureCount</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">currentCASFailureCount</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>请注意，<code class="language-plaintext highlighter-rouge">AtomicInteger.compareAndSet()</code>只是<code class="language-plaintext highlighter-rouge">AtomicInteger.compareAndSwap()</code>方法的包装，以反映CAS操作的布尔结果。</p><h2 id="提款">提款</h2><p>同样，<code class="language-plaintext highlighter-rouge">withdraw</code>方法可以创建为：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">withdraw</span><span class="o">(</span><span class="kt">int</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">current</span> <span class="o">=</span> <span class="n">getBalance</span><span class="o">();</span>
    <span class="n">maybeWait</span><span class="o">();</span>
    <span class="kt">boolean</span> <span class="n">result</span> <span class="o">=</span> <span class="n">balance</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">current</span><span class="o">,</span> <span class="n">current</span> <span class="o">-</span> <span class="n">amount</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">transactionCount</span><span class="o">.</span><span class="na">incrementAndGet</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">currentCASFailureCount</span> <span class="o">=</span> <span class="n">currentThreadCASFailureCount</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="n">currentThreadCASFailureCount</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">currentCASFailureCount</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>为了演示ABA问题，我们创建了一个<code class="language-plaintext highlighter-rouge">maybeWait()</code>方法来保存一些耗时的操作，该操作为其他线程提供了一些额外的时间范围以在余额上进行修改。</p><p>现在，我们将线程1暂停两秒钟：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">maybeWait</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="s">"thread1"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()))</span> <span class="o">{</span>
        <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="aba方案">ABA方案</h2><p>最后，我们可以编写一个单元测试来检查ABA问题是否可能。</p><p>我们要做的是有两个线程，之前的线程1和线程2。线程1将读取余额并被延迟。在线程1处于睡眠状态时，线程2将更改余额，然后将其更改回。</p><p>线程1唤醒后，它就不再是明智的选择，并且其操作仍将成功。</p><p>进行一些初始化之后，我们可以创建线程1，这将需要一些额外的时间来执行CAS操作。完成此操作后，它不会意识到内部状态已更改，因此，CAS失败计数将为0，而不是ABA情况下的预期1：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">abaProblemTest</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// ...</span>
    <span class="nc">Thread</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">assertTrue</span><span class="o">(</span><span class="n">account</span><span class="o">.</span><span class="na">withdraw</span><span class="o">(</span><span class="n">amountToWithdrawByThread1</span><span class="o">));</span>
 
        <span class="n">assertTrue</span><span class="o">(</span><span class="n">account</span><span class="o">.</span><span class="na">getCurrentThreadCASFailureCount</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">);</span> <span class="c1">// test will fail!</span>
    <span class="o">},</span> <span class="s">"thread1"</span><span class="o">);</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div><p>同样，我们可以创建线程2，该线程将在线程1之前完成，并更改帐户余额并将其更改回原始值。在这种情况下，我们预计CAS不会出现任何故障。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">abaProblemTest</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// ...</span>
    <span class="nc">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">assertTrue</span><span class="o">(</span><span class="n">account</span><span class="o">.</span><span class="na">deposit</span><span class="o">(</span><span class="n">amountToDepositByThread2</span><span class="o">));</span>
        <span class="n">assertEquals</span><span class="o">(</span><span class="n">defaultBalance</span> <span class="o">+</span> <span class="n">amountToDepositByThread2</span><span class="o">,</span> <span class="n">account</span><span class="o">.</span><span class="na">getBalance</span><span class="o">());</span>
        <span class="n">assertTrue</span><span class="o">(</span><span class="n">account</span><span class="o">.</span><span class="na">withdraw</span><span class="o">(</span><span class="n">amountToWithdrawByThread2</span><span class="o">));</span>
 
        <span class="n">assertEquals</span><span class="o">(</span><span class="n">defaultBalance</span><span class="o">,</span> <span class="n">account</span><span class="o">.</span><span class="na">getBalance</span><span class="o">());</span>
 
        <span class="n">assertEquals</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">account</span><span class="o">.</span><span class="na">getCurrentThreadCASFailureCount</span><span class="o">());</span>
    <span class="o">},</span> <span class="s">"thread2"</span><span class="o">);</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div><p>运行线程后，线程1将获得预期的余额，尽管它不希望线程2产生额外的两个事务：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">abaProblemTest</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// ...</span>
 
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">defaultBalance</span> <span class="o">-</span> <span class="n">amountToWithdrawByThread1</span><span class="o">,</span> <span class="n">account</span><span class="o">.</span><span class="na">getBalance</span><span class="o">());</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="n">account</span><span class="o">.</span><span class="na">getTransactionCount</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div><h1 id="基于值与基于引用的方案">基于值与基于引用的方案</h1><p>在上面的示例中，我们可以发现一个重要的事实 – 在场景结束时返回的<code class="language-plaintext highlighter-rouge">AtomicInteger</code>与我们开始时使用的完全相同。除了无法捕获线程2进行的两个额外事务之外，在此特定示例中没有发生异常。</p><p>这背后的原因是我们基本上使用了值类型而不是引用类型。</p><h2 id="基于引用的异常">基于引用的异常</h2><p>为了重用引用类型，我们可能会遇到ABA问题。在这种情况下，在ABA方案结束时，我们会获得匹配的引用，因此CAS操作成功，但是，该引用可能指向的对象与原始对象不同。这可能导致歧义。</p><h1 id="解决方案">解决方案</h1><p>现在，我们已经很好地了解了问题所在，下面我们来探讨一些可能的解决方案。</p><h2 id="垃圾收集">垃圾收集</h2><p>对于引用类型，<strong>垃圾回收（GC）可以在大多数时间保护我们免受ABA问题的困扰。</strong></p><p>当线程1在我们正在使用的给定内存地址上有一个对象引用时，那么线程2所做的任何事情都不会导致另一个对象使用该地址。该对象仍然存在，并且在不保留对其引用之前，其地址不会被重用。</p><p>虽然这适用于引用类型，但问题是我们在无锁数据结构中依赖GC。</p><p>当然，某些语言不提供GC也是如此。</p><h2 id="危险指示器">危险指示器</h2><p>即Hazard Pointers</p><p>危险指示器与上一个危险指示器有所关联 – <strong>我们可以在没有自动垃圾收集机制的语言中使用它们。</strong></p><p>简而言之，线程在共享数据结构中跟踪有问题的指针。这样，每个线程都知道指针所定义的给定内存地址上的对象可能已被另一个线程修改。</p><p>现在，让我们来看一些更严格的解决方案。</p><h2 id="不变性">不变性</h2><p>当然，<strong>使用不可变对象可以解决此问题，因为我们不会在整个应用程序中重复使用对象。</strong> 每当发生更改时，都会创建一个新对象，因此CAS肯定会失败。</p><p>但是，我们的最终解决方案还允许使用可变对象。</p><h2 id="双重比较和交换">双重比较和交换</h2><p>即double compare and swap</p><p><strong>双重比较和交换方法的思想是跟踪另一个变量，即版本号，</strong> 然后在比较中也使用它。在这种情况下，如果我们拥有旧版本号，则CAS操作将失败，这仅在其他线程同时修改我们的变量时才可能发生。</p><p>在Java中，<code class="language-plaintext highlighter-rouge">AtomicStampedReference</code>和<code class="language-plaintext highlighter-rouge">AtomicMarkableReference</code>是此方法的标准实现。</p><p><a href="https://www.baeldung.com/lock-free-programming#1-compare-and-swap">Introduction to Lock-Free Data Structures with Java Examples</a></p><p><a href="https://www.baeldung.com/cs/aba-concurrency">The ABA Problem in Concurrency</a></p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://dreamylost.cn" target="_blank">梦境迷离</a></li><li>本文链接：<a href="https://dreamylost.cn/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E4%B8%AD%E7%9A%84ABA%E9%97%AE%E9%A2%98.html" target="_blank">https://dreamylost.cn/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E4%B8%AD%E7%9A%84ABA%E9%97%AE%E9%A2%98.html</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91-%E5%B9%B6%E', clientID: '061aadb5d449c0877d7d', clientSecret: '9aa7af7c248a7e36a07a86993e11a7acf7fbd353', repo: 'dreamylost-comments', owner: 'jxnu-liguobin', admin: ['jxnu-liguobin'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@built/assets/search_data.json?v=1648117392', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"> <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-8236444920328818" data-ad-slot="6220614560" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2019 <span title="梦境迷离">梦境迷离</span> <a href="http://www.beian.miit.gov.cn/publish/query/indexFirst.action" rel="nofollow" target="_blank">赣ICP备17017283号-1</a> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/jxnu-liguobin/jxnu-liguobin.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://dreamylost.cn/" title="首页" target="">首页</a></li><li> <a href="https://dreamylost.cn/categories/" title="分类" target="">分类</a></li><li> <a href="https://dreamylost.cn/wiki/" title="维基" target="">维基</a></li><li> <a href="https://dreamylost.cn/links/" title="链接" target="">链接</a></li><li> <a href="https://dreamylost.cn/about/" title="关于" target="">关于</a></li><li><a href="https://dreamylost.cn/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2019-09-20 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/jxnu-liguobin/jxnu-liguobin.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-147390701-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
